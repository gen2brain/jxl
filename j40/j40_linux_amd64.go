// Code generated by 'ccgo -all-errors -pkgname j40 -ignore-unsupported-alignment -export-externs "" -export-defines "" -export-fields "" -export-structs "" -export-typedefs "" -o j40.go j40.c', DO NOT EDIT.

package j40

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"

	"modernc.org/libc"
	"modernc.org/libc/sys/types"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer
var _ *libc.TLS
var _ types.Size_t

const (
	AIO_PRIO_DELTA_MAX                   = 20
	BC_BASE_MAX                          = 99
	BC_DIM_MAX                           = 2048
	BC_SCALE_MAX                         = 99
	BC_STRING_MAX                        = 1000
	BIG_ENDIAN                           = 4321
	BUFSIZ                               = 8192
	BYTE_ORDER                           = 1234
	CHARCLASS_NAME_MAX                   = 2048
	CHAR_BIT                             = 8
	CHAR_MAX                             = 127
	CHAR_MIN                             = -128
	COLL_WEIGHTS_MAX                     = 255
	DELAYTIMER_MAX                       = 2147483647
	E2BIG                                = 7
	EACCES                               = 13
	EADDRINUSE                           = 98
	EADDRNOTAVAIL                        = 99
	EADV                                 = 68
	EAFNOSUPPORT                         = 97
	EAGAIN                               = 11
	EALREADY                             = 114
	EBADE                                = 52
	EBADF                                = 9
	EBADFD                               = 77
	EBADMSG                              = 74
	EBADR                                = 53
	EBADRQC                              = 56
	EBADSLT                              = 57
	EBFONT                               = 59
	EBUSY                                = 16
	ECANCELED                            = 125
	ECHILD                               = 10
	ECHRNG                               = 44
	ECOMM                                = 70
	ECONNABORTED                         = 103
	ECONNREFUSED                         = 111
	ECONNRESET                           = 104
	EDEADLK                              = 35
	EDEADLOCK                            = 35
	EDESTADDRREQ                         = 89
	EDOM                                 = 33
	EDOTDOT                              = 73
	EDQUOT                               = 122
	EEXIST                               = 17
	EFAULT                               = 14
	EFBIG                                = 27
	EHOSTDOWN                            = 112
	EHOSTUNREACH                         = 113
	EHWPOISON                            = 133
	EIDRM                                = 43
	EILSEQ                               = 84
	EINPROGRESS                          = 115
	EINTR                                = 4
	EINVAL                               = 22
	EIO                                  = 5
	EISCONN                              = 106
	EISDIR                               = 21
	EISNAM                               = 120
	EKEYEXPIRED                          = 127
	EKEYREJECTED                         = 129
	EKEYREVOKED                          = 128
	EL2HLT                               = 51
	EL2NSYNC                             = 45
	EL3HLT                               = 46
	EL3RST                               = 47
	ELIBACC                              = 79
	ELIBBAD                              = 80
	ELIBEXEC                             = 83
	ELIBMAX                              = 82
	ELIBSCN                              = 81
	ELNRNG                               = 48
	ELOOP                                = 40
	EMEDIUMTYPE                          = 124
	EMFILE                               = 24
	EMLINK                               = 31
	EMSGSIZE                             = 90
	EMULTIHOP                            = 72
	ENAMETOOLONG                         = 36
	ENAVAIL                              = 119
	ENETDOWN                             = 100
	ENETRESET                            = 102
	ENETUNREACH                          = 101
	ENFILE                               = 23
	ENOANO                               = 55
	ENOBUFS                              = 105
	ENOCSI                               = 50
	ENODATA                              = 61
	ENODEV                               = 19
	ENOENT                               = 2
	ENOEXEC                              = 8
	ENOKEY                               = 126
	ENOLCK                               = 37
	ENOLINK                              = 67
	ENOMEDIUM                            = 123
	ENOMEM                               = 12
	ENOMSG                               = 42
	ENONET                               = 64
	ENOPKG                               = 65
	ENOPROTOOPT                          = 92
	ENOSPC                               = 28
	ENOSR                                = 63
	ENOSTR                               = 60
	ENOSYS                               = 38
	ENOTBLK                              = 15
	ENOTCONN                             = 107
	ENOTDIR                              = 20
	ENOTEMPTY                            = 39
	ENOTNAM                              = 118
	ENOTRECOVERABLE                      = 131
	ENOTSOCK                             = 88
	ENOTSUP                              = 95
	ENOTTY                               = 25
	ENOTUNIQ                             = 76
	ENXIO                                = 6
	EOF                                  = -1
	EOPNOTSUPP                           = 95
	EOVERFLOW                            = 75
	EOWNERDEAD                           = 130
	EPERM                                = 1
	EPFNOSUPPORT                         = 96
	EPIPE                                = 32
	EPROTO                               = 71
	EPROTONOSUPPORT                      = 93
	EPROTOTYPE                           = 91
	ERANGE                               = 34
	EREMCHG                              = 78
	EREMOTE                              = 66
	EREMOTEIO                            = 121
	ERESTART                             = 85
	ERFKILL                              = 132
	EROFS                                = 30
	ESHUTDOWN                            = 108
	ESOCKTNOSUPPORT                      = 94
	ESPIPE                               = 29
	ESRCH                                = 3
	ESRMNT                               = 69
	ESTALE                               = 116
	ESTRPIPE                             = 86
	ETIME                                = 62
	ETIMEDOUT                            = 110
	ETOOMANYREFS                         = 109
	ETXTBSY                              = 26
	EUCLEAN                              = 117
	EUNATCH                              = 49
	EUSERS                               = 87
	EWOULDBLOCK                          = 11
	EXDEV                                = 18
	EXFULL                               = 54
	EXIT_FAILURE                         = 1
	EXIT_SUCCESS                         = 0
	EXPR_NEST_MAX                        = 32
	FD_SETSIZE                           = 1024
	FILENAME_MAX                         = 4096
	FOPEN_MAX                            = 16
	FP_ILOGB0                            = -2147483648
	FP_ILOGBNAN                          = -2147483648
	FP_INFINITE1                         = 1
	FP_NAN1                              = 0
	FP_NORMAL1                           = 4
	FP_SUBNORMAL1                        = 3
	FP_ZERO1                             = 2
	HOST_NAME_MAX                        = 64
	INT16_MAX                            = 32767
	INT16_MIN                            = -32768
	INT32_MAX                            = 2147483647
	INT32_MIN                            = -2147483648
	INT64_MAX                            = 9223372036854775807
	INT64_MIN                            = -9223372036854775808
	INT8_MAX                             = 127
	INT8_MIN                             = -128
	INTMAX_MAX                           = 9223372036854775807
	INTMAX_MIN                           = -9223372036854775808
	INTPTR_MAX                           = 9223372036854775807
	INTPTR_MIN                           = -9223372036854775808
	INT_FAST16_MAX                       = 9223372036854775807
	INT_FAST16_MIN                       = -9223372036854775808
	INT_FAST32_MAX                       = 9223372036854775807
	INT_FAST32_MIN                       = -9223372036854775808
	INT_FAST64_MAX                       = 9223372036854775807
	INT_FAST64_MIN                       = -9223372036854775808
	INT_FAST8_MAX                        = 127
	INT_FAST8_MIN                        = -128
	INT_LEAST16_MAX                      = 32767
	INT_LEAST16_MIN                      = -32768
	INT_LEAST32_MAX                      = 2147483647
	INT_LEAST32_MIN                      = -2147483648
	INT_LEAST64_MAX                      = 9223372036854775807
	INT_LEAST64_MIN                      = -9223372036854775808
	INT_LEAST8_MAX                       = 127
	INT_LEAST8_MIN                       = -128
	INT_MAX                              = 2147483647
	INT_MIN                              = -2147483648
	J40_API                              = 0
	J40_FILENAME                         = "j40.h"
	J40_IMPLEMENTATION                   = 0
	J40_RGBA                             = 0x1755
	J40_U8X4                             = 0x0f33
	J40_VERSION                          = 2270
	J40__CLANG_VER                       = 0
	J40__COEFFS_ALIGN                    = 64
	J40__ERRBUF_LEN                      = 256
	J40__EXPOSE_INTERNALS                = 0
	J40__GCC_VER                         = 786944
	J40__INITIAL_BUFSIZE                 = 0x10000
	J40__MAX_DIST_MULT                   = 2097152
	J40__PIXELS_ALIGN                    = 32
	J40__RECURSING                       = 9999
	J40__SQRT2                           = 1.4142135623730951
	LINE_MAX                             = 2048
	LITTLE_ENDIAN                        = 1234
	LLONG_MAX                            = 9223372036854775807
	LLONG_MIN                            = -9223372036854775808
	LOGIN_NAME_MAX                       = 256
	LONG_MAX                             = 9223372036854775807
	LONG_MIN                             = -9223372036854775808
	L_ctermid                            = 9
	L_tmpnam                             = 20
	MATH_ERREXCEPT                       = 2
	MATH_ERRNO                           = 1
	MAX_CANON                            = 255
	MAX_INPUT                            = 255
	MB_LEN_MAX                           = 16
	MQ_PRIO_MAX                          = 32768
	M_1_PI                               = 0.31830988618379067154
	M_2_PI                               = 0.63661977236758134308
	M_2_SQRTPI                           = 1.12837916709551257390
	M_E                                  = 2.7182818284590452354
	M_LN10                               = 2.30258509299404568402
	M_LN2                                = 0.69314718055994530942
	M_LOG10E                             = 0.43429448190325182765
	M_LOG2E                              = 1.4426950408889634074
	M_PI                                 = 3.14159265358979323846
	M_PI_2                               = 1.57079632679489661923
	M_PI_4                               = 0.78539816339744830962
	M_SQRT1_2                            = 0.70710678118654752440
	M_SQRT2                              = 1.41421356237309504880
	NAME_MAX                             = 255
	NGROUPS_MAX                          = 65536
	PATH_MAX                             = 4096
	PDP_ENDIAN                           = 3412
	PIPE_BUF                             = 4096
	PTHREAD_DESTRUCTOR_ITERATIONS        = 4
	PTHREAD_KEYS_MAX                     = 1024
	PTHREAD_STACK_MIN                    = 16384
	PTRDIFF_MAX                          = 9223372036854775807
	PTRDIFF_MIN                          = -9223372036854775808
	P_tmpdir                             = "/tmp"
	RAND_MAX                             = 2147483647
	RE_DUP_MAX                           = 32767
	RTSIG_MAX                            = 32
	SCHAR_MAX                            = 127
	SCHAR_MIN                            = -128
	SEEK_CUR                             = 1
	SEEK_END                             = 2
	SEEK_SET                             = 0
	SEM_VALUE_MAX                        = 2147483647
	SHRT_MAX                             = 32767
	SHRT_MIN                             = -32768
	SIG_ATOMIC_MAX                       = 2147483647
	SIG_ATOMIC_MIN                       = -2147483648
	SIZE_MAX                             = 18446744073709551615
	SSIZE_MAX                            = 9223372036854775807
	TMP_MAX                              = 238328
	TTY_NAME_MAX                         = 32
	UCHAR_MAX                            = 255
	UINT16_MAX                           = 65535
	UINT32_MAX                           = 4294967295
	UINT64_MAX                           = 18446744073709551615
	UINT8_MAX                            = 255
	UINTMAX_MAX                          = 18446744073709551615
	UINTPTR_MAX                          = 18446744073709551615
	UINT_FAST16_MAX                      = 18446744073709551615
	UINT_FAST32_MAX                      = 18446744073709551615
	UINT_FAST64_MAX                      = 18446744073709551615
	UINT_FAST8_MAX                       = 255
	UINT_LEAST16_MAX                     = 65535
	UINT_LEAST32_MAX                     = 4294967295
	UINT_LEAST64_MAX                     = 18446744073709551615
	UINT_LEAST8_MAX                      = 255
	UINT_MAX                             = 4294967295
	ULLONG_MAX                           = 18446744073709551615
	ULONG_MAX                            = 18446744073709551615
	USHRT_MAX                            = 65535
	WCHAR_MAX                            = 2147483647
	WCHAR_MIN                            = -2147483648
	WCONTINUED                           = 8
	WEXITED                              = 4
	WINT_MAX                             = 4294967295
	WINT_MIN                             = 0
	WNOHANG                              = 1
	WNOWAIT                              = 0x01000000
	WSTOPPED                             = 2
	WUNTRACED                            = 2
	XATTR_LIST_MAX                       = 65536
	XATTR_NAME_MAX                       = 255
	XATTR_SIZE_MAX                       = 65536
	X_ALLOCA_H                           = 1
	X_ANSI_STDDEF_H                      = 0
	X_ASM_GENERIC_ERRNO_BASE_H           = 0
	X_ASM_GENERIC_ERRNO_H                = 0
	X_ATFILE_SOURCE                      = 1
	X_BITS_ATOMIC_WIDE_COUNTER_H         = 0
	X_BITS_BYTESWAP_H                    = 1
	X_BITS_ENDIANNESS_H                  = 1
	X_BITS_ENDIAN_H                      = 1
	X_BITS_ERRNO_H                       = 1
	X_BITS_FLOATN_COMMON_H               = 0
	X_BITS_FLOATN_H                      = 0
	X_BITS_LIBM_SIMD_DECL_STUBS_H        = 1
	X_BITS_POSIX1_LIM_H                  = 1
	X_BITS_POSIX2_LIM_H                  = 1
	X_BITS_PTHREADTYPES_ARCH_H           = 1
	X_BITS_PTHREADTYPES_COMMON_H         = 1
	X_BITS_STDINT_INTN_H                 = 1
	X_BITS_STDINT_UINTN_H                = 1
	X_BITS_STDIO_LIM_H                   = 1
	X_BITS_TIME64_H                      = 1
	X_BITS_TYPESIZES_H                   = 1
	X_BITS_TYPES_H                       = 1
	X_BITS_TYPES_LOCALE_T_H              = 1
	X_BITS_TYPES___LOCALE_T_H            = 1
	X_BITS_UINTN_IDENTITY_H              = 1
	X_BITS_WCHAR_H                       = 1
	X_BSD_PTRDIFF_T_                     = 0
	X_BSD_SIZE_T_                        = 0
	X_BSD_SIZE_T_DEFINED_                = 0
	X_DEFAULT_SOURCE                     = 1
	X_ENDIAN_H                           = 1
	X_ERRNO_H                            = 1
	X_FEATURES_H                         = 1
	X_FILE_OFFSET_BITS                   = 64
	X_GCC_LIMITS_H_                      = 0
	X_GCC_MAX_ALIGN_T                    = 0
	X_GCC_PTRDIFF_T                      = 0
	X_GCC_SIZE_T                         = 0
	X_GCC_WCHAR_T                        = 0
	X_GCC_WRAP_STDINT_H                  = 0
	X_IOFBF                              = 0
	X_IOLBF                              = 1
	X_IONBF                              = 2
	X_IO_EOF_SEEN                        = 0x0010
	X_IO_ERR_SEEN                        = 0x0020
	X_IO_USER_LOCK                       = 0x8000
	X_LIBC_LIMITS_H_                     = 1
	X_LIMITS_H___                        = 0
	X_LINUX_LIMITS_H                     = 0
	X_LP64                               = 1
	X_MATH_H                             = 1
	X_POSIX2_BC_BASE_MAX                 = 99
	X_POSIX2_BC_DIM_MAX                  = 2048
	X_POSIX2_BC_SCALE_MAX                = 99
	X_POSIX2_BC_STRING_MAX               = 1000
	X_POSIX2_CHARCLASS_NAME_MAX          = 14
	X_POSIX2_COLL_WEIGHTS_MAX            = 2
	X_POSIX2_EXPR_NEST_MAX               = 32
	X_POSIX2_LINE_MAX                    = 2048
	X_POSIX2_RE_DUP_MAX                  = 255
	X_POSIX_AIO_LISTIO_MAX               = 2
	X_POSIX_AIO_MAX                      = 1
	X_POSIX_ARG_MAX                      = 4096
	X_POSIX_CHILD_MAX                    = 25
	X_POSIX_CLOCKRES_MIN                 = 20000000
	X_POSIX_C_SOURCE                     = 200809
	X_POSIX_DELAYTIMER_MAX               = 32
	X_POSIX_HOST_NAME_MAX                = 255
	X_POSIX_LINK_MAX                     = 8
	X_POSIX_LOGIN_NAME_MAX               = 9
	X_POSIX_MAX_CANON                    = 255
	X_POSIX_MAX_INPUT                    = 255
	X_POSIX_MQ_OPEN_MAX                  = 8
	X_POSIX_MQ_PRIO_MAX                  = 32
	X_POSIX_NAME_MAX                     = 14
	X_POSIX_NGROUPS_MAX                  = 8
	X_POSIX_OPEN_MAX                     = 20
	X_POSIX_PATH_MAX                     = 256
	X_POSIX_PIPE_BUF                     = 512
	X_POSIX_RE_DUP_MAX                   = 255
	X_POSIX_RTSIG_MAX                    = 8
	X_POSIX_SEM_NSEMS_MAX                = 256
	X_POSIX_SEM_VALUE_MAX                = 32767
	X_POSIX_SIGQUEUE_MAX                 = 32
	X_POSIX_SOURCE                       = 1
	X_POSIX_SSIZE_MAX                    = 32767
	X_POSIX_STREAM_MAX                   = 8
	X_POSIX_SYMLINK_MAX                  = 255
	X_POSIX_SYMLOOP_MAX                  = 8
	X_POSIX_THREAD_DESTRUCTOR_ITERATIONS = 4
	X_POSIX_THREAD_KEYS_MAX              = 128
	X_POSIX_THREAD_THREADS_MAX           = 64
	X_POSIX_TIMER_MAX                    = 32
	X_POSIX_TTY_NAME_MAX                 = 9
	X_POSIX_TZNAME_MAX                   = 6
	X_PTRDIFF_T                          = 0
	X_PTRDIFF_T_                         = 0
	X_PTRDIFF_T_DECLARED                 = 0
	X_RWLOCK_INTERNAL_H                  = 0
	X_SIZET_                             = 0
	X_SIZE_T                             = 0
	X_SIZE_T_                            = 0
	X_SIZE_T_DECLARED                    = 0
	X_SIZE_T_DEFINED                     = 0
	X_SIZE_T_DEFINED_                    = 0
	X_STDC_PREDEF_H                      = 1
	X_STDDEF_H                           = 0
	X_STDDEF_H_                          = 0
	X_STDINT_H                           = 1
	X_STDIO_H                            = 1
	X_STDLIB_H                           = 1
	X_STRINGS_H                          = 1
	X_STRING_H                           = 1
	X_STRUCT_TIMESPEC                    = 1
	X_SYS_CDEFS_H                        = 1
	X_SYS_SELECT_H                       = 1
	X_SYS_SIZE_T_H                       = 0
	X_SYS_TYPES_H                        = 1
	X_THREAD_MUTEX_INTERNAL_H            = 1
	X_THREAD_SHARED_TYPES_H              = 1
	X_T_PTRDIFF                          = 0
	X_T_PTRDIFF_                         = 0
	X_T_SIZE                             = 0
	X_T_SIZE_                            = 0
	X_T_WCHAR                            = 0
	X_T_WCHAR_                           = 0
	X_VA_LIST_DEFINED                    = 0
	X_WCHAR_T                            = 0
	X_WCHAR_T_                           = 0
	X_WCHAR_T_DECLARED                   = 0
	X_WCHAR_T_DEFINED                    = 0
	X_WCHAR_T_DEFINED_                   = 0
	X_WCHAR_T_H                          = 0
	Linux                                = 1
	Math_errhandling                     = 3
	Unix                                 = 1
)

// All floating-point numbers can be put in one of these categories.
const (
	FP_NAN       = 0
	FP_INFINITE  = 1
	FP_ZERO      = 2
	FP_SUBNORMAL = 3
	FP_NORMAL    = 4
)

const (
	J40__MAX_TYPICAL_FAST_LEN = 7
)
const (
	J40__MAX_TABLE_GROWTH = 2
)

const (
	J40__DIST_BITS      = 12
	J40__ANS_INIT_STATE = 1245184
)

const (
	J40__CHROMA_WHITE = 0
	J40__CHROMA_RED   = 1
	J40__CHROMA_GREEN = 2
	J40__CHROMA_BLUE  = 3
)

const (
	J40__NUM_PRED = 14
)

const (
	J40__NUM_DCT_SELECT = 27
	J40__NUM_DCT_PARAMS = 17
	J40__NUM_ORDERS     = 13
)

const (
	J40__MAX_PASSES = 11
)

const (
	J40__BLEND_REPLACE = 0
	J40__BLEND_ADD     = 1
	J40__BLEND_BLEND   = 2
	J40__BLEND_MUL_ADD = 3
	J40__BLEND_MUL     = 4
)

const (
	J40__ORIGIN_NONE           = 0
	J40__ORIGIN_NEXT           = 1
	J40__ORIGIN_from_file      = 2
	J40__ORIGIN_from_memory    = 3
	J40__ORIGIN_output_format  = 4
	J40__ORIGIN_next_frame     = 5
	J40__ORIGIN_current_frame  = 6
	J40__ORIGIN_frame_pixels   = 7
	J40__ORIGIN_error_string   = 8
	J40__ORIGIN_free           = 9
	J40__ORIGIN_MAX            = 10
	J40__ORIGIN_LAST_ALT_MAGIC = 3
)

const (
	J40__PLANE_U8  = 32
	J40__PLANE_U16 = 33
	J40__PLANE_I16 = 65
	J40__PLANE_U32 = 34
	J40__PLANE_I32 = 66
	J40__PLANE_F32 = 98
)

const (
	J40__PLANE_CLEAR = 1

	J40__PLANE_FORCE_PAD = 2
)

type Ptrdiff_t = int64

type Size_t = uint64

type Wchar_t = int32

type X__int128_t = struct {
	Lo int64
	Hi int64
}
type X__uint128_t = struct {
	Lo uint64
	Hi uint64
}

type X__builtin_va_list = uintptr
type X__float128 = float64

// Type whose alignment is supported in every context and is at least
//
//	as great as that of any standard type not using alignment
//	specifiers.
type Max_align_t = struct {
	X__max_align_ll int64
	X__max_align_ld float64
}

// Convenience types.
type X__u_char = uint8
type X__u_short = uint16
type X__u_int = uint32
type X__u_long = uint64

// Fixed-size types, underlying types depend on word size and compiler.
type X__int8_t = int8
type X__uint8_t = uint8
type X__int16_t = int16
type X__uint16_t = uint16
type X__int32_t = int32
type X__uint32_t = uint32
type X__int64_t = int64
type X__uint64_t = uint64

// Smallest types with at least a given width.
type X__int_least8_t = X__int8_t
type X__uint_least8_t = X__uint8_t
type X__int_least16_t = X__int16_t
type X__uint_least16_t = X__uint16_t
type X__int_least32_t = X__int32_t
type X__uint_least32_t = X__uint32_t
type X__int_least64_t = X__int64_t
type X__uint_least64_t = X__uint64_t

// quad_t is also 64 bits.
type X__quad_t = int64
type X__u_quad_t = uint64

// Largest integral types.
type X__intmax_t = int64
type X__uintmax_t = uint64

type X__dev_t = uint64
type X__uid_t = uint32
type X__gid_t = uint32
type X__ino_t = uint64
type X__ino64_t = uint64
type X__mode_t = uint32
type X__nlink_t = uint64
type X__off_t = int64
type X__off64_t = int64
type X__pid_t = int32
type X__fsid_t = struct{ X__val [2]int32 }
type X__clock_t = int64
type X__rlim_t = uint64
type X__rlim64_t = uint64
type X__id_t = uint32
type X__time_t = int64
type X__useconds_t = uint32
type X__suseconds_t = int64
type X__suseconds64_t = int64

type X__daddr_t = int32
type X__key_t = int32

// Clock ID used in clock and timer functions.
type X__clockid_t = int32

// Timer ID returned by `timer_create'.
type X__timer_t = uintptr

// Type to represent block size.
type X__blksize_t = int64

// Type to count number of disk blocks.
type X__blkcnt_t = int64
type X__blkcnt64_t = int64

// Type to count file system blocks.
type X__fsblkcnt_t = uint64
type X__fsblkcnt64_t = uint64

// Type to count file system nodes.
type X__fsfilcnt_t = uint64
type X__fsfilcnt64_t = uint64

// Type of miscellaneous file system fields.
type X__fsword_t = int64

type X__ssize_t = int64

// Signed long type used in system calls.
type X__syscall_slong_t = int64

// Unsigned long type used in system calls.
type X__syscall_ulong_t = uint64

// These few don't really vary by system, they always correspond
//
//	to one of the other defined types.
type X__loff_t = X__off64_t
type X__caddr_t = uintptr

// Duplicates info from stdint.h but this is used in unistd.h.
type X__intptr_t = int64

// Duplicate info from sys/socket.h.
type X__socklen_t = uint32

// C99: An integer type that can be accessed as an atomic entity,
//
//	even in the presence of asynchronous interrupts.
//	It is not currently necessary for this to be machine-specific.
type X__sig_atomic_t = int32

type Int8_t = X__int8_t
type Int16_t = X__int16_t
type Int32_t = X__int32_t
type Int64_t = X__int64_t

type Uint8_t = X__uint8_t
type Uint16_t = X__uint16_t
type Uint32_t = X__uint32_t
type Uint64_t = X__uint64_t

// Signed.
type Int_least8_t = X__int_least8_t
type Int_least16_t = X__int_least16_t
type Int_least32_t = X__int_least32_t
type Int_least64_t = X__int_least64_t

// Unsigned.
type Uint_least8_t = X__uint_least8_t
type Uint_least16_t = X__uint_least16_t
type Uint_least32_t = X__uint_least32_t
type Uint_least64_t = X__uint_least64_t

// Signed.
type Int_fast8_t = int8
type Int_fast16_t = int64
type Int_fast32_t = int64
type Int_fast64_t = int64

// Unsigned.
type Uint_fast8_t = uint8
type Uint_fast16_t = uint64
type Uint_fast32_t = uint64
type Uint_fast64_t = uint64

// Types for `void *' pointers.
type Intptr_t = int64
type Uintptr_t = uint64

// Largest integral types.
type Intmax_t = X__intmax_t
type Uintmax_t = X__uintmax_t

// Returned by `div'.
type Div_t = struct {
	Quot int32
	Rem  int32
}

// Returned by `ldiv'.
type Ldiv_t = struct {
	Quot int64
	Rem  int64
}

// Returned by `lldiv'.
type Lldiv_t = struct {
	Quot int64
	Rem  int64
}

type U_char = X__u_char
type U_short = X__u_short
type U_int = X__u_int
type U_long = X__u_long
type Quad_t = X__quad_t
type U_quad_t = X__u_quad_t
type Fsid_t = X__fsid_t
type Loff_t = X__loff_t

type Ino_t = X__ino64_t

type Dev_t = X__dev_t

type Gid_t = X__gid_t

type Mode_t = X__mode_t

type Nlink_t = X__nlink_t

type Uid_t = X__uid_t

type Off_t = X__off64_t

type Pid_t = X__pid_t

type Id_t = X__id_t

type Ssize_t = X__ssize_t

type Daddr_t = X__daddr_t
type Caddr_t = X__caddr_t

type Key_t = X__key_t

// Returned by `clock'.
type Clock_t = X__clock_t

// Clock ID used in clock and timer functions.
type Clockid_t = X__clockid_t

// Returned by `time'.
type Time_t = X__time_t

// Timer ID returned by `timer_create'.
type Timer_t = X__timer_t

// Old compatibility names for C types.
type Ulong = uint64
type Ushort = uint16
type Uint = uint32

// These were defined by ISO C without the first `_'.
type U_int8_t = X__uint8_t
type U_int16_t = X__uint16_t
type U_int32_t = X__uint32_t
type U_int64_t = X__uint64_t

type Register_t = int32

type X__sigset_t = struct{ X__val [16]uint64 }

// A set of signals to be blocked, unblocked, or waited for.
type Sigset_t = X__sigset_t

// A time value that is accurate to the nearest
//
//	microsecond but also has a range of years.
type Timeval = struct {
	Tv_sec  X__time_t
	Tv_usec X__suseconds_t
}

// POSIX.1b structure for a time value.  This is like a `struct timeval' but
//
//	has nanoseconds instead of microseconds.
type Timespec = struct {
	Tv_sec  X__time_t
	Tv_nsec X__syscall_slong_t
}

type Suseconds_t = X__suseconds_t

// The fd_set member is required to be an array of longs.
type X__fd_mask = int64

// fd_set for select and pselect.
type Fd_set = struct{ X__fds_bits [16]X__fd_mask }

// Sometimes the fd_set member is assumed to have this type.
type Fd_mask = X__fd_mask

type Blksize_t = X__blksize_t

// Types from the Large File Support interface.
type Blkcnt_t = X__blkcnt64_t
type Fsblkcnt_t = X__fsblkcnt64_t
type Fsfilcnt_t = X__fsfilcnt64_t

// Counter that is monotonically increasing (by less than 2**31 per
//
//	increment), with a single writer, and an arbitrary number of
//	readers.
type X__atomic_wide_counter = struct{ X__value64 uint64 }

type X__pthread_internal_list = struct {
	X__prev uintptr
	X__next uintptr
}

type X__pthread_list_t = X__pthread_internal_list

type X__pthread_internal_slist = struct{ X__next uintptr }

type X__pthread_slist_t = X__pthread_internal_slist

type X__pthread_mutex_s = struct {
	X__lock    int32
	X__count   uint32
	X__owner   int32
	X__nusers  uint32
	X__kind    int32
	X__spins   int16
	X__elision int16
	X__list    X__pthread_list_t
}

type X__pthread_rwlock_arch_t = struct {
	X__readers       uint32
	X__writers       uint32
	X__wrphase_futex uint32
	X__writers_futex uint32
	X__pad3          uint32
	X__pad4          uint32
	X__cur_writer    int32
	X__shared        int32
	X__rwelision     int8
	X__pad1          [7]uint8
	X__pad2          uint64
	X__flags         uint32
	__ccgo_pad1      [4]byte
}

type X__pthread_cond_s = struct {
	X__wseq         X__atomic_wide_counter
	X__g1_start     X__atomic_wide_counter
	X__g_refs       [2]uint32
	X__g_size       [2]uint32
	X__g1_orig_size uint32
	X__wrefs        uint32
	X__g_signals    [2]uint32
}

type X__tss_t = uint32
type X__thrd_t = uint64

type X__once_flag = struct{ X__data int32 }

// Thread identifiers.  The structure of the attribute type is not
//
//	exposed on purpose.
type Pthread_t = uint64

// Data structures for mutex handling.  The structure of the attribute
//
//	type is not exposed on purpose.
type Pthread_mutexattr_t = struct {
	__ccgo_pad1 [0]uint32
	X__size     [4]int8
}

// Data structure for condition variable handling.  The structure of
//
//	the attribute type is not exposed on purpose.
type Pthread_condattr_t = struct {
	__ccgo_pad1 [0]uint32
	X__size     [4]int8
}

// Keys for thread-specific data
type Pthread_key_t = uint32

// Once-only execution
type Pthread_once_t = int32

type Pthread_attr_t1 = struct {
	__ccgo_pad1 [0]uint64
	X__size     [56]int8
}

type Pthread_attr_t = Pthread_attr_t1

type Pthread_mutex_t = struct{ X__data X__pthread_mutex_s }

type Pthread_cond_t = struct{ X__data X__pthread_cond_s }

// Data structure for reader-writer lock variable handling.  The
//
//	structure of the attribute type is deliberately not exposed.
type Pthread_rwlock_t = struct{ X__data X__pthread_rwlock_arch_t }

type Pthread_rwlockattr_t = struct {
	__ccgo_pad1 [0]uint64
	X__size     [8]int8
}

// POSIX spinlock data type.
type Pthread_spinlock_t = int32

// POSIX barriers data type.  The structure of the type is
//
//	deliberately not exposed.
type Pthread_barrier_t = struct {
	__ccgo_pad1 [0]uint64
	X__size     [32]int8
}

type Pthread_barrierattr_t = struct {
	__ccgo_pad1 [0]uint32
	X__size     [4]int8
}

type Random_data = struct {
	Fptr        uintptr
	Rptr        uintptr
	State       uintptr
	Rand_type   int32
	Rand_deg    int32
	Rand_sep    int32
	__ccgo_pad1 [4]byte
	End_ptr     uintptr
}

// Data structure for communication with thread safe versions.  This
//
//	type is to be regarded as opaque.  It's only exported because users
//	have to allocate objects of this type.
type Drand48_data = struct {
	X__x     [3]uint16
	X__old_x [3]uint16
	X__c     uint16
	X__init  uint16
	X__a     uint64
}

// Shorthand for type of comparison functions.
type X__compar_fn_t = uintptr

type X__locale_struct = struct {
	X__locales       [13]uintptr
	X__ctype_b       uintptr
	X__ctype_tolower uintptr
	X__ctype_toupper uintptr
	X__names         [13]uintptr
}

type X__locale_t = uintptr

type Locale_t = X__locale_t

// Define the following typedefs.
//
//	    float_t	floating-point type at least as wide as `float' used
//			to evaluate `float' expressions
//	    double_t	floating-point type at least as wide as `double' used
//			to evaluate `double' expressions
type Float_t = float32
type Double_t = float64

type X__gnuc_va_list = X__builtin_va_list

// Conversion state information.
type X__mbstate_t = struct {
	X__count int32
	X__value struct{ X__wch uint32 }
}

// The tag name of this struct is _G_fpos_t to preserve historic
//
//	C++ mangled names for functions taking fpos_t arguments.
//	That name should not be used in new code.
type X_G_fpos_t = struct {
	X__pos   X__off_t
	X__state X__mbstate_t
}

// The tag name of this struct is _G_fpos_t to preserve historic
//
//	C++ mangled names for functions taking fpos_t arguments.
//	That name should not be used in new code.
type X__fpos_t = X_G_fpos_t

// The tag name of this struct is _G_fpos64_t to preserve historic
//
//	C++ mangled names for functions taking fpos_t and/or fpos64_t
//	arguments.  That name should not be used in new code.
type X_G_fpos64_t = struct {
	X__pos   X__off64_t
	X__state X__mbstate_t
}

// The tag name of this struct is _G_fpos64_t to preserve historic
//
//	C++ mangled names for functions taking fpos_t and/or fpos64_t
//	arguments.  That name should not be used in new code.
type X__fpos64_t = X_G_fpos64_t

type X_IO_FILE = struct {
	X_flags          int32
	__ccgo_pad1      [4]byte
	X_IO_read_ptr    uintptr
	X_IO_read_end    uintptr
	X_IO_read_base   uintptr
	X_IO_write_base  uintptr
	X_IO_write_ptr   uintptr
	X_IO_write_end   uintptr
	X_IO_buf_base    uintptr
	X_IO_buf_end     uintptr
	X_IO_save_base   uintptr
	X_IO_backup_base uintptr
	X_IO_save_end    uintptr
	X_markers        uintptr
	X_chain          uintptr
	X_fileno         int32
	X_flags2         int32
	X_old_offset     X__off_t
	X_cur_column     uint16
	X_vtable_offset  int8
	X_shortbuf       [1]int8
	__ccgo_pad2      [4]byte
	X_lock           uintptr
	X_offset         X__off64_t
	X_codecvt        uintptr
	X_wide_data      uintptr
	X_freeres_list   uintptr
	X_freeres_buf    uintptr
	X__pad5          Size_t
	X_mode           int32
	X_unused2        [20]int8
}

type X__FILE = X_IO_FILE

// The opaque type of streams.  This is the definition used elsewhere.
type FILE = X_IO_FILE

type Va_list = X__gnuc_va_list

// The type of the second argument to `fgetpos' and `fsetpos'.
type Fpos_t = X__fpos64_t

// an internal error type. non-zero indicates a different error condition.
// user callbacks can also emit error codes, which should not exceed `J40_MIN_RESERVED_ERR`.
// it can be interpreted as a four-letter code, but such encoding is not guaranteed.
type J40_err = Uint32_t

type J40__inner1 = struct {
	Magic        Uint32_t
	Origin       J40__origin
	Err          J40_err
	Saved_errno  int32
	Cannot_retry int32
	Errbuf       [256]int8
	State        int32
	Bits         struct {
		Nbits       Int32_t
		__ccgo_pad1 [4]byte
		Bits        Uint64_t
		Ptr         uintptr
		End         uintptr
	}
	Source struct {
		Read_func     J40_source_read_func
		Seek_func     J40_source_seek_func
		Free_func     J40_source_free_func
		Data          uintptr
		Fileoff       Int64_t
		Fileoff_limit Int64_t
	}
	Container struct {
		Flags       uint32
		__ccgo_pad1 [4]byte
		Map         uintptr
		Nmap        Int32_t
		Map_cap     Int32_t
	}
	Buffer struct {
		Buf           uintptr
		Size          Int64_t
		Capacity      Int64_t
		Next_codeoff  Int64_t
		Codeoff_limit Int64_t
		Checkpoint    J40__bits_st
	}
	Image struct {
		Width                 Int32_t
		Height                Int32_t
		Orientation           uint32
		Intr_width            Int32_t
		Intr_height           Int32_t
		Bpp                   int32
		Exp_bits              int32
		Anim_tps_num          Int32_t
		Anim_tps_denom        Int32_t
		__ccgo_pad1           [4]byte
		Anim_nloops           Int64_t
		Anim_have_timecodes   int32
		__ccgo_pad2           [4]byte
		Icc                   uintptr
		Iccsize               Size_t
		Cspace                uint32
		Cpoints               [4][2]float32
		Gamma_or_tf           int32
		Render_intent         uint32
		Intensity_target      float32
		Min_nits              float32
		Linear_below          float32
		Modular_16bit_buffers int32
		Num_extra_channels    int32
		Ec_info               uintptr
		Xyb_encoded           int32
		Opsin_inv_mat         [3][3]float32
		Opsin_bias            [3]float32
		Quant_bias            [3]float32
		Quant_bias_num        float32
		Want_icc              int32
	}
	Frame struct {
		Is_last               int32
		Type                  uint32
		Is_modular            int32
		Has_noise             int32
		Has_patches           int32
		Has_splines           int32
		Use_lf_frame          int32
		Skip_adapt_lf_smooth  int32
		Do_ycbcr              int32
		Jpeg_upsampling       Int32_t
		Log_upsampling        Int32_t
		__ccgo_pad1           [4]byte
		Ec_log_upsampling     uintptr
		Group_size_shift      Int32_t
		X_qm_scale            Int32_t
		B_qm_scale            Int32_t
		Num_passes            Int32_t
		Shift                 [11]Int8_t
		Log_ds                [12]Int8_t
		__ccgo_pad2           [1]byte
		Lf_level              Int32_t
		X0                    Int32_t
		Y0                    Int32_t
		Width                 Int32_t
		Height                Int32_t
		__ccgo_pad3           [4]byte
		Num_groups            Int64_t
		Num_groups_per_row    Int64_t
		Num_lf_groups         Int64_t
		Num_lf_groups_per_row Int64_t
		Duration              Int64_t
		Timecode              Int64_t
		Blend_info            J40__blend_info
		__ccgo_pad4           [4]byte
		Ec_blend_info         uintptr
		Save_as_ref           Int32_t
		Save_before_ct        int32
		Name_len              Int32_t
		__ccgo_pad5           [4]byte
		Name                  uintptr
		Gab                   struct {
			Enabled int32
			Weights [3][2]float32
		}
		Epf struct {
			Iters             Int32_t
			Sharp_lut         [8]float32
			Channel_scale     [3]float32
			Quant_mul         float32
			Pass0_sigma_scale float32
			Pass2_sigma_scale float32
			Border_sad_mul    float32
			Sigma_for_modular float32
		}
		M_lf_scaled       [3]float32
		__ccgo_pad6       [4]byte
		Global_tree       uintptr
		Global_codespec   J40__code_spec
		Gmodular          J40__modular
		Num_gm_channels   Int32_t
		Global_scale      Int32_t
		Quant_lf          Int32_t
		Lf_thr            [3][15]Int32_t
		Qf_thr            [15]Int32_t
		Nb_lf_thr         [3]Int32_t
		Nb_qf_thr         Int32_t
		__ccgo_pad7       [4]byte
		Block_ctx_map     uintptr
		Block_ctx_size    Int32_t
		Nb_block_ctx      Int32_t
		Inv_colour_factor float32
		X_factor_lf       Int32_t
		B_factor_lf       Int32_t
		Base_corr_x       float32
		Base_corr_b       float32
		Dct_select_used   Int32_t
		Dct_select_loaded Int32_t
		Order_used        Int32_t
		Order_loaded      Int32_t
		__ccgo_pad8       [4]byte
		Dq_matrix         [17]J40__dq_matrix
		Num_hf_presets    Int32_t
		__ccgo_pad9       [4]byte
		Orders            [11][13][3]uintptr
		Coeff_codespec    [11]J40__code_spec
	}
	Lf_groups     uintptr
	Toc           J40__toc
	Rendered      int32
	__ccgo_pad1   [4]byte
	Rendered_rgba J40__plane
}

type J40_image = struct {
	Magic       Uint32_t
	__ccgo_pad1 [4]byte
	U           struct{ Inner uintptr }
}

type J40_frame = struct {
	Magic    Uint32_t
	Reserved Uint32_t
	Inner    uintptr
}

type J40_memory_free_func = uintptr

type J40_u8x4 = [4]Uint8_t

// J40__DEFINE_PIXELS(uint8_t, u8);      // j40_pixels_u8, j40_frame_pixels_u8, j40_row_u8
// J40__DEFINE_PIXELS(uint16_t, u16);    // j40_pixels_u16, j40_frame_pixels_u16, j40_row_u16
// J40__DEFINE_PIXELS(uint32_t, u32);    // j40_pixels_u32, j40_frame_pixels_u32, j40_row_u32
// J40__DEFINE_PIXELS(uint64_t, u64);    // j40_pixels_u64, j40_frame_pixels_u64, j40_row_u64
// J40__DEFINE_PIXELS(float, f32);       // j40_pixels_f32, j40_frame_pixels_f32, j40_row_f32
// J40__DEFINE_PIXELS(j40_u8x3, u8x3);   // j40_pixels_u8x3, j40_frame_pixels_u8x3, j40_row_u8x3
// J40__DEFINE_PIXELS(j40_u16x3, u16x3); // j40_pixels_u16x3, j40_frame_pixels_u16x3, j40_row_u16x3
// J40__DEFINE_PIXELS(j40_u32x3, u32x3); // j40_pixels_u32x3, j40_frame_pixels_u32x3, j40_row_u32x3
// J40__DEFINE_PIXELS(j40_f32x3, f32x3); // j40_pixels_f32x3, j40_frame_pixels_f32x3, j40_row_f32x3
type J40_pixels_u8x4 = struct {
	Width        Int32_t
	Height       Int32_t
	Stride_bytes Int32_t
	__ccgo_pad1  [4]byte
	Data         uintptr
}

// bit and logical buffer. this is most frequently accessed and thus available without indirection.
//
// the bit buffer (`nbits` least significant bits of `bits`) is the least significant bits available
// for decoding, and the logical buffer [ptr, end) corresponds to subsequent bits.
// the logical buffer is guaranteed to be all in the codestream (which is not always true if
// the file uses a container).
//
// when the bit buffer has been exhausted the next byte from the logical buffer is consumed and
// appended at the *top* of the bit buffer. when the logical buffer has been exhausted
// higher layers (first backing buffer, then container, and finally source) should be consulted.
type J40__bits_st1 = struct {
	Nbits       Int32_t
	__ccgo_pad1 [4]byte
	Bits        Uint64_t
	Ptr         uintptr
	End         uintptr
}

// bit and logical buffer. this is most frequently accessed and thus available without indirection.
//
// the bit buffer (`nbits` least significant bits of `bits`) is the least significant bits available
// for decoding, and the logical buffer [ptr, end) corresponds to subsequent bits.
// the logical buffer is guaranteed to be all in the codestream (which is not always true if
// the file uses a container).
//
// when the bit buffer has been exhausted the next byte from the logical buffer is consumed and
// appended at the *top* of the bit buffer. when the logical buffer has been exhausted
// higher layers (first backing buffer, then container, and finally source) should be consulted.
type J40__bits_st = J40__bits_st1

// a common context ("state") for all internal functions.
// this bears a strong similarity with `struct j40__inner` type in the API layer which would be
// introduced much later. there are multiple reasons for this split:
// - `j40__st` is designed to be in the stack, so it doesn't take up much stack space.
// - `j40__st` allows for partial initialization of subsystems, which makes testing much easier.
// - `j40__st` only holds things relevant to decoding, while `j40__inner` has API contexts.
// - there can be multiple `j40__st` for multi-threaded decoding.
type J40__source_st1 = struct {
	Read_func     J40_source_read_func
	Seek_func     J40_source_seek_func
	Free_func     J40_source_free_func
	Data          uintptr
	Fileoff       Int64_t
	Fileoff_limit Int64_t
}

// a common context ("state") for all internal functions.
// this bears a strong similarity with `struct j40__inner` type in the API layer which would be
// introduced much later. there are multiple reasons for this split:
// - `j40__st` is designed to be in the stack, so it doesn't take up much stack space.
// - `j40__st` allows for partial initialization of subsystems, which makes testing much easier.
// - `j40__st` only holds things relevant to decoding, while `j40__inner` has API contexts.
// - there can be multiple `j40__st` for multi-threaded decoding.
type J40__container_st1 = struct {
	Flags       uint32
	__ccgo_pad1 [4]byte
	Map         uintptr
	Nmap        Int32_t
	Map_cap     Int32_t
}

// a common context ("state") for all internal functions.
// this bears a strong similarity with `struct j40__inner` type in the API layer which would be
// introduced much later. there are multiple reasons for this split:
// - `j40__st` is designed to be in the stack, so it doesn't take up much stack space.
// - `j40__st` allows for partial initialization of subsystems, which makes testing much easier.
// - `j40__st` only holds things relevant to decoding, while `j40__inner` has API contexts.
// - there can be multiple `j40__st` for multi-threaded decoding.
type J40__buffer_st1 = struct {
	Buf           uintptr
	Size          Int64_t
	Capacity      Int64_t
	Next_codeoff  Int64_t
	Codeoff_limit Int64_t
	Checkpoint    J40__bits_st
}

// a common context ("state") for all internal functions.
// this bears a strong similarity with `struct j40__inner` type in the API layer which would be
// introduced much later. there are multiple reasons for this split:
// - `j40__st` is designed to be in the stack, so it doesn't take up much stack space.
// - `j40__st` allows for partial initialization of subsystems, which makes testing much easier.
// - `j40__st` only holds things relevant to decoding, while `j40__inner` has API contexts.
// - there can be multiple `j40__st` for multi-threaded decoding.
type J40__image_st1 = struct {
	Width                 Int32_t
	Height                Int32_t
	Orientation           uint32
	Intr_width            Int32_t
	Intr_height           Int32_t
	Bpp                   int32
	Exp_bits              int32
	Anim_tps_num          Int32_t
	Anim_tps_denom        Int32_t
	__ccgo_pad1           [4]byte
	Anim_nloops           Int64_t
	Anim_have_timecodes   int32
	__ccgo_pad2           [4]byte
	Icc                   uintptr
	Iccsize               Size_t
	Cspace                uint32
	Cpoints               [4][2]float32
	Gamma_or_tf           int32
	Render_intent         uint32
	Intensity_target      float32
	Min_nits              float32
	Linear_below          float32
	Modular_16bit_buffers int32
	Num_extra_channels    int32
	Ec_info               uintptr
	Xyb_encoded           int32
	Opsin_inv_mat         [3][3]float32
	Opsin_bias            [3]float32
	Quant_bias            [3]float32
	Quant_bias_num        float32
	Want_icc              int32
}

// a common context ("state") for all internal functions.
// this bears a strong similarity with `struct j40__inner` type in the API layer which would be
// introduced much later. there are multiple reasons for this split:
// - `j40__st` is designed to be in the stack, so it doesn't take up much stack space.
// - `j40__st` allows for partial initialization of subsystems, which makes testing much easier.
// - `j40__st` only holds things relevant to decoding, while `j40__inner` has API contexts.
// - there can be multiple `j40__st` for multi-threaded decoding.
type J40__frame_st1 = struct {
	Is_last               int32
	Type                  uint32
	Is_modular            int32
	Has_noise             int32
	Has_patches           int32
	Has_splines           int32
	Use_lf_frame          int32
	Skip_adapt_lf_smooth  int32
	Do_ycbcr              int32
	Jpeg_upsampling       Int32_t
	Log_upsampling        Int32_t
	__ccgo_pad1           [4]byte
	Ec_log_upsampling     uintptr
	Group_size_shift      Int32_t
	X_qm_scale            Int32_t
	B_qm_scale            Int32_t
	Num_passes            Int32_t
	Shift                 [11]Int8_t
	Log_ds                [12]Int8_t
	__ccgo_pad2           [1]byte
	Lf_level              Int32_t
	X0                    Int32_t
	Y0                    Int32_t
	Width                 Int32_t
	Height                Int32_t
	__ccgo_pad3           [4]byte
	Num_groups            Int64_t
	Num_groups_per_row    Int64_t
	Num_lf_groups         Int64_t
	Num_lf_groups_per_row Int64_t
	Duration              Int64_t
	Timecode              Int64_t
	Blend_info            J40__blend_info
	__ccgo_pad4           [4]byte
	Ec_blend_info         uintptr
	Save_as_ref           Int32_t
	Save_before_ct        int32
	Name_len              Int32_t
	__ccgo_pad5           [4]byte
	Name                  uintptr
	Gab                   struct {
		Enabled int32
		Weights [3][2]float32
	}
	Epf struct {
		Iters             Int32_t
		Sharp_lut         [8]float32
		Channel_scale     [3]float32
		Quant_mul         float32
		Pass0_sigma_scale float32
		Pass2_sigma_scale float32
		Border_sad_mul    float32
		Sigma_for_modular float32
	}
	M_lf_scaled       [3]float32
	__ccgo_pad6       [4]byte
	Global_tree       uintptr
	Global_codespec   J40__code_spec
	Gmodular          J40__modular
	Num_gm_channels   Int32_t
	Global_scale      Int32_t
	Quant_lf          Int32_t
	Lf_thr            [3][15]Int32_t
	Qf_thr            [15]Int32_t
	Nb_lf_thr         [3]Int32_t
	Nb_qf_thr         Int32_t
	__ccgo_pad7       [4]byte
	Block_ctx_map     uintptr
	Block_ctx_size    Int32_t
	Nb_block_ctx      Int32_t
	Inv_colour_factor float32
	X_factor_lf       Int32_t
	B_factor_lf       Int32_t
	Base_corr_x       float32
	Base_corr_b       float32
	Dct_select_used   Int32_t
	Dct_select_loaded Int32_t
	Order_used        Int32_t
	Order_loaded      Int32_t
	__ccgo_pad8       [4]byte
	Dq_matrix         [17]J40__dq_matrix
	Num_hf_presets    Int32_t
	__ccgo_pad9       [4]byte
	Orders            [11][13][3]uintptr
	Coeff_codespec    [11]J40__code_spec
}

// a common context ("state") for all internal functions.
// this bears a strong similarity with `struct j40__inner` type in the API layer which would be
// introduced much later. there are multiple reasons for this split:
// - `j40__st` is designed to be in the stack, so it doesn't take up much stack space.
// - `j40__st` allows for partial initialization of subsystems, which makes testing much easier.
// - `j40__st` only holds things relevant to decoding, while `j40__inner` has API contexts.
// - there can be multiple `j40__st` for multi-threaded decoding.
type J40__lf_group_st1 = struct {
	Idx             Int64_t
	Left            Int32_t
	Top             Int32_t
	Width           Int32_t
	Height          Int32_t
	Width8          Int32_t
	Height8         Int32_t
	Width64         Int32_t
	Height64        Int32_t
	Gidx            Int64_t
	Grows           Int64_t
	Gcolumns        Int64_t
	Gstride         Int64_t
	Xfromy          J40__plane
	Bfromy          J40__plane
	Sharpness       J40__plane
	Nb_varblocks    Int32_t
	__ccgo_pad1     [4]byte
	Blocks          J40__plane
	Varblocks       uintptr
	Llfcoeffs       [3]uintptr
	Coeffs          [3]uintptr
	Coeffs_misalign [3]Uint8_t
	__ccgo_pad2     [5]byte
	Lfindices       J40__plane
	Loaded          int32
	__ccgo_pad3     [4]byte
}

// a common context ("state") for all internal functions.
// this bears a strong similarity with `struct j40__inner` type in the API layer which would be
// introduced much later. there are multiple reasons for this split:
// - `j40__st` is designed to be in the stack, so it doesn't take up much stack space.
// - `j40__st` allows for partial initialization of subsystems, which makes testing much easier.
// - `j40__st` only holds things relevant to decoding, while `j40__inner` has API contexts.
// - there can be multiple `j40__st` for multi-threaded decoding.
type J40__limits1 = struct {
	Pixels                      Int64_t
	Width                       Int32_t
	Height                      Int32_t
	Icc_output_size             Uint64_t
	Bpp                         Int32_t
	Ec_black_allowed            int32
	Num_extra_channels          Int32_t
	Needs_modular_16bit_buffers int32
	Nb_transforms               Int32_t
	Nb_channels_tr              Int32_t
	Tree_depth                  Int32_t
	__ccgo_pad1                 [4]byte
	Zf_pixels                   Int64_t
}

// a common context ("state") for all internal functions.
// this bears a strong similarity with `struct j40__inner` type in the API layer which would be
// introduced much later. there are multiple reasons for this split:
// - `j40__st` is designed to be in the stack, so it doesn't take up much stack space.
// - `j40__st` allows for partial initialization of subsystems, which makes testing much easier.
// - `j40__st` only holds things relevant to decoding, while `j40__inner` has API contexts.
// - there can be multiple `j40__st` for multi-threaded decoding.
type J40__st = struct {
	Err          J40_err
	Saved_errno  int32
	Cannot_retry int32
	__ccgo_pad1  [4]byte
	Bits         J40__bits_st1
	Source       uintptr
	Container    uintptr
	Buffer       uintptr
	Image        uintptr
	Frame        uintptr
	Lf_group     uintptr
	Limits       uintptr
}

func j40__set_error(tls *libc.TLS, st uintptr, err J40_err) J40_err {
	if err != Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 3))) {
		(*J40__st)(unsafe.Pointer(st)).Cannot_retry = 1
	}
	if !(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0) {
		(*J40__st)(unsafe.Pointer(st)).Err = err
	}
	return err
}

func j40__malloc(tls *libc.TLS, size Size_t) uintptr {
	return libc.Xmalloc(tls, size)
}

func j40__calloc(tls *libc.TLS, num Size_t, size Size_t) uintptr {
	return libc.Xcalloc(tls, num, size)
}

func j40__realloc32(tls *libc.TLS, st uintptr, ptr uintptr, itemsize Size_t, len Int32_t, cap uintptr) uintptr {
	var newptr uintptr
	var newcap Uint32_t
	var newsize Size_t

	if !(len <= *(*Int32_t)(unsafe.Pointer(cap))) {
		goto __1
	}
	return ptr
__1:
	;
	newcap = Uint32_t(*(*Int32_t)(unsafe.Pointer(cap))) * Uint32_t(2)
	if !(newcap > Uint32_t(2147483647)) {
		goto __2
	}
	newcap = Uint32_t(2147483647)
__2:
	;
	if !(newcap < Uint32_t(len)) {
		goto __3
	}
	newcap = Uint32_t(len)
__3:
	;
__4:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __7
	}
	goto J40__ON_ERROR
__7:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(uint64(newcap) <= libc.Uint64(18446744073709551615)/itemsize)), int64(0)) != 0) {
		goto __8
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__8:
	;
	goto __5
__5:
	if 0 != 0 {
		goto __4
	}
	goto __6
__6:
	;
	newsize = itemsize * Size_t(newcap)
__9:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __12
	}
	goto J40__ON_ERROR
__12:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignUintptr(&newptr, func() uintptr {
		if ptr != 0 {
			return libc.Xrealloc(tls, ptr, newsize)
		}
		return libc.Xmalloc(tls, newsize)
	}())) != 0)), int64(0)) != 0) {
		goto __13
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__13:
	;
	goto __10
__10:
	if 0 != 0 {
		goto __9
	}
	goto __11
__11:
	;
	*(*Int32_t)(unsafe.Pointer(cap)) = Int32_t(newcap)
	return newptr
J40__ON_ERROR:
	return uintptr(0)
}

func j40__realloc64(tls *libc.TLS, st uintptr, ptr uintptr, itemsize Size_t, len Int64_t, cap uintptr) uintptr {
	var newptr uintptr
	var newcap Uint64_t
	var newsize Size_t

	if !(len <= *(*Int64_t)(unsafe.Pointer(cap))) {
		goto __1
	}
	return ptr
__1:
	;
	newcap = Uint64_t(*(*Int64_t)(unsafe.Pointer(cap))) * uint64(2)
	if !(newcap > uint64(9223372036854775807)) {
		goto __2
	}
	newcap = uint64(9223372036854775807)
__2:
	;
	if !(newcap < Uint64_t(len)) {
		goto __3
	}
	newcap = Uint64_t(len)
__3:
	;
__4:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __7
	}
	goto J40__ON_ERROR
__7:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(newcap <= libc.Uint64(18446744073709551615)/itemsize)), int64(0)) != 0) {
		goto __8
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__8:
	;
	goto __5
__5:
	if 0 != 0 {
		goto __4
	}
	goto __6
__6:
	;
	newsize = itemsize * newcap
__9:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __12
	}
	goto J40__ON_ERROR
__12:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignUintptr(&newptr, func() uintptr {
		if ptr != 0 {
			return libc.Xrealloc(tls, ptr, newsize)
		}
		return libc.Xmalloc(tls, newsize)
	}())) != 0)), int64(0)) != 0) {
		goto __13
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__13:
	;
	goto __10
__10:
	if 0 != 0 {
		goto __9
	}
	goto __11
__11:
	;
	*(*Int64_t)(unsafe.Pointer(cap)) = Int64_t(newcap)
	return newptr
J40__ON_ERROR:
	return uintptr(0)
}

func j40__free(tls *libc.TLS, ptr uintptr) {
	libc.Xfree(tls, ptr)
}

func J40__unpack_signed(tls *libc.TLS, x Int32_t) Int32_t {
	return func() int32 {
		if x&1 != 0 {
			return -(x/2 + 1)
		}
		return x / 2
	}()
}

func J40__unpack_signed64(tls *libc.TLS, x Int64_t) Int64_t {
	return func() int64 {
		if x&int64(1) != 0 {
			return -(x/int64(2) + int64(1))
		}
		return x / int64(2)
	}()
}

// equivalent to ceil(x / y)
func J40__ceil_div32(tls *libc.TLS, x Int32_t, y Int32_t) Int32_t {
	return (x + y - 1) / y
}

func J40__ceil_div64(tls *libc.TLS, x Int64_t, y Int64_t) Int64_t {
	return (x + y - int64(1)) / y
}

func J40__minf(tls *libc.TLS, x float32, y float32) float32 {
	return func() float32 {
		if x < y {
			return x
		}
		return y
	}()
}

func J40__maxf(tls *libc.TLS, x float32, y float32) float32 {
	return func() float32 {
		if x > y {
			return x
		}
		return y
	}()
}

// used to guard against division by zero
func J40__surely_nonzero(tls *libc.TLS, x float32) int32 {
	return libc.Bool32(!(libc.X__builtin_isnan(tls, float64(x-x)) != 0) && libc.Xfabs(tls, float64(x)) >= 1e-8)
}

// same to `(a + b) >> 1` but doesn't overflow, useful for tight loops with autovectorization
// https://devblogs.microsoft.com/oldnewthing/20220207-00/?p=106223
func J40__floor_avg16(tls *libc.TLS, x Int16_t, y Int16_t) Int16_t {
	return Int16_t(int32(x)/2 + int32(y)/2 + int32(x)&int32(y)&1)
}

func J40__abs16(tls *libc.TLS, x Int16_t) Int16_t {
	return func() int16 {
		if int32(x) < 0 {
			return int16(-int32(x))
		}
		return x
	}()
}

func J40__min16(tls *libc.TLS, x Int16_t, y Int16_t) Int16_t {
	return func() int16 {
		if int32(x) < int32(y) {
			return x
		}
		return y
	}()
}

func J40__max16(tls *libc.TLS, x Int16_t, y Int16_t) Int16_t {
	return func() int16 {
		if int32(x) > int32(y) {
			return x
		}
		return y
	}()
}

func J40__add16(tls *libc.TLS, x Int16_t, y Int16_t, out uintptr) int32 {
	return 1 - libc.X__builtin_add_overflowInt64(tls, int64(x), int64(y), out)
}

func J40__sub16(tls *libc.TLS, x Int16_t, y Int16_t, out uintptr) int32 {
	return 1 - libc.X__builtin_sub_overflowInt64(tls, int64(x), int64(y), out)
}

func J40__mul16(tls *libc.TLS, x Int16_t, y Int16_t, out uintptr) int32 {
	return 1 - libc.X__builtin_mul_overflowInt64(tls, int64(x), int64(y), out)
}

func J40__add_fallback16(tls *libc.TLS, x Int16_t, y Int16_t, out uintptr) int32 {
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(x) > 0 && int32(y) > 32767-int32(x) || int32(x) < 0 && int32(y) < -32767-1-int32(x))), int64(0)) != 0 {
		return 0
	} else {
		*(*Int16_t)(unsafe.Pointer(out)) = Int16_t(int32(x) + int32(y))
		return 1
	}
	return int32(0)
}

func J40__sub_fallback16(tls *libc.TLS, x Int16_t, y Int16_t, out uintptr) int32 {
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(y) < 0 && int32(x) > 32767+int32(y) || int32(y) > 0 && int32(x) < -32767-1+int32(y))), int64(0)) != 0 {
		return 0
	} else {
		*(*Int16_t)(unsafe.Pointer(out)) = Int16_t(int32(x) - int32(y))
		return 1
	}
	return int32(0)
}

func J40__mul_fallback16(tls *libc.TLS, x Int16_t, y Int16_t, out uintptr) int32 {
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(func() int32 {
		if int32(x) > 0 {
			return func() int32 {
				if int32(y) > 0 {
					return libc.Bool32(int32(x) > 32767/int32(y))
				}
				return libc.Bool32(int32(y) < (-32767-1)/int32(x))
			}()
		}
		return func() int32 {
			if int32(y) > 0 {
				return libc.Bool32(int32(x) < (-32767-1)/int32(y))
			}
			return libc.Bool32(int32(y) != 0 && int32(x) < 32767/int32(y))
		}()
	}() != 0)), int64(0)) != 0 {
		return 0
	} else {
		*(*Int16_t)(unsafe.Pointer(out)) = Int16_t(int32(x) * int32(y))
		return 1
	}
	return int32(0)
}

func J40__clamp_add16(tls *libc.TLS, x Int16_t, y Int16_t) Int16_t {
	bp := tls.Alloc(2)
	defer tls.Free(2)

	if J40__add16(tls, x, y, bp) != 0 {
		return *(*Int16_t)(unsafe.Pointer(bp))
	}
	return int16(32767)
}

func J40__clamp_mul16(tls *libc.TLS, x Int16_t, y Int16_t) Int16_t {
	bp := tls.Alloc(2)
	defer tls.Free(2)

	if J40__mul16(tls, x, y, bp) != 0 {
		return *(*Int16_t)(unsafe.Pointer(bp))
	}
	return int16(32767)
}

// same to `(a + b) >> 1` but doesn't overflow, useful for tight loops with autovectorization
// https://devblogs.microsoft.com/oldnewthing/20220207-00/?p=106223
func J40__floor_avg32(tls *libc.TLS, x Int32_t, y Int32_t) Int32_t {
	return x/2 + y/2 + x&y&1
}

func J40__abs32(tls *libc.TLS, x Int32_t) Int32_t {
	return func() int32 {
		if x < 0 {
			return -x
		}
		return x
	}()
}

func J40__min32(tls *libc.TLS, x Int32_t, y Int32_t) Int32_t {
	return func() int32 {
		if x < y {
			return x
		}
		return y
	}()
}

func J40__max32(tls *libc.TLS, x Int32_t, y Int32_t) Int32_t {
	return func() int32 {
		if x > y {
			return x
		}
		return y
	}()
}

func J40__add32(tls *libc.TLS, x Int32_t, y Int32_t, out uintptr) int32 {
	return 1 - libc.X__builtin_add_overflowInt64(tls, int64(x), int64(y), out)
}

func J40__sub32(tls *libc.TLS, x Int32_t, y Int32_t, out uintptr) int32 {
	return 1 - libc.X__builtin_sub_overflowInt64(tls, int64(x), int64(y), out)
}

func J40__mul32(tls *libc.TLS, x Int32_t, y Int32_t, out uintptr) int32 {
	return 1 - libc.X__builtin_mul_overflowInt64(tls, int64(x), int64(y), out)
}

func J40__add_fallback32(tls *libc.TLS, x Int32_t, y Int32_t, out uintptr) int32 {
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(x > 0 && y > 2147483647-x || x < 0 && y < -2147483647-1-x)), int64(0)) != 0 {
		return 0
	} else {
		*(*Int32_t)(unsafe.Pointer(out)) = x + y
		return 1
	}
	return int32(0)
}

func J40__sub_fallback32(tls *libc.TLS, x Int32_t, y Int32_t, out uintptr) int32 {
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(y < 0 && x > 2147483647+y || y > 0 && x < -2147483647-1+y)), int64(0)) != 0 {
		return 0
	} else {
		*(*Int32_t)(unsafe.Pointer(out)) = x - y
		return 1
	}
	return int32(0)
}

func J40__mul_fallback32(tls *libc.TLS, x Int32_t, y Int32_t, out uintptr) int32 {
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(func() int32 {
		if x > 0 {
			return func() int32 {
				if y > 0 {
					return libc.Bool32(x > 2147483647/y)
				}
				return libc.Bool32(y < (-2147483647-1)/x)
			}()
		}
		return func() int32 {
			if y > 0 {
				return libc.Bool32(x < (-2147483647-1)/y)
			}
			return libc.Bool32(y != 0 && x < 2147483647/y)
		}()
	}() != 0)), int64(0)) != 0 {
		return 0
	} else {
		*(*Int32_t)(unsafe.Pointer(out)) = x * y
		return 1
	}
	return int32(0)
}

func J40__clamp_add32(tls *libc.TLS, x Int32_t, y Int32_t) Int32_t {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if J40__add32(tls, x, y, bp) != 0 {
		return *(*Int32_t)(unsafe.Pointer(bp))
	}
	return 2147483647
}

func J40__clamp_mul32(tls *libc.TLS, x Int32_t, y Int32_t) Int32_t {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if J40__mul32(tls, x, y, bp) != 0 {
		return *(*Int32_t)(unsafe.Pointer(bp))
	}
	return 2147483647
}

// both requires x to be > 0
func J40__floor_lg32(tls *libc.TLS, x Uint32_t) int32 {
	return 32 - 1 - libc.X__builtin_clz(tls, x)

}

func J40__ceil_lg32(tls *libc.TLS, x Uint32_t) int32 {
	if x > Uint32_t(1) {
		return 32 - libc.X__builtin_clz(tls, x-Uint32_t(1))
	}
	return 0

}

// same to `(a + b) >> 1` but doesn't overflow, useful for tight loops with autovectorization
// https://devblogs.microsoft.com/oldnewthing/20220207-00/?p=106223
func J40__floor_avg64(tls *libc.TLS, x Int64_t, y Int64_t) Int64_t {
	return x/int64(2) + y/int64(2) + x&y&int64(1)
}

func J40__abs64(tls *libc.TLS, x Int64_t) Int64_t {
	return func() int64 {
		if x < int64(0) {
			return -x
		}
		return x
	}()
}

func J40__min64(tls *libc.TLS, x Int64_t, y Int64_t) Int64_t {
	return func() int64 {
		if x < y {
			return x
		}
		return y
	}()
}

func J40__max64(tls *libc.TLS, x Int64_t, y Int64_t) Int64_t {
	return func() int64 {
		if x > y {
			return x
		}
		return y
	}()
}

func J40__add64(tls *libc.TLS, x Int64_t, y Int64_t, out uintptr) int32 {
	return 1 - libc.X__builtin_add_overflowInt64(tls, x, y, out)
}

func J40__sub64(tls *libc.TLS, x Int64_t, y Int64_t, out uintptr) int32 {
	return 1 - libc.X__builtin_sub_overflowInt64(tls, x, y, out)
}

func J40__mul64(tls *libc.TLS, x Int64_t, y Int64_t, out uintptr) int32 {
	return 1 - libc.X__builtin_mul_overflowInt64(tls, x, y, out)
}

func J40__add_fallback64(tls *libc.TLS, x Int64_t, y Int64_t, out uintptr) int32 {
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(x > int64(0) && y > 9223372036854775807-x || x < int64(0) && y < -9223372036854775807-int64(1)-x)), int64(0)) != 0 {
		return 0
	} else {
		*(*Int64_t)(unsafe.Pointer(out)) = x + y
		return 1
	}
	return int32(0)
}

func J40__sub_fallback64(tls *libc.TLS, x Int64_t, y Int64_t, out uintptr) int32 {
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(y < int64(0) && x > 9223372036854775807+y || y > int64(0) && x < -9223372036854775807-int64(1)+y)), int64(0)) != 0 {
		return 0
	} else {
		*(*Int64_t)(unsafe.Pointer(out)) = x - y
		return 1
	}
	return int32(0)
}

func J40__mul_fallback64(tls *libc.TLS, x Int64_t, y Int64_t, out uintptr) int32 {
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(func() int32 {
		if x > int64(0) {
			return func() int32 {
				if y > int64(0) {
					return libc.Bool32(x > 9223372036854775807/y)
				}
				return libc.Bool32(y < (-9223372036854775807-int64(1))/x)
			}()
		}
		return func() int32 {
			if y > int64(0) {
				return libc.Bool32(x < (-9223372036854775807-int64(1))/y)
			}
			return libc.Bool32(y != int64(0) && x < 9223372036854775807/y)
		}()
	}() != 0)), int64(0)) != 0 {
		return 0
	} else {
		*(*Int64_t)(unsafe.Pointer(out)) = x * y
		return 1
	}
	return int32(0)
}

func J40__clamp_add64(tls *libc.TLS, x Int64_t, y Int64_t) Int64_t {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if J40__add64(tls, x, y, bp) != 0 {
		return *(*Int64_t)(unsafe.Pointer(bp))
	}
	return 9223372036854775807
}

func J40__clamp_mul64(tls *libc.TLS, x Int64_t, y Int64_t) Int64_t {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if J40__mul64(tls, x, y, bp) != 0 {
		return *(*Int64_t)(unsafe.Pointer(bp))
	}
	return 9223372036854775807
}

// both requires x to be > 0
func J40__floor_lg64(tls *libc.TLS, x Uint64_t) int32 {
	return 64 - 1 - libc.X__builtin_clzl(tls, x)

}

func J40__ceil_lg64(tls *libc.TLS, x Uint64_t) int32 {
	if x > uint64(1) {
		return 64 - libc.X__builtin_clzl(tls, x-uint64(1))
	}
	return 0

}

// #if _POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600
// J40_ALWAYS_INLINE void *j40__alloc_aligned(size_t sz, size_t align, size_t *outmisalign) {
// void *ptr = NULL;
// *outmisalign = 0;
// return posix_memalign(&ptr, align, sz) ? NULL : ptr;
// }
// J40_ALWAYS_INLINE void j40__free_aligned(void *ptr, size_t align, size_t misalign) {
// (void) align; (void) misalign;
// free(ptr); // important: do not use j40_free!
// }
// #elif defined _ISOC11_SOURCE
// J40_ALWAYS_INLINE void *j40__alloc_aligned(size_t sz, size_t align, size_t *outmisalign) {
// if (sz > SIZE_MAX / align * align) return NULL; // overflow
// *outmisalign = 0;
// return aligned_alloc(align, (sz + align - 1) / align * align);
// }
// J40_ALWAYS_INLINE void j40__free_aligned(void *ptr, size_t align, size_t misalign) {
// (void) align; (void) misalign;
// free(ptr); // important: do not use j40_free!
// }
// #else
func J40__alloc_aligned(tls *libc.TLS, sz Size_t, align Size_t, outmisalign uintptr) uintptr {
	return J40__alloc_aligned_fallback(tls, sz, align, outmisalign)

}

func J40__free_aligned(tls *libc.TLS, ptr uintptr, align Size_t, misalign Size_t) {
	J40__free_aligned_fallback(tls, ptr, align, misalign)

}

// a fallback implementation; the caller should store the misalign amount [0, align) separately.
// used when the platform doesn't provide aligned malloc at all, or the platform implementation
// is not necessarily better; e.g. MSVC _aligned_malloc has the same amount of overhead as of Win10
func J40__alloc_aligned_fallback(tls *libc.TLS, sz Size_t, align Size_t, outmisalign uintptr) uintptr {
	var maxmisalign Size_t = align - uint64(1)
	var misalign Size_t
	var ptr uintptr
	if sz > libc.Uint64(18446744073709551615)-maxmisalign {
		return uintptr(0)
	}
	ptr = j40__malloc(tls, sz+maxmisalign)
	if !(ptr != 0) {
		return uintptr(0)
	}
	misalign = align - Uintptr_t(ptr)%align
	if misalign == align {
		misalign = uint64(0)
	}
	*(*Size_t)(unsafe.Pointer(outmisalign)) = misalign
	return uintptr(Uintptr_t(ptr) + misalign)
}

func J40__free_aligned_fallback(tls *libc.TLS, ptr uintptr, align Size_t, misalign Size_t) {
	if !(ptr != 0) {
		return
	}

	j40__free(tls, uintptr(Uintptr_t(ptr)-misalign))
}

type J40__view_f32 = struct {
	Logw Int32_t
	Logh Int32_t
	Ptr  uintptr
}

func J40__make_view_f32(tls *libc.TLS, logw Int32_t, logh Int32_t, ptr uintptr) J40__view_f32 {
	var ret = J40__view_f32{Logw: logw, Logh: logh, Ptr: ptr}
	return ret
}

func J40__adapt_view_f32(tls *libc.TLS, outv uintptr, logw Int32_t, logh Int32_t) {
	(*J40__view_f32)(unsafe.Pointer(outv)).Logw = logw
	(*J40__view_f32)(unsafe.Pointer(outv)).Logh = logh
}

func J40__reshape_view_f32(tls *libc.TLS, outv uintptr, logw Int32_t, logh Int32_t) {
	(*J40__view_f32)(unsafe.Pointer(outv)).Logw = logw
	(*J40__view_f32)(unsafe.Pointer(outv)).Logh = logh
}

func J40__copy_view_f32(tls *libc.TLS, outv uintptr, inv J40__view_f32) {
	var x Int32_t
	var y Int32_t
	var outptr uintptr = (*J40__view_f32)(unsafe.Pointer(outv)).Ptr
	J40__adapt_view_f32(tls, outv, inv.Logw, inv.Logh)
	for y = 0; y < int32(1)<<inv.Logh; y++ {
		for x = 0; x < int32(1)<<inv.Logw; x++ {
			*(*float32)(unsafe.Pointer(outptr + uintptr(y<<inv.Logw|x)*4)) = *(*float32)(unsafe.Pointer(inv.Ptr + uintptr(y<<inv.Logw|x)*4))
		}
	}
}

func J40__transpose_view_f32(tls *libc.TLS, outv uintptr, inv J40__view_f32) {
	var x Int32_t
	var y Int32_t
	var outptr uintptr = (*J40__view_f32)(unsafe.Pointer(outv)).Ptr
	J40__adapt_view_f32(tls, outv, inv.Logh, inv.Logw)
	for y = 0; y < int32(1)<<inv.Logh; y++ {
		for x = 0; x < int32(1)<<inv.Logw; x++ {
			*(*float32)(unsafe.Pointer(outptr + uintptr(x<<inv.Logh|y)*4)) = *(*float32)(unsafe.Pointer(inv.Ptr + uintptr(y<<inv.Logw|x)*4))
		}
	}
}

// shuffles columns 01234567 into 02461357 and so on
func J40__oddeven_columns_to_halves_f32(tls *libc.TLS, outv uintptr, inv J40__view_f32) {
	var x Int32_t
	var y Int32_t
	var outptr uintptr = (*J40__view_f32)(unsafe.Pointer(outv)).Ptr

	J40__adapt_view_f32(tls, outv, inv.Logw, inv.Logh)
	for y = 0; y < int32(1)<<inv.Logh; y++ {
		for x = 0; x < int32(1)<<inv.Logw; x++ {
			var outx Int32_t = x&1<<(inv.Logw-1) | x>>1
			*(*float32)(unsafe.Pointer(outptr + uintptr(y<<inv.Logw|outx)*4)) = *(*float32)(unsafe.Pointer(inv.Ptr + uintptr(y<<inv.Logw|x)*4))
		}
	}
}

// shuffles rows 01234567 into 02461357 and so on
func J40__oddeven_rows_to_halves_f32(tls *libc.TLS, outv uintptr, inv J40__view_f32) {
	var x Int32_t
	var y Int32_t
	var outptr uintptr = (*J40__view_f32)(unsafe.Pointer(outv)).Ptr

	J40__adapt_view_f32(tls, outv, inv.Logw, inv.Logh)
	for y = 0; y < int32(1)<<inv.Logh; y++ {
		var outy Int32_t = y&1<<(inv.Logh-1) | y>>1
		for x = 0; x < int32(1)<<inv.Logw; x++ {
			*(*float32)(unsafe.Pointer(outptr + uintptr(outy<<inv.Logw|x)*4)) = *(*float32)(unsafe.Pointer(inv.Ptr + uintptr(y<<inv.Logw|x)*4))
		}
	}
}

func J40__print_view_f32(tls *libc.TLS, v J40__view_f32, name uintptr, file uintptr, line Int32_t) {
	bp := tls.Alloc(72)
	defer tls.Free(72)

	var x Int32_t
	var y Int32_t
	libc.Xprintf(tls, ts+10, libc.VaList(bp, file, line, name, int32(1)<<v.Logw, int32(1)<<v.Logh, v.Ptr))
	for y = 0; y < int32(1)<<v.Logh; y++ {
		libc.Xprintf(tls, ts+41, 0)
		for x = 0; x < int32(1)<<v.Logw; x++ {
			libc.Xprintf(tls, ts+44, libc.VaList(bp+48, float64(*(*float32)(unsafe.Pointer(func() uintptr { ; return v.Ptr + uintptr(y<<v.Logw|x)*4 }())))))
		}
	}
	libc.Xprintf(tls, ts+48, libc.VaList(bp+56, file, line))
}

type J40__plane = struct {
	Type         Uint8_t
	Misalign     Uint8_t
	Vshift       Int8_t
	Hshift       Int8_t
	Width        Int32_t
	Height       Int32_t
	Stride_bytes Int32_t
	Pixels       Uintptr_t
}

func j40__init_plane(tls *libc.TLS, st uintptr, type1 Uint8_t, width Int32_t, height Int32_t, flags uint32, out uintptr) J40_err {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var pixel_size Int32_t
	var pixels uintptr

	var total Size_t

	pixel_size = int32(1) << (int32(type1) & 31)

	(*J40__plane)(unsafe.Pointer(out)).Type = Uint8_t(0)

__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(J40__mul32(tls, width, pixel_size, bp) != 0)), int64(0)) != 0) {
		goto __5
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 61))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 61 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 61 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 61 + 3))))
	goto J40__ON_ERROR
__5:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
	if !(int32(flags)&J40__PLANE_FORCE_PAD != 0) {
		goto __6
	}
__7:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __10
	}
	goto J40__ON_ERROR
__10:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(J40__add32(tls, *(*Int32_t)(unsafe.Pointer(bp)), 1, bp) != 0)), int64(0)) != 0) {
		goto __11
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 61))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 61 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 61 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 61 + 3))))
	goto J40__ON_ERROR
__11:
	;
	goto __8
__8:
	if 0 != 0 {
		goto __7
	}
	goto __9
__9:
	;
__6:
	;
__12:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __15
	}
	goto J40__ON_ERROR
__15:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(J40__mul32(tls, J40__ceil_div32(tls, *(*Int32_t)(unsafe.Pointer(bp)), J40__PIXELS_ALIGN), J40__PIXELS_ALIGN, bp) != 0)), int64(0)) != 0) {
		goto __16
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 61))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 61 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 61 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 61 + 3))))
	goto J40__ON_ERROR
__16:
	;
	goto __13
__13:
	if 0 != 0 {
		goto __12
	}
	goto __14
__14:
	;
__17:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __20
	}
	goto J40__ON_ERROR
__20:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Size_t(*(*Int32_t)(unsafe.Pointer(bp))) <= libc.Uint64(18446744073709551615)/uint64(Uint32_t(height)))), int64(0)) != 0) {
		goto __21
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 61))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 61 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 61 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 61 + 3))))
	goto J40__ON_ERROR
__21:
	;
	goto __18
__18:
	if 0 != 0 {
		goto __17
	}
	goto __19
__19:
	;
	total = Size_t(*(*Int32_t)(unsafe.Pointer(bp))) * Size_t(height)
__22:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __25
	}
	goto J40__ON_ERROR
__25:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignUintptr(&pixels, J40__alloc_aligned(tls, total, uint64(J40__PIXELS_ALIGN), bp+8))) != 0)), int64(0)) != 0) {
		goto __26
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__26:
	;
	goto __23
__23:
	if 0 != 0 {
		goto __22
	}
	goto __24
__24:
	;
	(*J40__plane)(unsafe.Pointer(out)).Stride_bytes = *(*Int32_t)(unsafe.Pointer(bp))
	(*J40__plane)(unsafe.Pointer(out)).Width = width
	(*J40__plane)(unsafe.Pointer(out)).Height = height
	(*J40__plane)(unsafe.Pointer(out)).Type = type1
	(*J40__plane)(unsafe.Pointer(out)).Vshift = libc.AssignPtrInt8(out+3, int8(0))
	(*J40__plane)(unsafe.Pointer(out)).Misalign = Uint8_t(*(*Size_t)(unsafe.Pointer(bp + 8)))
	(*J40__plane)(unsafe.Pointer(out)).Pixels = Uintptr_t(pixels)
	if !(int32(flags)&J40__PLANE_CLEAR != 0) {
		goto __27
	}
	libc.Xmemset(tls, pixels, 0, total)
__27:
	;
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__plane_all_equal_sized(tls *libc.TLS, begin uintptr, end uintptr) int32 {
	var c J40__plane
	var shift_should_match int32
	if begin >= end {
		return 0
	}
	c = *(*J40__plane)(unsafe.Pointer(begin))
	shift_should_match = libc.Bool32(int32((*J40__plane)(unsafe.Pointer(begin)).Vshift) >= 0 && int32((*J40__plane)(unsafe.Pointer(begin)).Hshift) >= 0)
	for libc.PreIncUintptr(&begin, 24) < end {
		if c.Width != (*J40__plane)(unsafe.Pointer(begin)).Width || c.Height != (*J40__plane)(unsafe.Pointer(begin)).Height {
			return 0
		}

		if shift_should_match != 0 {
			if int32(c.Vshift) >= 0 && int32(c.Hshift) >= 0 && (int32(c.Vshift) != int32((*J40__plane)(unsafe.Pointer(begin)).Vshift) || int32(c.Hshift) != int32((*J40__plane)(unsafe.Pointer(begin)).Hshift)) {
				return 0
			}
		}
	}
	return 1
}

func j40__plane_all_equal_typed(tls *libc.TLS, begin uintptr, end uintptr) Uint8_t {
	var type1 Uint8_t
	if begin >= end {
		return Uint8_t(0)
	}
	type1 = (*J40__plane)(unsafe.Pointer(begin)).Type
	for libc.PreIncUintptr(&begin, 24) < end {
		if int32(type1) != int32((*J40__plane)(unsafe.Pointer(begin)).Type) {
			return Uint8_t(0)
		}
	}
	return type1
}

func j40__free_plane(tls *libc.TLS, plane uintptr) {
	if (*J40__plane)(unsafe.Pointer(plane)).Type != 0 {
		J40__free_aligned(tls, uintptr((*J40__plane)(unsafe.Pointer(plane)).Pixels), uint64(J40__PIXELS_ALIGN), uint64((*J40__plane)(unsafe.Pointer(plane)).Misalign))
	}
	(*J40__plane)(unsafe.Pointer(plane)).Width = libc.AssignPtrInt32(plane+8, libc.AssignPtrInt32(plane+12, 0))
	(*J40__plane)(unsafe.Pointer(plane)).Type = Uint8_t(0)
	(*J40__plane)(unsafe.Pointer(plane)).Vshift = libc.AssignPtrInt8(plane+3, int8(0))
	(*J40__plane)(unsafe.Pointer(plane)).Misalign = Uint8_t(0)
	(*J40__plane)(unsafe.Pointer(plane)).Pixels = Uintptr_t(uintptr(0))
}

type J40__limits = J40__limits1

var sJ40__MAIN_LV5_LIMITS = J40__limits{Pixels: int64(int32(1) << 28), Width: int32(1) << 18, Height: int32(1) << 18, Icc_output_size: uint64(uint32(1) << 22), Bpp: 16, Num_extra_channels: 4, Needs_modular_16bit_buffers: 1, Nb_transforms: 8, Nb_channels_tr: 256, Tree_depth: 64, Zf_pixels: int64(int32(1) << 28)}

type J40_source_read_func = uintptr
type J40_source_seek_func = uintptr
type J40_source_free_func = uintptr

type J40__source_st = J40__source_st1

func j40__memory_source_read(tls *libc.TLS, buf uintptr, fileoff Int64_t, maxsize Size_t, size uintptr, data uintptr) int32 {
	var mem uintptr = data
	libc.Xmemcpy(tls, buf, mem+uintptr(fileoff), maxsize)
	*(*Size_t)(unsafe.Pointer(size)) = maxsize
	return 0
}

func j40__init_memory_source(tls *libc.TLS, st uintptr, buf uintptr, size Size_t, freefunc J40_memory_free_func, source uintptr) J40_err {
__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(size <= uint64(9223372036854775807))), int64(0)) != 0) {
		goto __5
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 3))))
	goto J40__ON_ERROR
__5:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
	(*J40__source_st)(unsafe.Pointer(source)).Read_func = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, Int64_t, Size_t, uintptr, uintptr) int32
	}{j40__memory_source_read}))
	(*J40__source_st)(unsafe.Pointer(source)).Seek_func = uintptr(0)
	(*J40__source_st)(unsafe.Pointer(source)).Free_func = freefunc
	(*J40__source_st)(unsafe.Pointer(source)).Data = buf
	(*J40__source_st)(unsafe.Pointer(source)).Fileoff = int64(0)
	(*J40__source_st)(unsafe.Pointer(source)).Fileoff_limit = Int64_t(size)
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__file_source_read(tls *libc.TLS, buf uintptr, fileoff Int64_t, maxsize Size_t, size uintptr, data uintptr) int32 {
	var fp uintptr = data
	var read Size_t

	_ = fileoff
	read = libc.Xfread(tls, buf, uint64(1), maxsize, fp)
	if read > uint64(0) {
		*(*Size_t)(unsafe.Pointer(size)) = read
		return 0

	} else {
		return 1
	}
	return int32(0)
}

func j40__file_source_seek(tls *libc.TLS, fileoff Int64_t, data uintptr) int32 {
	var fp uintptr = data
	if fileoff < int64(0) {
		return 1
	}
	if fileoff <= 0x7fffffffffffffff {
		if libc.Xfseek(tls, fp, fileoff, SEEK_SET) != 0 {
			return 1
		}
	} else {
		if libc.Xfseek(tls, fp, 0x7fffffffffffffff, SEEK_SET) != 0 {
			return 1
		}
		fileoff = fileoff - 0x7fffffffffffffff
		for fileoff >= 0x7fffffffffffffff {
			if libc.Xfseek(tls, fp, 0x7fffffffffffffff, SEEK_CUR) != 0 {
				return 1
			}
			fileoff = fileoff - 0x7fffffffffffffff
		}
		if libc.Xfseek(tls, fp, fileoff, SEEK_CUR) != 0 {
			return 1
		}
	}
	return 0
}

func j40__file_source_free(tls *libc.TLS, data uintptr) {
	var fp uintptr = data
	libc.Xfclose(tls, fp)
}

func j40__init_file_source(tls *libc.TLS, st uintptr, path uintptr, source uintptr) J40_err {
	var fp uintptr
	var saved_errno int32

	saved_errno = *(*int32)(unsafe.Pointer(libc.X__errno_location(tls)))
	*(*int32)(unsafe.Pointer(libc.X__errno_location(tls))) = 0
	fp = libc.Xfopen(tls, path, ts+71)
	if !!(fp != 0) {
		goto __1
	}
	(*J40__st)(unsafe.Pointer(st)).Saved_errno = *(*int32)(unsafe.Pointer(libc.X__errno_location(tls)))
	if !(*(*int32)(unsafe.Pointer(libc.X__errno_location(tls))) == 0) {
		goto __2
	}
	*(*int32)(unsafe.Pointer(libc.X__errno_location(tls))) = saved_errno
__2:
	;
__3:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 74))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 74 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 74 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 74 + 3))))
	goto J40__ON_ERROR
	goto __4
__4:
	if 0 != 0 {
		goto __3
	}
	goto __5
__5:
	;
__1:
	;
	*(*int32)(unsafe.Pointer(libc.X__errno_location(tls))) = saved_errno

	(*J40__source_st)(unsafe.Pointer(source)).Read_func = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, Int64_t, Size_t, uintptr, uintptr) int32
	}{j40__file_source_read}))
	(*J40__source_st)(unsafe.Pointer(source)).Seek_func = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, Int64_t, uintptr) int32
	}{j40__file_source_seek}))
	(*J40__source_st)(unsafe.Pointer(source)).Free_func = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{j40__file_source_free}))
	(*J40__source_st)(unsafe.Pointer(source)).Data = fp
	(*J40__source_st)(unsafe.Pointer(source)).Fileoff = int64(0)
	(*J40__source_st)(unsafe.Pointer(source)).Fileoff_limit = func() int64 {
		if uint64(9223372036854775807) < libc.Uint64(18446744073709551615) {
			return 9223372036854775807
		}
		return libc.Int64FromUint64(18446744073709551615)
	}()
	return J40_err(0)

J40__ON_ERROR:
	if !(fp != 0) {
		goto __6
	}
	libc.Xfclose(tls, fp)
__6:
	;
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__try_read_from_source(tls *libc.TLS, st uintptr, buf uintptr, minsize Int64_t, maxsize Int64_t, size uintptr) J40_err {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var source uintptr
	var read_size Int64_t
	var saved_errno int32

	source = (*J40__st)(unsafe.Pointer(st)).Source
	read_size = int64(0)
	saved_errno = *(*int32)(unsafe.Pointer(libc.X__errno_location(tls)))
	*(*int32)(unsafe.Pointer(libc.X__errno_location(tls))) = 0
	*(*Int64_t)(unsafe.Pointer(size)) = int64(0)

	if !(maxsize > (*J40__source_st)(unsafe.Pointer(source)).Fileoff_limit-(*J40__source_st)(unsafe.Pointer(source)).Fileoff) {
		goto __1
	}
	maxsize = (*J40__source_st)(unsafe.Pointer(source)).Fileoff_limit - (*J40__source_st)(unsafe.Pointer(source)).Fileoff
__2:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __5
	}
	goto J40__ON_ERROR
__5:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(minsize <= maxsize)), int64(0)) != 0) {
		goto __6
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 3))))
	goto J40__ON_ERROR
__6:
	;
	goto __3
__3:
	if 0 != 0 {
		goto __2
	}
	goto __4
__4:
	;
__1:
	;
__7:
	if !(read_size < maxsize) {
		goto __8
	}
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!((*struct {
		f func(*libc.TLS, uintptr, Int64_t, Size_t, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*J40__source_st)(unsafe.Pointer(source)).Read_func})).f(tls, buf+uintptr(read_size), (*J40__source_st)(unsafe.Pointer(source)).Fileoff, Size_t(maxsize-read_size), bp, (*J40__source_st)(unsafe.Pointer(source)).Data) != 0)), int64(0)) != 0) {
		goto __9
	}
	(*J40__st)(unsafe.Pointer(st)).Saved_errno = *(*int32)(unsafe.Pointer(libc.X__errno_location(tls)))
	if !(*(*int32)(unsafe.Pointer(libc.X__errno_location(tls))) == 0) {
		goto __10
	}
	*(*int32)(unsafe.Pointer(libc.X__errno_location(tls))) = saved_errno
__10:
	;
__11:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 79))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 79 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 79 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 79 + 3))))
	goto J40__ON_ERROR
	goto __12
__12:
	if 0 != 0 {
		goto __11
	}
	goto __13
__13:
	;
__9:
	;
	if !(*(*Size_t)(unsafe.Pointer(bp)) == uint64(0)) {
		goto __14
	}
	goto __8
__14:
	;
__15:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __18
	}
	goto J40__ON_ERROR
__18:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(*(*Size_t)(unsafe.Pointer(bp)) <= uint64(9223372036854775807))), int64(0)) != 0) {
		goto __19
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 3))))
	goto J40__ON_ERROR
__19:
	;
	goto __16
__16:
	if 0 != 0 {
		goto __15
	}
	goto __17
__17:
	;
	read_size = read_size + Int64_t(*(*Size_t)(unsafe.Pointer(bp)))
__20:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __23
	}
	goto J40__ON_ERROR
__23:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(J40__add64(tls, (*J40__source_st)(unsafe.Pointer(source)).Fileoff, read_size, source+32) != 0)), int64(0)) != 0) {
		goto __24
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 3))))
	goto J40__ON_ERROR
__24:
	;
	goto __21
__21:
	if 0 != 0 {
		goto __20
	}
	goto __22
__22:
	;
	goto __7
__8:
	;
__25:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __28
	}
	goto J40__ON_ERROR
__28:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(read_size >= minsize)), int64(0)) != 0) {
		goto __29
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 3))))
	goto J40__ON_ERROR
__29:
	;
	goto __26
__26:
	if 0 != 0 {
		goto __25
	}
	goto __27
__27:
	;
	*(*int32)(unsafe.Pointer(libc.X__errno_location(tls))) = saved_errno
	*(*Int64_t)(unsafe.Pointer(size)) = read_size
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__read_from_source(tls *libc.TLS, st uintptr, buf uintptr, size Int64_t) J40_err {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	return j40__try_read_from_source(tls, st, buf, size, size, bp)
}

func j40__seek_from_source(tls *libc.TLS, st uintptr, fileoff Int64_t) J40_err {
	var source uintptr
	var saved_errno int32
	source = (*J40__st)(unsafe.Pointer(st)).Source

	if !(fileoff == (*J40__source_st)(unsafe.Pointer(source)).Fileoff) {
		goto __1
	}
	return J40_err(0)
__1:
	;
	fileoff = J40__min64(tls, fileoff, (*J40__source_st)(unsafe.Pointer(source)).Fileoff_limit)

	if !((*J40__source_st)(unsafe.Pointer(source)).Seek_func != 0) {
		goto __2
	}
	saved_errno = *(*int32)(unsafe.Pointer(libc.X__errno_location(tls)))
	*(*int32)(unsafe.Pointer(libc.X__errno_location(tls))) = 0

	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!((*struct {
		f func(*libc.TLS, Int64_t, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*J40__source_st)(unsafe.Pointer(source)).Seek_func})).f(tls, fileoff, (*J40__source_st)(unsafe.Pointer(source)).Data) != 0)), int64(0)) != 0) {
		goto __3
	}
	(*J40__st)(unsafe.Pointer(st)).Saved_errno = *(*int32)(unsafe.Pointer(libc.X__errno_location(tls)))
	if !(*(*int32)(unsafe.Pointer(libc.X__errno_location(tls))) == 0) {
		goto __4
	}
	*(*int32)(unsafe.Pointer(libc.X__errno_location(tls))) = saved_errno
__4:
	;
__5:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 84))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 84 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 84 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 84 + 3))))
	goto J40__ON_ERROR
	goto __6
__6:
	if 0 != 0 {
		goto __5
	}
	goto __7
__7:
	;
__3:
	;
	*(*int32)(unsafe.Pointer(libc.X__errno_location(tls))) = saved_errno
__2:
	;
	(*J40__source_st)(unsafe.Pointer(source)).Fileoff = fileoff
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__free_source(tls *libc.TLS, source uintptr) {
	if (*J40__source_st)(unsafe.Pointer(source)).Free_func != 0 {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*J40__source_st)(unsafe.Pointer(source)).Free_func})).f(tls, (*J40__source_st)(unsafe.Pointer(source)).Data)
	}
	(*J40__source_st)(unsafe.Pointer(source)).Read_func = uintptr(0)
	(*J40__source_st)(unsafe.Pointer(source)).Seek_func = uintptr(0)
	(*J40__source_st)(unsafe.Pointer(source)).Free_func = uintptr(0)
	(*J40__source_st)(unsafe.Pointer(source)).Data = uintptr(0)
}

type J40__map = struct {
	Codeoff Int64_t
	Fileoff Int64_t
}

const (
	J40__CONTAINER_CONFIRMED = 1

	J40__SEEN_JXLL = 2
	J40__SEEN_JXLI = 4
	J40__SEEN_JXLC = 8
	J40__SEEN_JXLP = 16

	J40__NO_MORE_CODESTREAM_BOX = 32

	J40__IMPLIED_LAST_MAP_ENTRY = 64

	J40__NO_MORE_BOX = 128
)

type J40__container_st = J40__container_st1

func J40__u32be(tls *libc.TLS, p uintptr) Uint32_t {
	return Uint32_t(*(*Uint8_t)(unsafe.Pointer(p)))<<24 | Uint32_t(*(*Uint8_t)(unsafe.Pointer(p + 1)))<<16 | Uint32_t(*(*Uint8_t)(unsafe.Pointer(p + 2)))<<8 | Uint32_t(*(*Uint8_t)(unsafe.Pointer(p + 3)))
}

// size is < 0 if EOF, or INT64_MAX if the box extends indefinitely until the end of file
func j40__box_header(tls *libc.TLS, st uintptr, type1 uintptr, size uintptr) J40_err {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var size32 Uint32_t
	var size64 Uint64_t

__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__try_read_from_source(tls, st, bp, int64(0), int64(8), bp+8) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
	if !(*(*Int64_t)(unsafe.Pointer(bp + 8)) == int64(0)) {
		goto __5
	}
	*(*Int64_t)(unsafe.Pointer(size)) = int64(-1)
	return J40_err(0)
__5:
	;
__6:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __9
	}
	goto J40__ON_ERROR
__9:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(*(*Int64_t)(unsafe.Pointer(bp + 8)) == int64(8))), int64(0)) != 0) {
		goto __10
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 3))))
	goto J40__ON_ERROR
__10:
	;
	goto __7
__7:
	if 0 != 0 {
		goto __6
	}
	goto __8
__8:
	;
	size32 = J40__u32be(tls, bp)
	*(*Uint32_t)(unsafe.Pointer(type1)) = J40__u32be(tls, bp+uintptr(4))
	if !(size32 == Uint32_t(0)) {
		goto __11
	}
	*(*Int64_t)(unsafe.Pointer(size)) = 9223372036854775807
	goto __12
__11:
	if !(size32 == Uint32_t(1)) {
		goto __13
	}
__15:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__read_from_source(tls, st, bp, int64(8)) != 0)), int64(0)) != 0) {
		goto __18
	}
	goto J40__ON_ERROR
__18:
	;
	goto __16
__16:
	if 0 != 0 {
		goto __15
	}
	goto __17
__17:
	;
	size64 = Uint64_t(J40__u32be(tls, bp))<<32 | Uint64_t(J40__u32be(tls, bp+uintptr(4)))
__19:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __22
	}
	goto J40__ON_ERROR
__22:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(size64 >= uint64(16))), int64(0)) != 0) {
		goto __23
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 89))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 89 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 89 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 89 + 3))))
	goto J40__ON_ERROR
__23:
	;
	goto __20
__20:
	if 0 != 0 {
		goto __19
	}
	goto __21
__21:
	;
__24:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __27
	}
	goto J40__ON_ERROR
__27:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(size64 <= uint64(9223372036854775807))), int64(0)) != 0) {
		goto __28
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 3))))
	goto J40__ON_ERROR
__28:
	;
	goto __25
__25:
	if 0 != 0 {
		goto __24
	}
	goto __26
__26:
	;
	*(*Int64_t)(unsafe.Pointer(size)) = Int64_t(size64) - int64(16)
	goto __14
__13:
__29:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __32
	}
	goto J40__ON_ERROR
__32:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(size32 >= Uint32_t(8))), int64(0)) != 0) {
		goto __33
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 89))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 89 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 89 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 89 + 3))))
	goto J40__ON_ERROR
__33:
	;
	goto __30
__30:
	if 0 != 0 {
		goto __29
	}
	goto __31
__31:
	;
	*(*Int64_t)(unsafe.Pointer(size)) = Int64_t(size32) - int64(8)
__14:
	;
__12:
	;
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

// scans as many boxes as required to map given codestream offset (i.e. the inclusive limit).
// this is done in the best effort basis, so even after this
// `j40__map_codestream_offset(st, wanted_codeoff)` may still fail.
func j40__container(tls *libc.TLS, st uintptr, wanted_codeoff Int64_t) J40_err {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var source uintptr
	var c uintptr

	var newptr uintptr

	var codestream_box int32
	source = (*J40__st)(unsafe.Pointer(st)).Source
	c = (*J40__st)(unsafe.Pointer(st)).Container

	if !!(int32((*J40__container_st)(unsafe.Pointer(c)).Map) != 0) {
		goto __1
	}
	(*J40__container_st)(unsafe.Pointer(c)).Map_cap = 8
	(*J40__container_st)(unsafe.Pointer(c)).Nmap = 1
__2:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __5
	}
	goto J40__ON_ERROR
__5:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(c+8, j40__malloc(tls, uint64(unsafe.Sizeof(J40__map{}))*Size_t((*J40__container_st)(unsafe.Pointer(c)).Map_cap)))) != 0)), int64(0)) != 0) {
		goto __6
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__6:
	;
	goto __3
__3:
	if 0 != 0 {
		goto __2
	}
	goto __4
__4:
	;
	(*J40__map)(unsafe.Pointer((*J40__container_st)(unsafe.Pointer(c)).Map)).Codeoff = libc.AssignPtrInt64((*J40__container_st)(unsafe.Pointer(c)).Map+8, int64(0))
__1:
	;
	if !((*J40__container_st)(unsafe.Pointer(c)).Flags&J40__IMPLIED_LAST_MAP_ENTRY != 0) {
		goto __7
	}
	return J40_err(0)
__7:
	;
	if !(wanted_codeoff < (*J40__map)(unsafe.Pointer((*J40__container_st)(unsafe.Pointer(c)).Map+uintptr((*J40__container_st)(unsafe.Pointer(c)).Nmap-1)*16)).Codeoff) {
		goto __8
	}
	return J40_err(0)
__8:
	;
	if !((*J40__container_st)(unsafe.Pointer(c)).Flags&J40__CONTAINER_CONFIRMED != 0) {
		goto __9
	}
__11:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__seek_from_source(tls, st, (*J40__map)(unsafe.Pointer((*J40__container_st)(unsafe.Pointer(c)).Map+uintptr((*J40__container_st)(unsafe.Pointer(c)).Nmap-1)*16)).Fileoff) != 0)), int64(0)) != 0) {
		goto __14
	}
	goto J40__ON_ERROR
__14:
	;
	goto __12
__12:
	if 0 != 0 {
		goto __11
	}
	goto __13
__13:
	;
	goto __10
__9:
__15:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__seek_from_source(tls, st, int64(0)) != 0)), int64(0)) != 0) {
		goto __18
	}
	goto J40__ON_ERROR
__18:
	;
	goto __16
__16:
	if 0 != 0 {
		goto __15
	}
	goto __17
__17:
	;
__19:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__read_from_source(tls, st, bp, int64(2)) != 0)), int64(0)) != 0) {
		goto __22
	}
	goto J40__ON_ERROR
__22:
	;
	goto __20
__20:
	if 0 != 0 {
		goto __19
	}
	goto __21
__21:
	;
	if !(int32(*(*Uint8_t)(unsafe.Pointer(bp))) == 0xff && int32(*(*Uint8_t)(unsafe.Pointer(bp + 1))) == 0x0a) {
		goto __23
	}
	(*J40__container_st)(unsafe.Pointer(c)).Flags = uint32(J40__CONTAINER_CONFIRMED | J40__IMPLIED_LAST_MAP_ENTRY)
	return J40_err(0)
__23:
	;
__24:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __27
	}
	goto J40__ON_ERROR
__27:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(*(*Uint8_t)(unsafe.Pointer(bp))) == int32(JXL_BOX[0]) && int32(*(*Uint8_t)(unsafe.Pointer(bp + 1))) == int32(JXL_BOX[1]))), int64(0)) != 0) {
		goto __28
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 94))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 94 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 94 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 94 + 3))))
	goto J40__ON_ERROR
__28:
	;
	goto __25
__25:
	if 0 != 0 {
		goto __24
	}
	goto __26
__26:
	;
__29:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__read_from_source(tls, st, bp, int64(uint64(unsafe.Sizeof(JXL_BOX))+uint64(unsafe.Sizeof(FTYP_BOX))-uint64(2))) != 0)), int64(0)) != 0) {
		goto __32
	}
	goto J40__ON_ERROR
__32:
	;
	goto __30
__30:
	if 0 != 0 {
		goto __29
	}
	goto __31
__31:
	;
__33:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __36
	}
	goto J40__ON_ERROR
__36:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(libc.Xmemcmp(tls, bp, uintptr(unsafe.Pointer(&JXL_BOX))+uintptr(2), uint64(unsafe.Sizeof(JXL_BOX))-uint64(2)) == 0)), int64(0)) != 0) {
		goto __37
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 94))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 94 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 94 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 94 + 3))))
	goto J40__ON_ERROR
__37:
	;
	goto __34
__34:
	if 0 != 0 {
		goto __33
	}
	goto __35
__35:
	;
__38:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __41
	}
	goto J40__ON_ERROR
__41:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(libc.Xmemcmp(tls, bp+uintptr(uint64(unsafe.Sizeof(JXL_BOX))-uint64(2)), uintptr(unsafe.Pointer(&FTYP_BOX)), uint64(unsafe.Sizeof(FTYP_BOX))) == 0)), int64(0)) != 0) {
		goto __42
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 99))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 99 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 99 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 99 + 3))))
	goto J40__ON_ERROR
__42:
	;
	goto __39
__39:
	if 0 != 0 {
		goto __38
	}
	goto __40
__40:
	;
	*(*uint32)(unsafe.Pointer(c)) |= J40__CONTAINER_CONFIRMED
	(*J40__map)(unsafe.Pointer((*J40__container_st)(unsafe.Pointer(c)).Map)).Fileoff = (*J40__source_st)(unsafe.Pointer(source)).Fileoff
__10:
	;
__43:
	if !(wanted_codeoff >= (*J40__map)(unsafe.Pointer((*J40__container_st)(unsafe.Pointer(c)).Map+uintptr((*J40__container_st)(unsafe.Pointer(c)).Nmap-1)*16)).Codeoff) {
		goto __44
	}
	codestream_box = 0

__45:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__box_header(tls, st, bp+32, bp+40) != 0)), int64(0)) != 0) {
		goto __48
	}
	goto J40__ON_ERROR
__48:
	;
	goto __46
__46:
	if 0 != 0 {
		goto __45
	}
	goto __47
__47:
	;
	if !(*(*Int64_t)(unsafe.Pointer(bp + 40)) < int64(0)) {
		goto __49
	}
	goto __44
__49:
	;
	switch *(*Uint32_t)(unsafe.Pointer(bp + 32)) {
	case Uint32_t(0x6a786c6c):
		goto __51

	case Uint32_t(0x6a786c69):
		goto __52

	case Uint32_t(0x6a786c63):
		goto __53

	case Uint32_t(0x6a786c70):
		goto __54

	case Uint32_t(0x62726f62):
		goto __55
	}
	goto __50
__51:
__56:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __59
	}
	goto J40__ON_ERROR
__59:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!!((*J40__container_st)(unsafe.Pointer(c)).Flags&J40__SEEN_JXLL != 0)), int64(0)) != 0) {
		goto __60
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 104))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 104 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 104 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 104 + 3))))
	goto J40__ON_ERROR
__60:
	;
	goto __57
__57:
	if 0 != 0 {
		goto __56
	}
	goto __58
__58:
	;
	*(*uint32)(unsafe.Pointer(c)) |= J40__SEEN_JXLL
	goto __50

__52:
__61:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __64
	}
	goto J40__ON_ERROR
__64:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!!((*J40__container_st)(unsafe.Pointer(c)).Flags&J40__SEEN_JXLI != 0)), int64(0)) != 0) {
		goto __65
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 104))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 104 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 104 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 104 + 3))))
	goto J40__ON_ERROR
__65:
	;
	goto __62
__62:
	if 0 != 0 {
		goto __61
	}
	goto __63
__63:
	;
	*(*uint32)(unsafe.Pointer(c)) |= J40__SEEN_JXLI
	goto __50

__53:
__66:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __69
	}
	goto J40__ON_ERROR
__69:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!!((*J40__container_st)(unsafe.Pointer(c)).Flags&J40__NO_MORE_CODESTREAM_BOX != 0)), int64(0)) != 0) {
		goto __70
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 104))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 104 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 104 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 104 + 3))))
	goto J40__ON_ERROR
__70:
	;
	goto __67
__67:
	if 0 != 0 {
		goto __66
	}
	goto __68
__68:
	;
__71:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __74
	}
	goto J40__ON_ERROR
__74:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!!((*J40__container_st)(unsafe.Pointer(c)).Flags&uint32(J40__SEEN_JXLP|J40__SEEN_JXLC) != 0)), int64(0)) != 0) {
		goto __75
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 104))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 104 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 104 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 104 + 3))))
	goto J40__ON_ERROR
__75:
	;
	goto __72
__72:
	if 0 != 0 {
		goto __71
	}
	goto __73
__73:
	;
	*(*uint32)(unsafe.Pointer(c)) |= uint32(J40__SEEN_JXLC | J40__NO_MORE_CODESTREAM_BOX)
	codestream_box = 1
	goto __50

__54:
__76:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __79
	}
	goto J40__ON_ERROR
__79:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!!((*J40__container_st)(unsafe.Pointer(c)).Flags&J40__NO_MORE_CODESTREAM_BOX != 0)), int64(0)) != 0) {
		goto __80
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 104))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 104 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 104 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 104 + 3))))
	goto J40__ON_ERROR
__80:
	;
	goto __77
__77:
	if 0 != 0 {
		goto __76
	}
	goto __78
__78:
	;
__81:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __84
	}
	goto J40__ON_ERROR
__84:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!!((*J40__container_st)(unsafe.Pointer(c)).Flags&J40__SEEN_JXLC != 0)), int64(0)) != 0) {
		goto __85
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 104))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 104 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 104 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 104 + 3))))
	goto J40__ON_ERROR
__85:
	;
	goto __82
__82:
	if 0 != 0 {
		goto __81
	}
	goto __83
__83:
	;
	*(*uint32)(unsafe.Pointer(c)) |= J40__SEEN_JXLP
	codestream_box = 1
__86:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __89
	}
	goto J40__ON_ERROR
__89:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(*(*Int64_t)(unsafe.Pointer(bp + 40)) >= int64(4))), int64(0)) != 0) {
		goto __90
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 109))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 109 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 109 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 109 + 3))))
	goto J40__ON_ERROR
__90:
	;
	goto __87
__87:
	if 0 != 0 {
		goto __86
	}
	goto __88
__88:
	;
__91:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__read_from_source(tls, st, bp, int64(4)) != 0)), int64(0)) != 0) {
		goto __94
	}
	goto J40__ON_ERROR
__94:
	;
	goto __92
__92:
	if 0 != 0 {
		goto __91
	}
	goto __93
__93:
	;
	if !!(int32(*(*Uint8_t)(unsafe.Pointer(bp)))>>7 != 0) {
		goto __95
	}
	*(*uint32)(unsafe.Pointer(c)) |= J40__NO_MORE_CODESTREAM_BOX
__95:
	;
	if !(*(*Int64_t)(unsafe.Pointer(bp + 40)) < 9223372036854775807) {
		goto __96
	}
	*(*Int64_t)(unsafe.Pointer(bp + 40)) -= int64(4)
__96:
	;
	goto __50

__55:
__97:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __100
	}
	goto J40__ON_ERROR
__100:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(*(*Int64_t)(unsafe.Pointer(bp + 40)) > int64(4))), int64(0)) != 0) {
		goto __101
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 114))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 114 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 114 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 114 + 3))))
	goto J40__ON_ERROR
__101:
	;
	goto __98
__98:
	if 0 != 0 {
		goto __97
	}
	goto __99
__99:
	;
__102:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__read_from_source(tls, st, bp, int64(4)) != 0)), int64(0)) != 0) {
		goto __105
	}
	goto J40__ON_ERROR
__105:
	;
	goto __103
__103:
	if 0 != 0 {
		goto __102
	}
	goto __104
__104:
	;
	*(*Uint32_t)(unsafe.Pointer(bp + 32)) = J40__u32be(tls, bp)
__106:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __109
	}
	goto J40__ON_ERROR
__109:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(*(*Uint32_t)(unsafe.Pointer(bp + 32)) != Uint32_t(0x62726f62) && *(*Uint32_t)(unsafe.Pointer(bp + 32))>>8 != Uint32_t(0x6a786c))), int64(0)) != 0) {
		goto __110
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 114))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 114 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 114 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 114 + 3))))
	goto J40__ON_ERROR
__110:
	;
	goto __107
__107:
	if 0 != 0 {
		goto __106
	}
	goto __108
__108:
	;
	if !(*(*Int64_t)(unsafe.Pointer(bp + 40)) < 9223372036854775807) {
		goto __111
	}
	*(*Int64_t)(unsafe.Pointer(bp + 40)) -= int64(4)
__111:
	;
	goto __50
__50:
	;
	if !(*(*Int64_t)(unsafe.Pointer(bp + 40)) == 9223372036854775807) {
		goto __112
	}
	if !(codestream_box != 0) {
		goto __113
	}
	*(*uint32)(unsafe.Pointer(c)) |= J40__IMPLIED_LAST_MAP_ENTRY
__113:
	;
	*(*uint32)(unsafe.Pointer(c)) |= J40__NO_MORE_BOX
	goto __44
__112:
	;
	if !(codestream_box != 0) {
		goto __114
	}

__115:
	newptr = j40__realloc32(tls, st, *(*uintptr)(unsafe.Pointer(c + 8)), uint64(unsafe.Sizeof(J40__map{})), (*J40__container_st)(unsafe.Pointer(c)).Nmap+1, c+20)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(newptr != 0)), int64(1)) != 0) {
		goto __118
	}
	*(*uintptr)(unsafe.Pointer(c + 8)) = newptr
	goto __119
__118:
	goto J40__ON_ERROR
__119:
	;
	goto __116
__116:
	if 0 != 0 {
		goto __115
	}
	goto __117
__117:
	;
	(*J40__map)(unsafe.Pointer((*J40__container_st)(unsafe.Pointer(c)).Map + uintptr((*J40__container_st)(unsafe.Pointer(c)).Nmap-1)*16)).Fileoff = (*J40__source_st)(unsafe.Pointer(source)).Fileoff
__120:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __123
	}
	goto J40__ON_ERROR
__123:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(J40__add64(tls, (*J40__map)(unsafe.Pointer((*J40__container_st)(unsafe.Pointer(c)).Map+uintptr((*J40__container_st)(unsafe.Pointer(c)).Nmap-1)*16)).Codeoff, *(*Int64_t)(unsafe.Pointer(bp + 40)), (*J40__container_st)(unsafe.Pointer(c)).Map+uintptr((*J40__container_st)(unsafe.Pointer(c)).Nmap)*16) != 0)), int64(0)) != 0) {
		goto __124
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 3))))
	goto J40__ON_ERROR
__124:
	;
	goto __121
__121:
	if 0 != 0 {
		goto __120
	}
	goto __122
__122:
	;
__125:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __128
	}
	goto J40__ON_ERROR
__128:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(J40__add32(tls, (*J40__container_st)(unsafe.Pointer(c)).Nmap, 1, c+16) != 0)), int64(0)) != 0) {
		goto __129
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 3))))
	goto J40__ON_ERROR
__129:
	;
	goto __126
__126:
	if 0 != 0 {
		goto __125
	}
	goto __127
__127:
	;
__114:
	;
__130:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __133
	}
	goto J40__ON_ERROR
__133:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(J40__add64(tls, (*J40__source_st)(unsafe.Pointer(source)).Fileoff, *(*Int64_t)(unsafe.Pointer(bp + 40)), (*J40__container_st)(unsafe.Pointer(c)).Map+uintptr((*J40__container_st)(unsafe.Pointer(c)).Nmap-1)*16+8) != 0)), int64(0)) != 0) {
		goto __134
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 3))))
	goto J40__ON_ERROR
__134:
	;
	goto __131
__131:
	if 0 != 0 {
		goto __130
	}
	goto __132
__132:
	;
__135:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__seek_from_source(tls, st, (*J40__map)(unsafe.Pointer((*J40__container_st)(unsafe.Pointer(c)).Map+uintptr((*J40__container_st)(unsafe.Pointer(c)).Nmap-1)*16)).Fileoff) != 0)), int64(0)) != 0) {
		goto __138
	}
	goto J40__ON_ERROR
__138:
	;
	goto __136
__136:
	if 0 != 0 {
		goto __135
	}
	goto __137
__137:
	;
	goto __43
__44:
	;
	if !((*J40__container_st)(unsafe.Pointer(c)).Flags&J40__NO_MORE_BOX != 0 && !((*J40__container_st)(unsafe.Pointer(c)).Flags&uint32(J40__SEEN_JXLC|J40__SEEN_JXLP) != 0)) {
		goto __139
	}
	(*J40__st)(unsafe.Pointer(st)).Cannot_retry = 1
__140:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 3))))
	goto J40__ON_ERROR
	goto __141
__141:
	if 0 != 0 {
		goto __140
	}
	goto __142
__142:
	;
__139:
	;
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

var JXL_BOX = [12]Uint8_t{
	Uint8_t(0x00), Uint8_t(0x00), Uint8_t(0x00), Uint8_t(0x0c), Uint8_t(0x4a), Uint8_t(0x58), Uint8_t(0x4c), Uint8_t(0x20), Uint8_t(0x0d), Uint8_t(0x0a), Uint8_t(0x87), Uint8_t(0x0a),
}
var FTYP_BOX = [20]Uint8_t{
	Uint8_t(0x00), Uint8_t(0x00), Uint8_t(0x00), Uint8_t(0x14), Uint8_t(0x66), Uint8_t(0x74), Uint8_t(0x79), Uint8_t(0x70), Uint8_t(0x6a), Uint8_t(0x78), Uint8_t(0x6c), Uint8_t(0x20),
	Uint8_t(0x00), Uint8_t(0x00), Uint8_t(0x00), Uint8_t(0x00), Uint8_t(0x6a), Uint8_t(0x78), Uint8_t(0x6c), Uint8_t(0x20),
}

// returns i such that codeoff is in [C[i], C[i+1]), or nmap-1 if there is no such map entry
func j40__search_codestream_offset(tls *libc.TLS, st uintptr, codeoff Int64_t) Int32_t {
	var map1 uintptr = (*J40__container_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Container)).Map
	var nmap Int32_t = (*J40__container_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Container)).Nmap
	var i Int32_t

	for i = 1; i < nmap; i++ {
		if codeoff < (*J40__map)(unsafe.Pointer(map1+uintptr(i)*16)).Codeoff {
			break
		}
	}
	return i - 1
}

func j40__map_codestream_offset(tls *libc.TLS, st uintptr, codeoff Int64_t, fileoff uintptr) J40_err {
	var map1 uintptr
	var nmap Int32_t
	var i Int32_t
	map1 = (*J40__container_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Container)).Map
	nmap = (*J40__container_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Container)).Nmap

	i = j40__search_codestream_offset(tls, st, codeoff)
	if !(i < nmap-1) {
		goto __1
	}

	*(*Int64_t)(unsafe.Pointer(fileoff)) = (*J40__map)(unsafe.Pointer(map1+uintptr(i)*16)).Fileoff + (codeoff - (*J40__map)(unsafe.Pointer(map1+uintptr(i)*16)).Codeoff)
	goto __2
__1:
	if !((*J40__container_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Container)).Flags&J40__IMPLIED_LAST_MAP_ENTRY != 0) {
		goto __3
	}
__5:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __8
	}
	goto J40__ON_ERROR
__8:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(J40__add64(tls, (*J40__map)(unsafe.Pointer(map1+uintptr(nmap-1)*16)).Fileoff, codeoff-(*J40__map)(unsafe.Pointer(map1+uintptr(nmap-1)*16)).Codeoff, fileoff) != 0)), int64(0)) != 0) {
		goto __9
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 3))))
	goto J40__ON_ERROR
__9:
	;
	goto __6
__6:
	if 0 != 0 {
		goto __5
	}
	goto __7
__7:
	;
	goto __4
__3:
	if !((*J40__container_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Container)).Flags&J40__NO_MORE_CODESTREAM_BOX != 0) {
		goto __10
	}

	if !(codeoff == (*J40__map)(unsafe.Pointer(map1+uintptr(nmap-1)*16)).Codeoff) {
		goto __12
	}
	*(*Int64_t)(unsafe.Pointer(fileoff)) = (*J40__map)(unsafe.Pointer(map1 + uintptr(nmap-1)*16)).Fileoff
	goto __13
__12:
	(*J40__st)(unsafe.Pointer(st)).Cannot_retry = 1
__14:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 3))))
	goto J40__ON_ERROR
	goto __15
__15:
	if 0 != 0 {
		goto __14
	}
	goto __16
__16:
	;
__13:
	;
	goto __11
__10:
__17:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 3))))
	goto J40__ON_ERROR
	goto __18
__18:
	if 0 != 0 {
		goto __17
	}
	goto __19
__19:
	;
__11:
	;
__4:
	;
__2:
	;
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__free_container(tls *libc.TLS, container uintptr) {
	j40__free(tls, (*J40__container_st)(unsafe.Pointer(container)).Map)
	(*J40__container_st)(unsafe.Pointer(container)).Map = uintptr(0)
	(*J40__container_st)(unsafe.Pointer(container)).Nmap = libc.AssignPtrInt32(container+20, 0)
}

type J40__buffer_st = J40__buffer_st1

func j40__init_buffer(tls *libc.TLS, st uintptr, codeoff Int64_t, codeoff_limit Int64_t) J40_err {
	var bits uintptr
	var checkpoint uintptr
	var buffer uintptr
	bits = st + 16
	checkpoint = (*J40__st)(unsafe.Pointer(st)).Buffer + 40
	buffer = (*J40__st)(unsafe.Pointer(st)).Buffer

__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(bits+16, libc.AssignPtrUintptr(bits+24, libc.AssignPtrUintptr(buffer, j40__malloc(tls, uint64(J40__INITIAL_BUFSIZE)))))) != 0)), int64(0)) != 0) {
		goto __5
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__5:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
	(*J40__buffer_st)(unsafe.Pointer(buffer)).Size = int64(0)
	(*J40__buffer_st)(unsafe.Pointer(buffer)).Capacity = int64(J40__INITIAL_BUFSIZE)
	(*J40__buffer_st)(unsafe.Pointer(buffer)).Next_codeoff = codeoff
	(*J40__buffer_st)(unsafe.Pointer(buffer)).Codeoff_limit = codeoff_limit
	(*J40__bits_st)(unsafe.Pointer(bits)).Bits = uint64(0)
	(*J40__bits_st)(unsafe.Pointer(bits)).Nbits = 0
	*(*J40__bits_st)(unsafe.Pointer(checkpoint)) = *(*J40__bits_st)(unsafe.Pointer(bits))
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__refill_buffer(tls *libc.TLS, st uintptr) J40_err {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var bits uintptr
	var checkpoint uintptr
	var buffer uintptr
	var container uintptr
	var available Int64_t
	var wanted_codeoff Int64_t
	var i Int32_t
	var committed_size Int64_t
	var newptr uintptr
	var newcap Int64_t
	var relptr Ptrdiff_t
	var box_size Int64_t
	_ = box_size
	var map1 uintptr
	var nmap Int32_t

	var readable_size Int64_t

	bits = st + 16
	checkpoint = (*J40__st)(unsafe.Pointer(st)).Buffer + 40
	buffer = (*J40__st)(unsafe.Pointer(st)).Buffer
	container = (*J40__st)(unsafe.Pointer(st)).Container

	if !((*J40__bits_st)(unsafe.Pointer(checkpoint)).Ptr > (*J40__buffer_st)(unsafe.Pointer(buffer)).Buf) {
		goto __1
	}
	committed_size = (int64((*J40__bits_st)(unsafe.Pointer(checkpoint)).Ptr) - int64((*J40__buffer_st)(unsafe.Pointer(buffer)).Buf)) / 1

	libc.Xmemmove(tls, (*J40__buffer_st)(unsafe.Pointer(buffer)).Buf, (*J40__bits_st)(unsafe.Pointer(checkpoint)).Ptr, Size_t((*J40__buffer_st)(unsafe.Pointer(buffer)).Size-committed_size))
	*(*Int64_t)(unsafe.Pointer(buffer + 8)) -= committed_size
	*(*uintptr)(unsafe.Pointer(bits + 16)) -= uintptr(committed_size)
	*(*uintptr)(unsafe.Pointer(bits + 24)) -= uintptr(committed_size)
	(*J40__bits_st)(unsafe.Pointer(checkpoint)).Ptr = (*J40__buffer_st)(unsafe.Pointer(buffer)).Buf
__1:
	;
	if !((*J40__buffer_st)(unsafe.Pointer(buffer)).Size == (*J40__buffer_st)(unsafe.Pointer(buffer)).Capacity) {
		goto __2
	}
	newcap = J40__clamp_add64(tls, (*J40__buffer_st)(unsafe.Pointer(buffer)).Capacity, (*J40__buffer_st)(unsafe.Pointer(buffer)).Capacity)
	relptr = (int64((*J40__bits_st)(unsafe.Pointer(bits)).Ptr) - int64((*J40__buffer_st)(unsafe.Pointer(buffer)).Buf)) / 1
__3:
	newptr = j40__realloc64(tls, st, *(*uintptr)(unsafe.Pointer(buffer)), uint64(unsafe.Sizeof(Uint8_t(0))), newcap, buffer+16)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(newptr != 0)), int64(1)) != 0) {
		goto __6
	}
	*(*uintptr)(unsafe.Pointer(buffer)) = newptr
	goto __7
__6:
	goto J40__ON_ERROR
__7:
	;
	goto __4
__4:
	if 0 != 0 {
		goto __3
	}
	goto __5
__5:
	;
	(*J40__bits_st)(unsafe.Pointer(bits)).Ptr = (*J40__buffer_st)(unsafe.Pointer(buffer)).Buf + uintptr(relptr)
	(*J40__bits_st)(unsafe.Pointer(checkpoint)).Ptr = (*J40__buffer_st)(unsafe.Pointer(buffer)).Buf
__2:
	;
	wanted_codeoff = J40__min64(tls, (*J40__buffer_st)(unsafe.Pointer(buffer)).Codeoff_limit,
		J40__clamp_add64(tls, (*J40__buffer_st)(unsafe.Pointer(buffer)).Next_codeoff, (*J40__buffer_st)(unsafe.Pointer(buffer)).Capacity-(*J40__buffer_st)(unsafe.Pointer(buffer)).Size))
	available = wanted_codeoff - (*J40__buffer_st)(unsafe.Pointer(buffer)).Next_codeoff
	wanted_codeoff--

	if !!(int32((*J40__container_st)(unsafe.Pointer(container)).Map) != 0) {
		goto __8
	}
__9:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__container(tls, st, wanted_codeoff) != 0)), int64(0)) != 0) {
		goto __12
	}
	goto J40__ON_ERROR
__12:
	;
	goto __10
__10:
	if 0 != 0 {
		goto __9
	}
	goto __11
__11:
	;
__8:
	;
	i = j40__search_codestream_offset(tls, st, (*J40__buffer_st)(unsafe.Pointer(buffer)).Next_codeoff)
__13:
	if !(available > int64(0)) {
		goto __14
	}
	map1 = (*J40__container_st)(unsafe.Pointer(container)).Map
	nmap = (*J40__container_st)(unsafe.Pointer(container)).Nmap

	if !(i < nmap-1) {
		goto __15
	}
	box_size = (*J40__map)(unsafe.Pointer(map1+uintptr(i+1)*16)).Codeoff - (*J40__map)(unsafe.Pointer(map1+uintptr(i)*16)).Codeoff

	readable_size = J40__min64(tls, available, (*J40__map)(unsafe.Pointer(map1+uintptr(i+1)*16)).Codeoff-(*J40__buffer_st)(unsafe.Pointer(buffer)).Next_codeoff)

	*(*Int64_t)(unsafe.Pointer(bp)) = (*J40__map)(unsafe.Pointer(map1+uintptr(i)*16)).Fileoff + ((*J40__buffer_st)(unsafe.Pointer(buffer)).Next_codeoff - (*J40__map)(unsafe.Pointer(map1+uintptr(i)*16)).Codeoff)
	goto __16
__15:
	if !((*J40__container_st)(unsafe.Pointer(container)).Flags&J40__IMPLIED_LAST_MAP_ENTRY != 0) {
		goto __17
	}
	readable_size = available
__19:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __22
	}
	goto J40__ON_ERROR
__22:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(J40__add64(tls, (*J40__map)(unsafe.Pointer(map1+uintptr(i)*16)).Fileoff, (*J40__buffer_st)(unsafe.Pointer(buffer)).Next_codeoff-(*J40__map)(unsafe.Pointer(map1+uintptr(nmap-1)*16)).Codeoff, bp) != 0)), int64(0)) != 0) {
		goto __23
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 3))))
	goto J40__ON_ERROR
__23:
	;
	goto __20
__20:
	if 0 != 0 {
		goto __19
	}
	goto __21
__21:
	;
	goto __18
__17:
__24:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__container(tls, st, wanted_codeoff) != 0)), int64(0)) != 0) {
		goto __27
	}
	goto J40__ON_ERROR
__27:
	;
	goto __25
__25:
	if 0 != 0 {
		goto __24
	}
	goto __26
__26:
	;
	if !(nmap == (*J40__container_st)(unsafe.Pointer(container)).Nmap && !((*J40__container_st)(unsafe.Pointer(container)).Flags&J40__IMPLIED_LAST_MAP_ENTRY != 0)) {
		goto __28
	}
	goto __14
__28:
	;
	goto __13
__18:
	;
__16:
	;
__29:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__seek_from_source(tls, st, *(*Int64_t)(unsafe.Pointer(bp))) != 0)), int64(0)) != 0) {
		goto __32
	}
	goto J40__ON_ERROR
__32:
	;
	goto __30
__30:
	if 0 != 0 {
		goto __29
	}
	goto __31
__31:
	;
__33:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__try_read_from_source(tls, st, (*J40__buffer_st)(unsafe.Pointer(buffer)).Buf+uintptr((*J40__buffer_st)(unsafe.Pointer(buffer)).Size), int64(0), readable_size, bp+8) != 0)), int64(0)) != 0) {
		goto __36
	}
	goto J40__ON_ERROR
__36:
	;
	goto __34
__34:
	if 0 != 0 {
		goto __33
	}
	goto __35
__35:
	;
	if !(*(*Int64_t)(unsafe.Pointer(bp + 8)) == int64(0)) {
		goto __37
	}
	goto __14
__37:
	;
	*(*Int64_t)(unsafe.Pointer(buffer + 8)) += *(*Int64_t)(unsafe.Pointer(bp + 8))
__38:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __41
	}
	goto J40__ON_ERROR
__41:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(J40__add64(tls, (*J40__buffer_st)(unsafe.Pointer(buffer)).Next_codeoff, *(*Int64_t)(unsafe.Pointer(bp + 8)), buffer+24) != 0)), int64(0)) != 0) {
		goto __42
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 3))))
	goto J40__ON_ERROR
__42:
	;
	goto __39
__39:
	if 0 != 0 {
		goto __38
	}
	goto __40
__40:
	;
	(*J40__bits_st)(unsafe.Pointer(bits)).End = libc.AssignPtrUintptr(checkpoint+24, (*J40__buffer_st)(unsafe.Pointer(buffer)).Buf+uintptr((*J40__buffer_st)(unsafe.Pointer(buffer)).Size))
	available = available - *(*Int64_t)(unsafe.Pointer(bp + 8))
	if !(*(*Int64_t)(unsafe.Pointer(bp + 8)) == readable_size) {
		goto __43
	}
	i++
__43:
	;
	goto __13
__14:
	;
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__seek_buffer(tls *libc.TLS, st uintptr, codeoff Int64_t) J40_err {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var reusable_size Int64_t

	reusable_size = (*J40__buffer_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Buffer)).Next_codeoff - codeoff
	(*J40__st)(unsafe.Pointer(st)).Bits.Bits = uint64(0)
	(*J40__st)(unsafe.Pointer(st)).Bits.Nbits = 0
	if !(int64(0) < reusable_size && reusable_size <= (*J40__buffer_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Buffer)).Size) {
		goto __1
	}
	(*J40__st)(unsafe.Pointer(st)).Bits.Ptr = (*J40__buffer_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Buffer)).Buf + uintptr((*J40__buffer_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Buffer)).Size-reusable_size)
	(*J40__st)(unsafe.Pointer(st)).Bits.End = (*J40__buffer_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Buffer)).Buf + uintptr((*J40__buffer_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Buffer)).Size)
	goto __2
__1:
	(*J40__st)(unsafe.Pointer(st)).Bits.Ptr = libc.AssignPtrUintptr(st+16+24, (*J40__buffer_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Buffer)).Buf)
	(*J40__buffer_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Buffer)).Size = int64(0)
	(*J40__buffer_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Buffer)).Next_codeoff = codeoff
__3:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__map_codestream_offset(tls, st, codeoff, bp) != 0)), int64(0)) != 0) {
		goto __6
	}
	goto J40__ON_ERROR
__6:
	;
	goto __4
__4:
	if 0 != 0 {
		goto __3
	}
	goto __5
__5:
	;
__7:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__seek_from_source(tls, st, *(*Int64_t)(unsafe.Pointer(bp))) != 0)), int64(0)) != 0) {
		goto __10
	}
	goto J40__ON_ERROR
__10:
	;
	goto __8
__8:
	if 0 != 0 {
		goto __7
	}
	goto __9
__9:
	;
__2:
	;
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__codestream_offset(tls *libc.TLS, st uintptr) Int64_t {
	return (*J40__buffer_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Buffer)).Next_codeoff - (*J40__buffer_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Buffer)).Size + (int64((*J40__st)(unsafe.Pointer(st)).Bits.Ptr)-int64((*J40__buffer_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Buffer)).Buf))/1 - Int64_t((*J40__st)(unsafe.Pointer(st)).Bits.Nbits/8)
}

// diagnostic only, doesn't check for overflow or anything
func J40__bits_read(tls *libc.TLS, st uintptr) Int64_t {
	var nbytes Int32_t = J40__ceil_div32(tls, (*J40__st)(unsafe.Pointer(st)).Bits.Nbits, 8)
	var nbits Int32_t = 8*nbytes - (*J40__st)(unsafe.Pointer(st)).Bits.Nbits

	var codeoff Int64_t = (*J40__buffer_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Buffer)).Next_codeoff - (*J40__buffer_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Buffer)).Size + (int64((*J40__st)(unsafe.Pointer(st)).Bits.Ptr)-int64((*J40__buffer_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Buffer)).Buf))/1 - Int64_t(nbytes)
	var map1 = *(*J40__map)(unsafe.Pointer((*J40__container_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Container)).Map + uintptr(j40__search_codestream_offset(tls, st, codeoff))*16))
	return (map1.Fileoff+(codeoff-map1.Codeoff))*int64(8) + Int64_t(nbits)
}

func j40__free_buffer(tls *libc.TLS, buffer uintptr) {
	j40__free(tls, (*J40__buffer_st)(unsafe.Pointer(buffer)).Buf)
	(*J40__buffer_st)(unsafe.Pointer(buffer)).Buf = uintptr(0)
	(*J40__buffer_st)(unsafe.Pointer(buffer)).Size = libc.AssignPtrInt64(buffer+16, int64(0))
}

func j40__always_refill(tls *libc.TLS, st uintptr, n Int32_t) J40_err {
	var bits uintptr
	var consumed Int32_t
	bits = st + 16

__1:
	if !(1 != 0) {
		goto __2
	}
	consumed = (NBITS - (*J40__bits_st)(unsafe.Pointer(bits)).Nbits) >> 3
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!((int64((*J40__bits_st)(unsafe.Pointer(bits)).End)-int64((*J40__bits_st)(unsafe.Pointer(bits)).Ptr))/1 >= int64(consumed))), int64(1)) != 0) {
		goto __3
	}

__4:
	*(*Uint64_t)(unsafe.Pointer(bits + 8)) |= Uint64_t(*(*Uint8_t)(unsafe.Pointer(libc.PostIncUintptr(&(*J40__bits_st)(unsafe.Pointer(bits)).Ptr, 1)))) << (*J40__bits_st)(unsafe.Pointer(bits)).Nbits
	*(*Int32_t)(unsafe.Pointer(bits)) += 8
	goto __5
__5:
	if (*J40__bits_st)(unsafe.Pointer(bits)).Nbits <= NBITS-8 {
		goto __4
	}
	goto __6
__6:
	;
	goto __2
__3:
	;
__7:
	if !((*J40__bits_st)(unsafe.Pointer(bits)).Ptr < (*J40__bits_st)(unsafe.Pointer(bits)).End) {
		goto __8
	}
	*(*Uint64_t)(unsafe.Pointer(bits + 8)) |= Uint64_t(*(*Uint8_t)(unsafe.Pointer(libc.PostIncUintptr(&(*J40__bits_st)(unsafe.Pointer(bits)).Ptr, 1)))) << (*J40__bits_st)(unsafe.Pointer(bits)).Nbits
	*(*Int32_t)(unsafe.Pointer(bits)) += 8
	goto __7
__8:
	;
	if !((*J40__bits_st)(unsafe.Pointer(bits)).Nbits > NBITS-8) {
		goto __9
	}
	goto __2
__9:
	;
__10:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __13
	}
	goto J40__ON_ERROR
__13:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32((*J40__st)(unsafe.Pointer(st)).Buffer) != 0)), int64(0)) != 0) {
		goto __14
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 3))))
	goto J40__ON_ERROR
__14:
	;
	goto __11
__11:
	if 0 != 0 {
		goto __10
	}
	goto __12
__12:
	;
__15:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__refill_buffer(tls, st) != 0)), int64(0)) != 0) {
		goto __18
	}
	goto J40__ON_ERROR
__18:
	;
	goto __16
__16:
	if 0 != 0 {
		goto __15
	}
	goto __17
__17:
	;
	if !((*J40__bits_st)(unsafe.Pointer(bits)).End == (*J40__bits_st)(unsafe.Pointer(bits)).Ptr) {
		goto __19
	}
	if !((*J40__bits_st)(unsafe.Pointer(bits)).Nbits >= n) {
		goto __20
	}
	goto __2
__20:
	;
__21:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 3))))
	goto J40__ON_ERROR
	goto __22
__22:
	if 0 != 0 {
		goto __21
	}
	goto __23
__23:
	;
__19:
	;
	goto __1
__2:
	;
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

var NBITS Int32_t = 64

func j40__zero_pad_to_byte(tls *libc.TLS, st uintptr) J40_err {
	var n Int32_t = (*J40__st)(unsafe.Pointer(st)).Bits.Nbits & 7
	if (*J40__st)(unsafe.Pointer(st)).Bits.Bits&Uint64_t(uint32(1)<<n-uint32(1)) != 0 {
		return j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 119))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 119 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 119 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 119 + 3))))
	}
	libc.AssignShrPtrUint64(st+16+8, int(n))
	*(*Int32_t)(unsafe.Pointer(st + 16)) -= n
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__skip(tls *libc.TLS, st uintptr, n Int64_t) J40_err {
	var bits uintptr = st + 16
	var bytes Int64_t
	if Int64_t((*J40__bits_st)(unsafe.Pointer(bits)).Nbits) >= n {
		libc.AssignShrPtrUint64(bits+8, int(Int32_t(n)))
		*(*Int32_t)(unsafe.Pointer(bits)) -= Int32_t(n)
	} else {
		n = n - Int64_t((*J40__bits_st)(unsafe.Pointer(bits)).Nbits)
		(*J40__bits_st)(unsafe.Pointer(bits)).Bits = uint64(0)
		(*J40__bits_st)(unsafe.Pointer(bits)).Nbits = 0
	}
	bytes = n >> 3

	if (int64((*J40__bits_st)(unsafe.Pointer(bits)).End)-int64((*J40__bits_st)(unsafe.Pointer(bits)).Ptr))/1 < bytes {
		return j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 3))))
	}
	*(*uintptr)(unsafe.Pointer(bits + 16)) += uintptr(bytes)
	n = n & int64(7)
	if func() uint32 {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!((*J40__st)(unsafe.Pointer(st)).Bits.Nbits < Int32_t(n))), int64(0)) != 0 {
			return j40__always_refill(tls, st, Int32_t(n))
		}
		return (*J40__st)(unsafe.Pointer(st)).Err
	}() != 0 {
		return (*J40__st)(unsafe.Pointer(st)).Err
	}
	libc.AssignShrPtrUint64(bits+8, int(Int32_t(n)))
	*(*Int32_t)(unsafe.Pointer(bits)) -= Int32_t(n)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__u(tls *libc.TLS, st uintptr, n Int32_t) Int32_t {
	var ret Int32_t

	if func() uint32 {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!((*J40__st)(unsafe.Pointer(st)).Bits.Nbits < n)), int64(0)) != 0 {
			return j40__always_refill(tls, st, n)
		}
		return (*J40__st)(unsafe.Pointer(st)).Err
	}() != 0 {
		return 0
	}
	ret = Int32_t((*J40__st)(unsafe.Pointer(st)).Bits.Bits & Uint64_t(uint32(1)<<n-uint32(1)))
	libc.AssignShrPtrUint64(st+16+8, int(n))
	*(*Int32_t)(unsafe.Pointer(st + 16)) -= n
	return ret
}

func j40__64u(tls *libc.TLS, st uintptr, n Int32_t) Int64_t {
	var ret Int64_t

	if func() uint32 {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!((*J40__st)(unsafe.Pointer(st)).Bits.Nbits < n)), int64(0)) != 0 {
			return j40__always_refill(tls, st, n)
		}
		return (*J40__st)(unsafe.Pointer(st)).Err
	}() != 0 {
		return int64(0)
	}
	ret = Int64_t((*J40__st)(unsafe.Pointer(st)).Bits.Bits & (Uint64_t(uint64(1))<<n - uint64(1)))
	libc.AssignShrPtrUint64(st+16+8, int(n))
	*(*Int32_t)(unsafe.Pointer(st + 16)) -= n
	return ret
}

func j40__u32(tls *libc.TLS, st uintptr, o0 Int32_t, n0 Int32_t, o1 Int32_t, n1 Int32_t, o2 Int32_t, n2 Int32_t, o3 Int32_t, n3 Int32_t) Int32_t {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	*(*[4]Int32_t)(unsafe.Pointer(bp + 16)) = [4]Int32_t{o0, o1, o2, o3}
	*(*[4]Int32_t)(unsafe.Pointer(bp)) = [4]Int32_t{n0, n1, n2, n3}
	var sel Int32_t

	sel = j40__u(tls, st, 2)
	return j40__u(tls, st, *(*Int32_t)(unsafe.Pointer(bp + uintptr(sel)*4))) + *(*Int32_t)(unsafe.Pointer(bp + 16 + uintptr(sel)*4))
}

func j40__64u32(tls *libc.TLS, st uintptr, o0 Int32_t, n0 Int32_t, o1 Int32_t, n1 Int32_t, o2 Int32_t, n2 Int32_t, o3 Int32_t, n3 Int32_t) Int64_t {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	*(*[4]Int32_t)(unsafe.Pointer(bp + 16)) = [4]Int32_t{o0, o1, o2, o3}
	*(*[4]Int32_t)(unsafe.Pointer(bp)) = [4]Int32_t{n0, n1, n2, n3}
	var sel Int32_t

	sel = j40__u(tls, st, 2)
	return (j40__64u(tls, st, *(*Int32_t)(unsafe.Pointer(bp + uintptr(sel)*4))) + Int64_t(*(*Int32_t)(unsafe.Pointer(bp + 16 + uintptr(sel)*4)))) & int64(0xffffffff)
}

func j40__u64(tls *libc.TLS, st uintptr) Uint64_t {
	var sel Int32_t = j40__u(tls, st, 2)
	var shift Int32_t
	var ret Uint64_t = Uint64_t(j40__u(tls, st, sel*4))
	if sel < 3 {
		ret = ret + Uint64_t(uint32(17)>>(8-sel*4))
	} else {
		for shift = 12; shift < 64 && j40__u(tls, st, 1) != 0; shift = shift + 8 {
			ret = ret | Uint64_t(j40__u(tls, st, func() int32 {
				if shift < 56 {
					return 8
				}
				return 64 - shift
			}()))<<shift
		}
	}
	return ret
}

func j40__enum(tls *libc.TLS, st uintptr) Int32_t {
	var ret Int32_t = j40__u32(tls, st, 0, 0, 1, 0, 2, 4, 18, 6)

	if ret >= 31 {
		j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 124))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 124 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 124 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 124 + 3))))
		return 0
	}
	return ret
}

func j40__f16(tls *libc.TLS, st uintptr) float32 {
	var bits Int32_t = j40__u(tls, st, 16)
	var biased_exp Int32_t = bits >> 10 & 0x1f
	if biased_exp == 31 {
		j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 129))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 129 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 129 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 129 + 3))))
		return 0.0
	}
	return func() float32 {
		if bits>>15 != 0 {
			return float32(-1)
		}
		return float32(1)
	}() * ldexpf(tls, float32(bits&0x3ff|func() int32 {
		if biased_exp > 0 {
			return 0x400
		}
		return 0
	}()), biased_exp-25)
}

func j40__u8(tls *libc.TLS, st uintptr) Int32_t {
	if j40__u(tls, st, 1) != 0 {
		var n Int32_t = j40__u(tls, st, 3)
		return j40__u(tls, st, n) + int32(1)<<n
	} else {
		return 0
	}
	return Int32_t(0)
}

// equivalent to u(ceil(log2(max + 1))), decodes [0, max] with the minimal number of bits
func j40__at_most(tls *libc.TLS, st uintptr, max Int32_t) Int32_t {
	var v Int32_t
	if max > 0 {
		v = j40__u(tls, st, J40__ceil_lg32(tls, Uint32_t(max)+Uint32_t(1)))
	} else {
		v = 0
	}
	if v > max {
		j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 134))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 134 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 134 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 134 + 3))))
		return 0
	}
	return v
}

// ensures that we have reached the end of file or advertised section with proper padding
func j40__no_more_bytes(tls *libc.TLS, st uintptr) J40_err {
__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__zero_pad_to_byte(tls, st) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
__5:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __8
	}
	goto J40__ON_ERROR
__8:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__st)(unsafe.Pointer(st)).Bits.Nbits == 0 && (*J40__st)(unsafe.Pointer(st)).Bits.Ptr == (*J40__st)(unsafe.Pointer(st)).Bits.End)), int64(0)) != 0) {
		goto __9
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 139))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 139 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 139 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 139 + 3))))
	goto J40__ON_ERROR
__9:
	;
	goto __6
__6:
	if 0 != 0 {
		goto __5
	}
	goto __7
__7:
	;
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

// read a prefix code tree, as specified in RFC 7932 section 3
func j40__prefix_code_tree(tls *libc.TLS, st uintptr, l2size Int32_t, out_fast_len uintptr, out_max_len uintptr, out_table uintptr) J40_err {
	bp := tls.Alloc(456)
	defer tls.Free(456)

	var l2lengths uintptr

	var l2table uintptr
	var total Int32_t
	var code Int32_t
	var hskip Int32_t
	var fast_len Int32_t
	var i Int32_t
	var j Int32_t
	var nsym Int32_t

	var tmp Int32_t
	var n Int32_t
	var start uintptr
	var prev Int32_t
	var rep Int32_t
	var prev_rep Int32_t

	var size Int32_t
	var size_limit Int32_t
	var size_used Int32_t
	var n1 Int32_t
	var start1 uintptr
	*(*[18]Int32_t)(unsafe.Pointer(bp + 40)) = [18]Int32_t{0: 0}
	l2lengths = uintptr(0)
	*(*[6]Int32_t)(unsafe.Pointer(bp + 16)) = [6]Int32_t{0: 0}
	*(*[16]Int32_t)(unsafe.Pointer(bp + 264)) = [16]Int32_t{0: 0}
	*(*[32]Int32_t)(unsafe.Pointer(bp + 112)) = [32]Int32_t{0: 0}
	l2table = uintptr(0)

	if !(l2size == 1) {
		goto __1
	}
	*(*Int32_t)(unsafe.Pointer(out_fast_len)) = libc.AssignPtrInt32(out_max_len, 0)
__2:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __5
	}
	goto J40__ON_ERROR
__5:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(out_table, j40__malloc(tls, uint64(unsafe.Sizeof(Int32_t(0)))))) != 0)), int64(0)) != 0) {
		goto __6
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__6:
	;
	goto __3
__3:
	if 0 != 0 {
		goto __2
	}
	goto __4
__4:
	;
	*(*Int32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(out_table)))) = 0
	return J40_err(0)
__1:
	;
	hskip = j40__u(tls, st, 2)
	if !(hskip == 1) {
		goto __7
	}
	nsym = j40__u(tls, st, 2) + 1
	i = 0
__8:
	if !(i < nsym) {
		goto __10
	}
	*(*Int32_t)(unsafe.Pointer(bp + uintptr(i)*4)) = j40__at_most(tls, st, l2size-1)
	j = 0
__11:
	if !(j < i) {
		goto __13
	}
__14:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __17
	}
	goto J40__ON_ERROR
__17:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(*(*Int32_t)(unsafe.Pointer(bp + uintptr(i)*4)) != *(*Int32_t)(unsafe.Pointer(bp + uintptr(j)*4)))), int64(0)) != 0) {
		goto __18
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 144))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 144 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 144 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 144 + 3))))
	goto J40__ON_ERROR
__18:
	;
	goto __15
__15:
	if 0 != 0 {
		goto __14
	}
	goto __16
__16:
	;
	goto __12
__12:
	j++
	goto __11
	goto __13
__13:
	;
	goto __9
__9:
	i++
	goto __8
	goto __10
__10:
	;
	if !(nsym == 4 && j40__u(tls, st, 1) != 0) {
		goto __19
	}
	nsym = 0
__19:
	;
__20:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __23
	}
	goto J40__ON_ERROR
__23:
	;
	goto __21
__21:
	if 0 != 0 {
		goto __20
	}
	goto __22
__22:
	;
	i = int32(TEMPLATES[nsym].Sortfrom) + 1
__24:
	if !(i < Int32_t(TEMPLATES[nsym].Sortto)) {
		goto __26
	}
	j = i
__27:
	if !(j > Int32_t(TEMPLATES[nsym].Sortfrom) && *(*Int32_t)(unsafe.Pointer(bp + uintptr(j-1)*4)) > *(*Int32_t)(unsafe.Pointer(bp + uintptr(j)*4))) {
		goto __29
	}
	tmp = *(*Int32_t)(unsafe.Pointer(bp + uintptr(j-1)*4))
	*(*Int32_t)(unsafe.Pointer(bp + uintptr(j-1)*4)) = *(*Int32_t)(unsafe.Pointer(bp + uintptr(j)*4))
	*(*Int32_t)(unsafe.Pointer(bp + uintptr(j)*4)) = tmp
	goto __28
__28:
	j--
	goto __27
	goto __29
__29:
	;
	goto __25
__25:
	i++
	goto __24
	goto __26
__26:
	;
	*(*Int32_t)(unsafe.Pointer(out_fast_len)) = libc.AssignPtrInt32(out_max_len, Int32_t(TEMPLATES[nsym].Maxlen))
__30:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __33
	}
	goto J40__ON_ERROR
__33:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(out_table, j40__malloc(tls, uint64(uint64(unsafe.Sizeof(Int32_t(0))))<<*(*Int32_t)(unsafe.Pointer(out_max_len))))) != 0)), int64(0)) != 0) {
		goto __34
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__34:
	;
	goto __31
__31:
	if 0 != 0 {
		goto __30
	}
	goto __32
__32:
	;
	i = 0
__35:
	if !(i < int32(1)<<*(*Int32_t)(unsafe.Pointer(out_max_len))) {
		goto __37
	}
	*(*Int32_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(out_table)) + uintptr(i)*4)) = *(*Int32_t)(unsafe.Pointer(bp + uintptr(*(*Int8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&TEMPLATES)) + uintptr(nsym)*19 + 11 + uintptr(i))))*4))<<16 | Int32_t(*(*Int8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&TEMPLATES)) + uintptr(nsym)*19 + 3 + uintptr(i))))
	goto __36
__36:
	i++
	goto __35
	goto __37
__37:
	;
	return J40_err(0)
__7:
	;
	total = 0
	i = libc.AssignPtrInt32(bp+16, hskip)
__38:
	if !(i < 18 && total < 32) {
		goto __40
	}
	*(*Int32_t)(unsafe.Pointer(bp + 40 + uintptr(L1ZIGZAG[i])*4)) = libc.AssignInt32(&code, j40__prefix_code(tls, st, 4, 4, uintptr(unsafe.Pointer(&L0TABLE))))
	*(*Int32_t)(unsafe.Pointer(bp + 16 + uintptr(code)*4))++
	if !(code != 0) {
		goto __41
	}
	total = total + int32(32)>>code
__41:
	;
	goto __39
__39:
	i++
	goto __38
	goto __40
__40:
	;
__42:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __45
	}
	goto J40__ON_ERROR
__45:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(total == 32 && *(*Int32_t)(unsafe.Pointer(bp + 16)) != i)), int64(0)) != 0) {
		goto __46
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 144))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 144 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 144 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 144 + 3))))
	goto J40__ON_ERROR
__46:
	;
	goto __43
__43:
	if 0 != 0 {
		goto __42
	}
	goto __44
__44:
	;
	if !(*(*Int32_t)(unsafe.Pointer(bp + 16)) == i-1) {
		goto __47
	}
	i = 0
__49:
	if !(*(*Int32_t)(unsafe.Pointer(bp + 40 + uintptr(i)*4)) != 0) {
		goto __51
	}
	goto __50
__50:
	i++
	goto __49
	goto __51
__51:
	;
	code = 0
__52:
	if !(code < 32) {
		goto __54
	}
	*(*Int32_t)(unsafe.Pointer(bp + 112 + uintptr(code)*4)) = i
	goto __53
__53:
	code++
	goto __52
	goto __54
__54:
	;
	*(*Int32_t)(unsafe.Pointer(bp + 40 + uintptr(i)*4)) = 0
	goto __48
__47:
	*(*Int32_t)(unsafe.Pointer(bp + 240 + 1*4)) = 0
	i = 2
__55:
	if !(i <= 5) {
		goto __57
	}
	*(*Int32_t)(unsafe.Pointer(bp + 240 + uintptr(i)*4)) = *(*Int32_t)(unsafe.Pointer(bp + 240 + uintptr(i-1)*4)) + *(*Int32_t)(unsafe.Pointer(bp + 16 + uintptr(i-1)*4))<<(5-(i-1))
	goto __56
__56:
	i++
	goto __55
	goto __57
__57:
	;
	i = 0
__58:
	if !(i < 18) {
		goto __60
	}
	n = *(*Int32_t)(unsafe.Pointer(bp + 40 + uintptr(i)*4))
	start = bp + 240 + uintptr(n)*4
	if !(n == 0) {
		goto __61
	}
	goto __59
__61:
	;
	code = Int32_t(REV5[*(*Int32_t)(unsafe.Pointer(start))])
__62:
	if !(code < 32) {
		goto __64
	}
	*(*Int32_t)(unsafe.Pointer(bp + 112 + uintptr(code)*4)) = i<<16 | n
	goto __63
__63:
	code = code + int32(1)<<n
	goto __62
	goto __64
__64:
	;
	*(*Int32_t)(unsafe.Pointer(start)) += int32(32) >> n
	goto __59
__59:
	i++
	goto __58
	goto __60
__60:
	;
__48:
	;
	prev = 8
	prev_rep = 0
__65:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __68
	}
	goto J40__ON_ERROR
__68:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignUintptr(&l2lengths, j40__calloc(tls, Size_t(l2size), uint64(unsafe.Sizeof(Int32_t(0)))))) != 0)), int64(0)) != 0) {
		goto __69
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__69:
	;
	goto __66
__66:
	if 0 != 0 {
		goto __65
	}
	goto __67
__67:
	;
	i = libc.AssignInt32(&total, 0)
__70:
	if !(i < l2size && total < 32768) {
		goto __72
	}
	code = j40__prefix_code(tls, st, 5, 5, bp+112)
	if !(code < 16) {
		goto __73
	}
	*(*Int32_t)(unsafe.Pointer(l2lengths + uintptr(libc.PostIncInt32(&i, 1))*4)) = code
	*(*Int32_t)(unsafe.Pointer(bp + 264 + uintptr(code)*4))++
	if !(code != 0) {
		goto __75
	}
	total = total + int32(32768)>>code
	prev = code
__75:
	;
	prev_rep = 0
	goto __74
__73:
	if !(code == 16) {
		goto __76
	}

	if !(prev_rep < 0) {
		goto __78
	}
	prev_rep = 0
__78:
	;
	rep = func() int32 {
		if prev_rep > 0 {
			return 4*prev_rep - 5
		}
		return 3
	}() + j40__u(tls, st, 2)
__79:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __82
	}
	goto J40__ON_ERROR
__82:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(i+(rep-prev_rep) <= l2size)), int64(0)) != 0) {
		goto __83
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 144))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 144 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 144 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 144 + 3))))
	goto J40__ON_ERROR
__83:
	;
	goto __80
__80:
	if 0 != 0 {
		goto __79
	}
	goto __81
__81:
	;
	total = total + 32768*(rep-prev_rep)>>prev
	*(*Int32_t)(unsafe.Pointer(bp + 264 + uintptr(prev)*4)) += rep - prev_rep
__84:
	if !(prev_rep < rep) {
		goto __86
	}
	*(*Int32_t)(unsafe.Pointer(l2lengths + uintptr(libc.PostIncInt32(&i, 1))*4)) = prev
	goto __85
__85:
	prev_rep++
	goto __84
	goto __86
__86:
	;
	goto __77
__76:
	if !(prev_rep > 0) {
		goto __87
	}
	prev_rep = 0
__87:
	;
	rep = func() int32 {
		if prev_rep < 0 {
			return 8*prev_rep + 13
		}
		return -3
	}() - j40__u(tls, st, 3)
__88:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __91
	}
	goto J40__ON_ERROR
__91:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(i+(prev_rep-rep) <= l2size)), int64(0)) != 0) {
		goto __92
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 144))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 144 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 144 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 144 + 3))))
	goto J40__ON_ERROR
__92:
	;
	goto __89
__89:
	if 0 != 0 {
		goto __88
	}
	goto __90
__90:
	;
__93:
	if !(prev_rep > rep) {
		goto __95
	}
	*(*Int32_t)(unsafe.Pointer(l2lengths + uintptr(libc.PostIncInt32(&i, 1))*4)) = 0
	goto __94
__94:
	prev_rep--
	goto __93
	goto __95
__95:
	;
__77:
	;
__74:
	;
__96:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __99
	}
	goto J40__ON_ERROR
__99:
	;
	goto __97
__97:
	if 0 != 0 {
		goto __96
	}
	goto __98
__98:
	;
	goto __71
__71:
	;
	goto __70
	goto __72
__72:
	;
__100:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __103
	}
	goto J40__ON_ERROR
__103:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(total == 32768)), int64(0)) != 0) {
		goto __104
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 144))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 144 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 144 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 144 + 3))))
	goto J40__ON_ERROR
__104:
	;
	goto __101
__101:
	if 0 != 0 {
		goto __100
	}
	goto __102
__102:
	;
	*(*Int32_t)(unsafe.Pointer(bp + 328 + 1*4)) = 0
	*(*Int32_t)(unsafe.Pointer(out_max_len)) = 1
	i = 2
__105:
	if !(i <= 15) {
		goto __107
	}
	*(*Int32_t)(unsafe.Pointer(bp + 328 + uintptr(i)*4)) = *(*Int32_t)(unsafe.Pointer(bp + 328 + uintptr(i-1)*4)) + *(*Int32_t)(unsafe.Pointer(bp + 264 + uintptr(i-1)*4))<<(15-(i-1))
	if !(*(*Int32_t)(unsafe.Pointer(bp + 264 + uintptr(i)*4)) != 0) {
		goto __108
	}
	*(*Int32_t)(unsafe.Pointer(out_max_len)) = i
__108:
	;
	goto __106
__106:
	i++
	goto __105
	goto __107
__107:
	;
	if !(*(*Int32_t)(unsafe.Pointer(out_max_len)) <= J40__MAX_TYPICAL_FAST_LEN) {
		goto __109
	}
	fast_len = *(*Int32_t)(unsafe.Pointer(out_max_len))
__111:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __114
	}
	goto J40__ON_ERROR
__114:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignUintptr(&l2table, j40__malloc(tls, uint64(uint64(unsafe.Sizeof(Int32_t(0))))<<fast_len))) != 0)), int64(0)) != 0) {
		goto __115
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__115:
	;
	goto __112
__112:
	if 0 != 0 {
		goto __111
	}
	goto __113
__113:
	;
	goto __110
__109:
	fast_len = J40__MAX_TYPICAL_FAST_LEN
	size = int32(1) << fast_len
	i = fast_len + 1
__116:
	if !(i <= *(*Int32_t)(unsafe.Pointer(out_max_len))) {
		goto __118
	}
	size = size + *(*Int32_t)(unsafe.Pointer(bp + 264 + uintptr(i)*4))
	goto __117
__117:
	i++
	goto __116
	goto __118
__118:
	;
	size_used = size
	size_limit = size * J40__MAX_TABLE_GROWTH
	i = fast_len + 1
__119:
	if !(i <= *(*Int32_t)(unsafe.Pointer(out_max_len))) {
		goto __121
	}
	size = size + int32(1)<<i - *(*Int32_t)(unsafe.Pointer(bp + 264 + uintptr(i)*4))
	if !(size <= size_limit) {
		goto __122
	}
	size_used = size
	fast_len = i
__122:
	;
	goto __120
__120:
	i++
	goto __119
	goto __121
__121:
	;
	*(*Int32_t)(unsafe.Pointer(bp + 392 + uintptr(fast_len+1)*4)) = int32(1) << fast_len
	i = fast_len + 2
__123:
	if !(i <= *(*Int32_t)(unsafe.Pointer(out_max_len))) {
		goto __125
	}
	*(*Int32_t)(unsafe.Pointer(bp + 392 + uintptr(i)*4)) = *(*Int32_t)(unsafe.Pointer(bp + 392 + uintptr(i-1)*4)) + *(*Int32_t)(unsafe.Pointer(bp + 264 + uintptr(i-1)*4))
	goto __124
__124:
	i++
	goto __123
	goto __125
__125:
	;
__126:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __129
	}
	goto J40__ON_ERROR
__129:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignUintptr(&l2table, j40__malloc(tls, uint64(unsafe.Sizeof(Int32_t(0)))*Size_t(size_used+1)))) != 0)), int64(0)) != 0) {
		goto __130
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__130:
	;
	goto __127
__127:
	if 0 != 0 {
		goto __126
	}
	goto __128
__128:
	;
	*(*Int32_t)(unsafe.Pointer(l2table + uintptr(size_used)*4)) = 0
__110:
	;
	i = 0
__131:
	if !(i < l2size) {
		goto __133
	}
	n1 = *(*Int32_t)(unsafe.Pointer(l2lengths + uintptr(i)*4))
	start1 = bp + 328 + uintptr(n1)*4
	if !(n1 == 0) {
		goto __134
	}
	goto __132
__134:
	;
	code = Int32_t(REV5[*(*Int32_t)(unsafe.Pointer(start1))&31])<<10 | Int32_t(REV5[*(*Int32_t)(unsafe.Pointer(start1))>>5&31])<<5 | Int32_t(REV5[*(*Int32_t)(unsafe.Pointer(start1))>>10])
	if !(n1 <= fast_len) {
		goto __135
	}
__137:
	if !(code < int32(1)<<fast_len) {
		goto __139
	}
	*(*Int32_t)(unsafe.Pointer(l2table + uintptr(code)*4)) = i<<16 | n1
	goto __138
__138:
	code = code + int32(1)<<n1
	goto __137
	goto __139
__139:
	;
	*(*Int32_t)(unsafe.Pointer(start1)) += int32(32768) >> n1
	goto __136
__135:
	if !(code>>fast_len == 0) {
		goto __140
	}
	*(*Int32_t)(unsafe.Pointer(l2table + uintptr(code)*4)) = -*(*Int32_t)(unsafe.Pointer(bp + 392 + uintptr(n1)*4))
__140:
	;
	*(*Int32_t)(unsafe.Pointer(start1)) += int32(32768) >> n1
	*(*Int32_t)(unsafe.Pointer(l2table + uintptr(libc.PostIncInt32(&*(*Int32_t)(unsafe.Pointer(bp + 392 + uintptr(n1)*4)), 1))*4)) = i<<16 | code>>fast_len<<4 | (n1 - fast_len)
__136:
	;
	goto __132
__132:
	i++
	goto __131
	goto __133
__133:
	;
	*(*Int32_t)(unsafe.Pointer(out_fast_len)) = fast_len
	*(*uintptr)(unsafe.Pointer(out_table)) = l2table
	j40__free(tls, l2lengths)
	return J40_err(0)

J40__ON_ERROR:
	j40__free(tls, l2lengths)
	j40__free(tls, l2table)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

var REV5 = [32]Uint8_t{
	Uint8_t(0), Uint8_t(16), Uint8_t(8), Uint8_t(24), Uint8_t(4), Uint8_t(20), Uint8_t(12), Uint8_t(28), Uint8_t(2), Uint8_t(18), Uint8_t(10), Uint8_t(26), Uint8_t(6), Uint8_t(22), Uint8_t(14), Uint8_t(30),
	Uint8_t(1), Uint8_t(17), Uint8_t(9), Uint8_t(25), Uint8_t(5), Uint8_t(21), Uint8_t(13), Uint8_t(29), Uint8_t(3), Uint8_t(19), Uint8_t(11), Uint8_t(27), Uint8_t(7), Uint8_t(23), Uint8_t(15), Uint8_t(31),
}
var L0TABLE = [16]Int32_t{
	0x00002, 0x40002, 0x30002, 0x20003, 0x00002, 0x40002, 0x30002, 0x10004,
	0x00002, 0x40002, 0x30002, 0x20003, 0x00002, 0x40002, 0x30002, 0x50004,
}
var L1ZIGZAG = [18]Uint8_t{Uint8_t(1), Uint8_t(2), Uint8_t(3), Uint8_t(4), Uint8_t(0), Uint8_t(5), Uint8_t(17), Uint8_t(6), Uint8_t(16), Uint8_t(7), Uint8_t(8), Uint8_t(9), Uint8_t(10), Uint8_t(11), Uint8_t(12), Uint8_t(13), Uint8_t(14), Uint8_t(15)}
var TEMPLATES = [5]struct {
	Maxlen   Int8_t
	Sortfrom Int8_t
	Sortto   Int8_t
	Len      [8]Int8_t
	Symref   [8]Int8_t
}{
	{Maxlen: int8(3), Sortfrom: int8(2), Sortto: int8(4), Len: [8]Int8_t{int8(1), int8(2), int8(1), int8(3), int8(1), int8(2), int8(1), int8(3)}, Symref: [8]Int8_t{int8(0), int8(1), int8(0), int8(2), int8(0), int8(1), int8(0), int8(3)}},
	{},
	{Maxlen: int8(1), Sortto: int8(2), Len: [8]Int8_t{0: int8(1), 1: int8(1)}, Symref: [8]Int8_t{0: int8(0), 1: int8(1)}},
	{Maxlen: int8(2), Sortfrom: int8(1), Sortto: int8(3), Len: [8]Int8_t{0: int8(1), 1: int8(2), 2: int8(1), 3: int8(2)}, Symref: [8]Int8_t{0: int8(0), 1: int8(1), 2: int8(0), 3: int8(2)}},
	{Maxlen: int8(2), Sortto: int8(4), Len: [8]Int8_t{0: int8(2), 1: int8(2), 2: int8(2), 3: int8(2)}, Symref: [8]Int8_t{0: int8(0), 1: int8(1), 2: int8(2), 3: int8(3)}}}

func j40__match_overflow(tls *libc.TLS, st uintptr, fast_len Int32_t, table uintptr) Int32_t {
	var entry Int32_t
	var code Int32_t
	var code_len Int32_t
	*(*Int32_t)(unsafe.Pointer(st + 16)) -= fast_len
	libc.AssignShrPtrUint64(st+16+8, int(fast_len))
	for __ccgo := true; __ccgo; __ccgo = code != Int32_t((*J40__st)(unsafe.Pointer(st)).Bits.Bits&Uint64_t(uint32(1)<<code_len-uint32(1))) {
		entry = *(*Int32_t)(unsafe.Pointer(libc.PostIncUintptr(&table, 4)))
		code = entry >> 4 & 0xfff
		code_len = entry & 15
	}
	return entry
}

func j40__prefix_code(tls *libc.TLS, st uintptr, fast_len Int32_t, max_len Int32_t, table uintptr) Int32_t {
	var entry Int32_t
	var code_len Int32_t

	if (*J40__st)(unsafe.Pointer(st)).Bits.Nbits < max_len && j40__always_refill(tls, st, 0) != 0 {
		return 0
	}
	entry = *(*Int32_t)(unsafe.Pointer(table + uintptr((*J40__st)(unsafe.Pointer(st)).Bits.Bits&Uint64_t(uint32(1)<<fast_len-uint32(1)))*4))
	if entry < 0 && fast_len < max_len {
		entry = j40__match_overflow(tls, st, fast_len, table-uintptr(entry)*4)
	}
	code_len = entry & 15
	*(*Int32_t)(unsafe.Pointer(st + 16)) -= code_len
	libc.AssignShrPtrUint64(st+16+8, int(code_len))
	if (*J40__st)(unsafe.Pointer(st)).Bits.Nbits < 0 {
		(*J40__st)(unsafe.Pointer(st)).Bits.Nbits = 0

		j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 3))))
	}
	return entry >> 16
}

// token < 2^split_exp is interpreted as is.
// otherwise (token - 2^split_exp) is split into NNHHHLLL where config determines H/L lengths.
// then MMMMM = u(NN + split_exp - H/L lengths) is read; the decoded value is 1HHHMMMMMLLL.
type J40__hybrid_int_config = struct {
	Split_exp    Int8_t
	Msb_in_token Int8_t
	Lsb_in_token Int8_t
	__ccgo_pad1  [1]byte
	Max_token    Int32_t
}

func j40__read_hybrid_int_config(tls *libc.TLS, st uintptr, log_alpha_size Int32_t, out uintptr) J40_err {
	(*J40__hybrid_int_config)(unsafe.Pointer(out)).Split_exp = Int8_t(j40__at_most(tls, st, log_alpha_size))
	if int32((*J40__hybrid_int_config)(unsafe.Pointer(out)).Split_exp) != log_alpha_size {
		(*J40__hybrid_int_config)(unsafe.Pointer(out)).Msb_in_token = Int8_t(j40__at_most(tls, st, int32((*J40__hybrid_int_config)(unsafe.Pointer(out)).Split_exp)))
		(*J40__hybrid_int_config)(unsafe.Pointer(out)).Lsb_in_token = Int8_t(j40__at_most(tls, st, int32((*J40__hybrid_int_config)(unsafe.Pointer(out)).Split_exp)-int32((*J40__hybrid_int_config)(unsafe.Pointer(out)).Msb_in_token)))
	} else {
		(*J40__hybrid_int_config)(unsafe.Pointer(out)).Msb_in_token = libc.AssignPtrInt8(out+2, int8(0))
	}
	(*J40__hybrid_int_config)(unsafe.Pointer(out)).Max_token = int32(1)<<int32((*J40__hybrid_int_config)(unsafe.Pointer(out)).Split_exp) + (30-int32((*J40__hybrid_int_config)(unsafe.Pointer(out)).Split_exp))<<(int32((*J40__hybrid_int_config)(unsafe.Pointer(out)).Lsb_in_token)+int32((*J40__hybrid_int_config)(unsafe.Pointer(out)).Msb_in_token)) - 1
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__hybrid_int(tls *libc.TLS, st uintptr, token Int32_t, config J40__hybrid_int_config) Int32_t {
	var midbits Int32_t
	var lo Int32_t
	var mid Int32_t
	var hi Int32_t
	var top Int32_t
	var bits_in_token Int32_t
	var split Int32_t = int32(1) << int32(config.Split_exp)
	if token < split {
		return token
	}
	if token > config.Max_token {
		token = config.Max_token
		j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 149))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 149 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 149 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 149 + 3))))
	}
	bits_in_token = int32(config.Msb_in_token) + int32(config.Lsb_in_token)
	midbits = int32(config.Split_exp) - bits_in_token + (token-split)>>bits_in_token
	mid = j40__u(tls, st, midbits)
	top = int32(1) << int32(config.Msb_in_token)
	lo = token & (int32(1)<<int32(config.Lsb_in_token) - 1)
	hi = token >> int32(config.Lsb_in_token) & (top - 1)
	return (top|hi)<<(midbits+Int32_t(config.Lsb_in_token)) | (mid<<int32(config.Lsb_in_token) | lo)
}

// the alias table of size N is conceptually an array of N buckets with probability 1/N each,
// where each bucket corresponds to at most two symbols distinguished by the cutoff point.
// this is done by rearranging symbols so that every symbol boundary falls into distinct buckets.
// so it allows *any* distribution of N symbols to be decoded in a constant time after the setup.
// the table is not unique though, so the spec needs to specify the exact construction algorithm.
//
//	input range: 0         cutoff               bucket_size
//	             +-----------|----------------------------+
//
// output symbol: |     i     |           symbol           | <- bucket i
//
//	              +-----------|----------------------------+
//	output range: 0     cutoff|offset    offset+bucket_size
type J40__alias_bucket = struct {
	Cutoff         Int16_t
	Offset_or_next Int16_t
	Symbol         Int16_t
}

func j40__init_alias_map(tls *libc.TLS, st uintptr, D uintptr, log_alpha_size Int32_t, out uintptr) J40_err {
	var log_bucket_size Int16_t
	var bucket_size Int16_t
	var table_size Int16_t
	var buckets uintptr

	var u Int16_t
	var o Int16_t
	var i Int16_t
	var j Int16_t
	var cutoff Int16_t
	var by Int16_t
	var tmp Int16_t
	log_bucket_size = Int16_t(J40__DIST_BITS - log_alpha_size)
	bucket_size = Int16_t(int32(1) << int32(log_bucket_size))
	table_size = Int16_t(int32(1) << log_alpha_size)
	buckets = uintptr(0)
	u = int16(-1)
	o = int16(-1)

__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignUintptr(&buckets, j40__malloc(tls, uint64(uint64(unsafe.Sizeof(J40__alias_bucket{})))<<log_alpha_size))) != 0)), int64(0)) != 0) {
		goto __5
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__5:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
	i = int16(0)
__6:
	if !(int32(i) < int32(table_size) && !(int32(*(*Int16_t)(unsafe.Pointer(D + uintptr(i)*2))) != 0)) {
		goto __8
	}
	goto __7
__7:
	i++
	goto __6
	goto __8
__8:
	;
	j = Int16_t(int32(i) + 1)
__9:
	if !(int32(j) < int32(table_size) && !(int32(*(*Int16_t)(unsafe.Pointer(D + uintptr(j)*2))) != 0)) {
		goto __11
	}
	goto __10
__10:
	j++
	goto __9
	goto __11
__11:
	;
	if !(int32(i) < int32(table_size) && int32(j) >= int32(table_size)) {
		goto __12
	}
	j = int16(0)
__13:
	if !(int32(j) < int32(table_size)) {
		goto __15
	}
	(*J40__alias_bucket)(unsafe.Pointer(buckets + uintptr(j)*6)).Symbol = i
	(*J40__alias_bucket)(unsafe.Pointer(buckets + uintptr(j)*6)).Offset_or_next = Int16_t(int32(j) << int32(log_bucket_size))
	(*J40__alias_bucket)(unsafe.Pointer(buckets + uintptr(j)*6)).Cutoff = int16(0)
	goto __14
__14:
	j++
	goto __13
	goto __15
__15:
	;
	*(*uintptr)(unsafe.Pointer(out)) = buckets
	return J40_err(0)
__12:
	;
	i = int16(0)
__16:
	if !(int32(i) < int32(table_size)) {
		goto __18
	}
	cutoff = *(*Int16_t)(unsafe.Pointer(D + uintptr(i)*2))
	(*J40__alias_bucket)(unsafe.Pointer(buckets + uintptr(i)*6)).Cutoff = cutoff
	if !(int32(cutoff) > int32(bucket_size)) {
		goto __19
	}
	(*J40__alias_bucket)(unsafe.Pointer(buckets + uintptr(i)*6)).Offset_or_next = o
	o = i
	goto __20
__19:
	if !(int32(cutoff) < int32(bucket_size)) {
		goto __21
	}
	(*J40__alias_bucket)(unsafe.Pointer(buckets + uintptr(i)*6)).Offset_or_next = u
	u = i
	goto __22
__21:
	(*J40__alias_bucket)(unsafe.Pointer(buckets + uintptr(i)*6)).Symbol = i
	(*J40__alias_bucket)(unsafe.Pointer(buckets + uintptr(i)*6)).Offset_or_next = int16(0)
__22:
	;
__20:
	;
	goto __17
__17:
	i++
	goto __16
	goto __18
__18:
	;
__23:
	if !(int32(o) >= 0) {
		goto __24
	}

	by = Int16_t(int32(bucket_size) - int32((*J40__alias_bucket)(unsafe.Pointer(buckets+uintptr(u)*6)).Cutoff))

	tmp = (*J40__alias_bucket)(unsafe.Pointer(buckets + uintptr(u)*6)).Offset_or_next
	(*J40__alias_bucket)(unsafe.Pointer(buckets + uintptr(o)*6)).Cutoff = Int16_t(int32((*J40__alias_bucket)(unsafe.Pointer(buckets+uintptr(o)*6)).Cutoff) - int32(by))
	(*J40__alias_bucket)(unsafe.Pointer(buckets + uintptr(u)*6)).Symbol = o
	(*J40__alias_bucket)(unsafe.Pointer(buckets + uintptr(u)*6)).Offset_or_next = Int16_t(int32((*J40__alias_bucket)(unsafe.Pointer(buckets+uintptr(o)*6)).Cutoff) - int32((*J40__alias_bucket)(unsafe.Pointer(buckets+uintptr(u)*6)).Cutoff))
	u = tmp
	if !(int32((*J40__alias_bucket)(unsafe.Pointer(buckets+uintptr(o)*6)).Cutoff) < int32(bucket_size)) {
		goto __25
	}
	tmp = (*J40__alias_bucket)(unsafe.Pointer(buckets + uintptr(o)*6)).Offset_or_next
	(*J40__alias_bucket)(unsafe.Pointer(buckets + uintptr(o)*6)).Offset_or_next = u
	u = o
	o = tmp
	goto __26
__25:
	if !(int32((*J40__alias_bucket)(unsafe.Pointer(buckets+uintptr(o)*6)).Cutoff) == int32(bucket_size)) {
		goto __27
	}
	tmp = (*J40__alias_bucket)(unsafe.Pointer(buckets + uintptr(o)*6)).Offset_or_next
	(*J40__alias_bucket)(unsafe.Pointer(buckets + uintptr(o)*6)).Offset_or_next = int16(0)
	o = tmp
__27:
	;
__26:
	;
	goto __23
__24:
	;
	*(*uintptr)(unsafe.Pointer(out)) = buckets
	return J40_err(0)

J40__ON_ERROR:
	j40__free(tls, buckets)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__ans_code(tls *libc.TLS, st uintptr, state uintptr, log_bucket_size Int32_t, D uintptr, aliases uintptr) Int32_t {
	if *(*Uint32_t)(unsafe.Pointer(state)) == Uint32_t(0) {
		*(*Uint32_t)(unsafe.Pointer(state)) = Uint32_t(j40__u(tls, st, 16))
		*(*Uint32_t)(unsafe.Pointer(state)) |= Uint32_t(j40__u(tls, st, 16)) << 16
	}
	{
		var index Int32_t = Int32_t(*(*Uint32_t)(unsafe.Pointer(state)) & Uint32_t(0xfff))
		var i Int32_t = index >> log_bucket_size
		var pos Int32_t = index & (int32(1)<<log_bucket_size - 1)
		var bucket uintptr = aliases + uintptr(i)*6
		var symbol Int32_t
		if pos < Int32_t((*J40__alias_bucket)(unsafe.Pointer(bucket)).Cutoff) {
			symbol = i
		} else {
			symbol = int32((*J40__alias_bucket)(unsafe.Pointer(bucket)).Symbol)
		}
		var offset Int32_t
		if pos < Int32_t((*J40__alias_bucket)(unsafe.Pointer(bucket)).Cutoff) {
			offset = 0
		} else {
			offset = int32((*J40__alias_bucket)(unsafe.Pointer(bucket)).Offset_or_next)
		}

		*(*Uint32_t)(unsafe.Pointer(state)) = Uint32_t(*(*Int16_t)(unsafe.Pointer(D + uintptr(symbol)*2)))*(*(*Uint32_t)(unsafe.Pointer(state))>>12) + Uint32_t(offset) + Uint32_t(pos)
		if *(*Uint32_t)(unsafe.Pointer(state)) < uint32(1)<<16 {
			*(*Uint32_t)(unsafe.Pointer(state)) = *(*Uint32_t)(unsafe.Pointer(state))<<16 | Uint32_t(j40__u(tls, st, 16))
		}
		return symbol

	}
	return Int32_t(0)
}

type J40__code_cluster = struct {
	__ccgo_pad1 [0]uint64
	Config      J40__hybrid_int_config
	__ccgo_pad2 [16]byte
}

type J40__code_spec = struct {
	Num_dist        Int32_t
	Lz77_enabled    int32
	Use_prefix_code int32
	Min_symbol      Int32_t
	Min_length      Int32_t
	Log_alpha_size  Int32_t
	Num_clusters    Int32_t
	__ccgo_pad1     [4]byte
	Cluster_map     uintptr
	Lz_len_config   J40__hybrid_int_config
	Clusters        uintptr
}

type J40__code_st = struct {
	Spec        uintptr
	Num_to_copy Int32_t
	Copy_pos    Int32_t
	Num_decoded Int32_t
	Window_cap  Int32_t
	Window      uintptr
	Ans_state   Uint32_t
	__ccgo_pad1 [4]byte
}

func j40__cluster_map(tls *libc.TLS, st uintptr, num_dist Int32_t, max_allowed Int32_t, num_clusters uintptr, map1 uintptr) J40_err {
	bp := tls.Alloc(384)
	defer tls.Free(384)

	var i Int32_t
	var j Int32_t
	var nbits Int32_t
	var index Int32_t

	var moved Uint8_t
	var use_mtf int32
	*(*J40__code_spec)(unsafe.Pointer(bp)) = J40__code_spec{}
	*(*J40__code_st)(unsafe.Pointer(bp + 56)) = J40__code_st{Spec: bp}
	*(*[8]Uint32_t)(unsafe.Pointer(bp + 352)) = [8]Uint32_t{0: Uint32_t(0)}

	if !(max_allowed > num_dist) {
		goto __1
	}
	max_allowed = num_dist
__1:
	;
	if !(num_dist == 1) {
		goto __2
	}
	*(*Int32_t)(unsafe.Pointer(num_clusters)) = 1
	*(*Uint8_t)(unsafe.Pointer(map1)) = Uint8_t(0)
	return J40_err(0)
__2:
	;
	if !(j40__u(tls, st, 1) != 0) {
		goto __3
	}
	nbits = j40__u(tls, st, 2)
	i = 0
__5:
	if !(i < num_dist) {
		goto __7
	}
	*(*Uint8_t)(unsafe.Pointer(map1 + uintptr(i))) = Uint8_t(j40__u(tls, st, nbits))
__8:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __11
	}
	goto J40__ON_ERROR
__11:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Int32_t(*(*Uint8_t)(unsafe.Pointer(map1 + uintptr(i)))) < max_allowed)), int64(0)) != 0) {
		goto __12
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 154))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 154 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 154 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 154 + 3))))
	goto J40__ON_ERROR
__12:
	;
	goto __9
__9:
	if 0 != 0 {
		goto __8
	}
	goto __10
__10:
	;
	goto __6
__6:
	i++
	goto __5
	goto __7
__7:
	;
	goto __4
__3:
	use_mtf = j40__u(tls, st, 1)

__13:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__read_code_spec(tls, st, 1, bp) != 0)), int64(0)) != 0) {
		goto __16
	}
	goto J40__ON_ERROR
__16:
	;
	goto __14
__14:
	if 0 != 0 {
		goto __13
	}
	goto __15
__15:
	;
	i = 0
__17:
	if !(i < num_dist) {
		goto __19
	}
	index = j40__code(tls, st, 0, 0, bp+56)
__20:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __23
	}
	goto J40__ON_ERROR
__23:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(index < max_allowed)), int64(0)) != 0) {
		goto __24
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 154))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 154 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 154 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 154 + 3))))
	goto J40__ON_ERROR
__24:
	;
	goto __21
__21:
	if 0 != 0 {
		goto __20
	}
	goto __22
__22:
	;
	*(*Uint8_t)(unsafe.Pointer(map1 + uintptr(i))) = Uint8_t(index)
	goto __18
__18:
	i++
	goto __17
	goto __19
__19:
	;
__25:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__finish_and_free_code(tls, st, bp+56) != 0)), int64(0)) != 0) {
		goto __28
	}
	goto J40__ON_ERROR
__28:
	;
	goto __26
__26:
	if 0 != 0 {
		goto __25
	}
	goto __27
__27:
	;
	j40__free_code_spec(tls, bp)

	if !(use_mtf != 0) {
		goto __29
	}
	i = 0
__30:
	if !(i < 256) {
		goto __32
	}
	*(*Uint8_t)(unsafe.Pointer(bp + 96 + uintptr(i))) = Uint8_t(i)
	goto __31
__31:
	i++
	goto __30
	goto __32
__32:
	;
	i = 0
__33:
	if !(i < num_dist) {
		goto __35
	}
	j = Int32_t(*(*Uint8_t)(unsafe.Pointer(map1 + uintptr(i))))
	*(*Uint8_t)(unsafe.Pointer(map1 + uintptr(i))) = libc.AssignUint8(&moved, *(*Uint8_t)(unsafe.Pointer(bp + 96 + uintptr(j))))
__36:
	if !(j > 0) {
		goto __38
	}
	*(*Uint8_t)(unsafe.Pointer(bp + 96 + uintptr(j))) = *(*Uint8_t)(unsafe.Pointer(bp + 96 + uintptr(j-1)))
	goto __37
__37:
	j--
	goto __36
	goto __38
__38:
	;
	*(*Uint8_t)(unsafe.Pointer(bp + 96)) = moved
	goto __34
__34:
	i++
	goto __33
	goto __35
__35:
	;
__29:
	;
__4:
	;
	i = 0
__39:
	if !(i < num_dist) {
		goto __41
	}
	*(*Uint32_t)(unsafe.Pointer(bp + 352 + uintptr(int32(*(*Uint8_t)(unsafe.Pointer(map1 + uintptr(i))))>>5)*4)) |= Uint32_t(Uint32_t(1)) << (int32(*(*Uint8_t)(unsafe.Pointer(map1 + uintptr(i)))) & 31)
	goto __40
__40:
	i++
	goto __39
	goto __41
__41:
	;
	i = 0
__42:
	if !(i < 256 && *(*Uint32_t)(unsafe.Pointer(bp + 352 + uintptr(i>>5)*4))>>(i&31)&Uint32_t(1) != 0) {
		goto __44
	}
	goto __43
__43:
	i++
	goto __42
	goto __44
__44:
	;
	*(*Int32_t)(unsafe.Pointer(num_clusters)) = i
__45:
	if !(i < 256 && !(*(*Uint32_t)(unsafe.Pointer(bp + 352 + uintptr(i>>5)*4))>>(i&31)&Uint32_t(1) != 0)) {
		goto __47
	}
	goto __46
__46:
	i++
	goto __45
	goto __47
__47:
	;
__48:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __51
	}
	goto J40__ON_ERROR
__51:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(i == 256)), int64(0)) != 0) {
		goto __52
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 154))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 154 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 154 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 154 + 3))))
	goto J40__ON_ERROR
__52:
	;
	goto __49
__49:
	if 0 != 0 {
		goto __48
	}
	goto __50
__50:
	;
	return J40_err(0)

J40__ON_ERROR:
	j40__free_code(tls, bp+56)
	j40__free_code_spec(tls, bp)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__ans_table(tls *libc.TLS, st uintptr, log_alpha_size Int32_t, outtable uintptr) J40_err {
	bp := tls.Alloc(1036)
	defer tls.Free(1036)

	var table_size Int32_t
	var i Int32_t
	var D uintptr
	var v Int32_t
	var v1 Int32_t
	var v2 Int32_t
	var alpha_size Int32_t
	var d Int16_t
	var bias_size Int16_t
	var prev Int16_t
	var bitcount Int32_t
	var len Int32_t
	var shift Int32_t
	var alpha_size1 Int32_t
	var omit_log Int32_t
	var omit_pos Int32_t
	var code Int32_t
	var total Int32_t
	var n Int32_t
	var ncodes Int32_t

	table_size = int32(1) << log_alpha_size
	D = uintptr(0)

__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignUintptr(&D, j40__malloc(tls, uint64(unsafe.Sizeof(Int16_t(0)))*Size_t(table_size)))) != 0)), int64(0)) != 0) {
		goto __5
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__5:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
	switch j40__u(tls, st, 2) {
	case 1:
		goto __7

	case 3:
		goto __8

	case 2:
		goto __9

	case 0:
		goto __10

	default:
		goto __11
	}
	goto __6
__7:
	v = j40__u8(tls, st)
	libc.Xmemset(tls, D, 0, uint64(unsafe.Sizeof(Int16_t(0)))*Size_t(table_size))
__12:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __15
	}
	goto J40__ON_ERROR
__15:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(v < table_size)), int64(0)) != 0) {
		goto __16
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 3))))
	goto J40__ON_ERROR
__16:
	;
	goto __13
__13:
	if 0 != 0 {
		goto __12
	}
	goto __14
__14:
	;
	*(*Int16_t)(unsafe.Pointer(D + uintptr(v)*2)) = int16(4096)
	goto __6

__8:
	v1 = j40__u8(tls, st)
	v2 = j40__u8(tls, st)
__17:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __20
	}
	goto J40__ON_ERROR
__20:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(v1 != v2 && v1 < table_size && v2 < table_size)), int64(0)) != 0) {
		goto __21
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 3))))
	goto J40__ON_ERROR
__21:
	;
	goto __18
__18:
	if 0 != 0 {
		goto __17
	}
	goto __19
__19:
	;
	libc.Xmemset(tls, D, 0, uint64(unsafe.Sizeof(Int16_t(0)))*Size_t(table_size))
	*(*Int16_t)(unsafe.Pointer(D + uintptr(v1)*2)) = Int16_t(j40__u(tls, st, 12))
	*(*Int16_t)(unsafe.Pointer(D + uintptr(v2)*2)) = Int16_t(4096 - int32(*(*Int16_t)(unsafe.Pointer(D + uintptr(v1)*2))))
	goto __6

__9:
	alpha_size = j40__u8(tls, st) + 1
	d = Int16_t(4096 / alpha_size)
	bias_size = Int16_t(4096 % alpha_size)
__22:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __25
	}
	goto J40__ON_ERROR
__25:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(alpha_size <= table_size)), int64(0)) != 0) {
		goto __26
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 3))))
	goto J40__ON_ERROR
__26:
	;
	goto __23
__23:
	if 0 != 0 {
		goto __22
	}
	goto __24
__24:
	;
	i = 0
__27:
	if !(i < Int32_t(bias_size)) {
		goto __29
	}
	*(*Int16_t)(unsafe.Pointer(D + uintptr(i)*2)) = Int16_t(int32(d) + 1)
	goto __28
__28:
	i++
	goto __27
	goto __29
__29:
	;
__30:
	if !(i < alpha_size) {
		goto __32
	}
	*(*Int16_t)(unsafe.Pointer(D + uintptr(i)*2)) = d
	goto __31
__31:
	i++
	goto __30
	goto __32
__32:
	;
__33:
	if !(i < table_size) {
		goto __35
	}
	*(*Int16_t)(unsafe.Pointer(D + uintptr(i)*2)) = int16(0)
	goto __34
__34:
	i++
	goto __33
	goto __35
__35:
	;
	goto __6

__10:
	if j40__u(tls, st, 1) != 0 {
		if j40__u(tls, st, 1) != 0 {
			if j40__u(tls, st, 1) != 0 {
				len = 3
			} else {
				len = 2
			}
		} else {
			len = 1
		}
	} else {
		len = 0
	}
	shift = j40__u(tls, st, len) + int32(1)<<len - 1
__36:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __39
	}
	goto J40__ON_ERROR
__39:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(shift <= 13)), int64(0)) != 0) {
		goto __40
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 3))))
	goto J40__ON_ERROR
__40:
	;
	goto __37
__37:
	if 0 != 0 {
		goto __36
	}
	goto __38
__38:
	;
	alpha_size1 = j40__u8(tls, st) + 3

	omit_log = -1
	i = libc.AssignInt32(&ncodes, 0)
__41:
	if !(i < alpha_size1) {
		goto __43
	}
	code = j40__prefix_code(tls, st, 4, 7, uintptr(unsafe.Pointer(&TABLE)))
	if !(code < 13) {
		goto __44
	}
	i++
	*(*Int32_t)(unsafe.Pointer(bp + uintptr(libc.PostIncInt32(&ncodes, 1))*4)) = code
	if !(omit_log < code) {
		goto __46
	}
	omit_log = code
__46:
	;
	goto __45
__44:
	i = i + libc.AssignInt32(&code, j40__u8(tls, st)+4)
	*(*Int32_t)(unsafe.Pointer(bp + uintptr(libc.PostIncInt32(&ncodes, 1))*4)) = -code
__45:
	;
	goto __42
__42:
	;
	goto __41
	goto __43
__43:
	;
__47:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __50
	}
	goto J40__ON_ERROR
__50:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(i == alpha_size1 && omit_log >= 0)), int64(0)) != 0) {
		goto __51
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 3))))
	goto J40__ON_ERROR
__51:
	;
	goto __48
__48:
	if 0 != 0 {
		goto __47
	}
	goto __49
__49:
	;
	omit_pos = -1
	i = libc.AssignInt32(&n, libc.AssignInt32(&total, 0))
__52:
	if !(i < ncodes && n < table_size) {
		goto __54
	}
	code = *(*Int32_t)(unsafe.Pointer(bp + uintptr(i)*4))
	if !(code < 0) {
		goto __55
	}
	if n > 0 {
		prev = *(*Int16_t)(unsafe.Pointer(D + uintptr(n-1)*2))
	} else {
		prev = int16(0)
	}
__57:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __60
	}
	goto J40__ON_ERROR
__60:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(prev) >= 0)), int64(0)) != 0) {
		goto __61
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 3))))
	goto J40__ON_ERROR
__61:
	;
	goto __58
__58:
	if 0 != 0 {
		goto __57
	}
	goto __59
__59:
	;
	code = J40__min32(tls, -code, table_size-n)
	total = total + Int32_t(prev)*code
__62:
	if !(libc.PostDecInt32(&code, 1) > 0) {
		goto __63
	}
	*(*Int16_t)(unsafe.Pointer(D + uintptr(libc.PostIncInt32(&n, 1))*2)) = prev
	goto __62
__63:
	;
	goto __56
__55:
	if !(code == omit_log) {
		goto __64
	}
	omit_pos = n
	omit_log = -1
	*(*Int16_t)(unsafe.Pointer(D + uintptr(libc.PostIncInt32(&n, 1))*2)) = int16(-1)
	goto __65
__64:
	if !(code < 2) {
		goto __66
	}
	total = total + code
	*(*Int16_t)(unsafe.Pointer(D + uintptr(libc.PostIncInt32(&n, 1))*2)) = Int16_t(code)
	goto __67
__66:
	code--
	bitcount = J40__min32(tls, J40__max32(tls, 0, shift-(12-code)>>1), code)
	code = int32(1)<<code + j40__u(tls, st, bitcount)<<(code-bitcount)
	total = total + code
	*(*Int16_t)(unsafe.Pointer(D + uintptr(libc.PostIncInt32(&n, 1))*2)) = Int16_t(code)
__67:
	;
__65:
	;
__56:
	;
	goto __53
__53:
	i++
	goto __52
	goto __54
__54:
	;
__68:
	if !(n < table_size) {
		goto __70
	}
	*(*Int16_t)(unsafe.Pointer(D + uintptr(n)*2)) = int16(0)
	goto __69
__69:
	n++
	goto __68
	goto __70
__70:
	;
__71:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __74
	}
	goto J40__ON_ERROR
__74:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(omit_pos >= 0)), int64(0)) != 0) {
		goto __75
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 3))))
	goto J40__ON_ERROR
__75:
	;
	goto __72
__72:
	if 0 != 0 {
		goto __71
	}
	goto __73
__73:
	;
__76:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __79
	}
	goto J40__ON_ERROR
__79:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(total <= 4096)), int64(0)) != 0) {
		goto __80
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 159 + 3))))
	goto J40__ON_ERROR
__80:
	;
	goto __77
__77:
	if 0 != 0 {
		goto __76
	}
	goto __78
__78:
	;
	*(*Int16_t)(unsafe.Pointer(D + uintptr(omit_pos)*2)) = Int16_t(4096 - total)
	goto __6

__11:
	;
__6:
	;
	*(*uintptr)(unsafe.Pointer(outtable)) = D
	return J40_err(0)

J40__ON_ERROR:
	j40__free(tls, D)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

var TABLE = [20]Int32_t{
	0xa0003, -16, 0x70003, 0x30004, 0x60003, 0x80003, 0x90003, 0x50004,
	0xa0003, 0x40004, 0x70003, 0x10004, 0x60003, 0x80003, 0x90003, 0x20004,
	0x00011, 0xb0022, 0xc0003, 0xd0043,
}

func j40__read_code_spec(tls *libc.TLS, st uintptr, num_dist Int32_t, spec uintptr) J40_err {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i Int32_t
	var n Int32_t
	var c uintptr

	var c1 uintptr

	(*J40__code_spec)(unsafe.Pointer(spec)).Cluster_map = uintptr(0)
	(*J40__code_spec)(unsafe.Pointer(spec)).Clusters = uintptr(0)

	(*J40__code_spec)(unsafe.Pointer(spec)).Lz77_enabled = j40__u(tls, st, 1)
	if !((*J40__code_spec)(unsafe.Pointer(spec)).Lz77_enabled != 0) {
		goto __1
	}
	(*J40__code_spec)(unsafe.Pointer(spec)).Min_symbol = j40__u32(tls, st, 224, 0, 512, 0, 4096, 0, 8, 15)
	(*J40__code_spec)(unsafe.Pointer(spec)).Min_length = j40__u32(tls, st, 3, 0, 4, 0, 5, 2, 9, 8)
__3:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__read_hybrid_int_config(tls, st, 8, spec+40) != 0)), int64(0)) != 0) {
		goto __6
	}
	goto J40__ON_ERROR
__6:
	;
	goto __4
__4:
	if 0 != 0 {
		goto __3
	}
	goto __5
__5:
	;
	num_dist++
	goto __2
__1:
	(*J40__code_spec)(unsafe.Pointer(spec)).Min_symbol = libc.AssignPtrInt32(spec+16, 0x7fffffff)
__2:
	;
__7:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __10
	}
	goto J40__ON_ERROR
__10:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(spec+32, j40__malloc(tls, uint64(unsafe.Sizeof(Uint8_t(0)))*Size_t(num_dist)))) != 0)), int64(0)) != 0) {
		goto __11
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__11:
	;
	goto __8
__8:
	if 0 != 0 {
		goto __7
	}
	goto __9
__9:
	;
__12:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__cluster_map(tls, st, num_dist, 256, spec+24, (*J40__code_spec)(unsafe.Pointer(spec)).Cluster_map) != 0)), int64(0)) != 0) {
		goto __15
	}
	goto J40__ON_ERROR
__15:
	;
	goto __13
__13:
	if 0 != 0 {
		goto __12
	}
	goto __14
__14:
	;
__16:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __19
	}
	goto J40__ON_ERROR
__19:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(spec+48, j40__calloc(tls, Size_t((*J40__code_spec)(unsafe.Pointer(spec)).Num_clusters), uint64(unsafe.Sizeof(J40__code_cluster{}))))) != 0)), int64(0)) != 0) {
		goto __20
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__20:
	;
	goto __17
__17:
	if 0 != 0 {
		goto __16
	}
	goto __18
__18:
	;
	(*J40__code_spec)(unsafe.Pointer(spec)).Use_prefix_code = j40__u(tls, st, 1)
	if !((*J40__code_spec)(unsafe.Pointer(spec)).Use_prefix_code != 0) {
		goto __21
	}
	i = 0
__23:
	if !(i < (*J40__code_spec)(unsafe.Pointer(spec)).Num_clusters) {
		goto __25
	}
__26:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__read_hybrid_int_config(tls, st, 15, (*J40__code_spec)(unsafe.Pointer(spec)).Clusters+uintptr(i)*24) != 0)), int64(0)) != 0) {
		goto __29
	}
	goto J40__ON_ERROR
__29:
	;
	goto __27
__27:
	if 0 != 0 {
		goto __26
	}
	goto __28
__28:
	;
	goto __24
__24:
	i++
	goto __23
	goto __25
__25:
	;
	i = 0
__30:
	if !(i < (*J40__code_spec)(unsafe.Pointer(spec)).Num_clusters) {
		goto __32
	}
	if !(j40__u(tls, st, 1) != 0) {
		goto __33
	}
	n = j40__u(tls, st, 4)
	*(*Int32_t)(unsafe.Pointer((*J40__code_spec)(unsafe.Pointer(spec)).Clusters + uintptr(i)*24 + 8)) = 1 + int32(1)<<n + j40__u(tls, st, n)
__35:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __38
	}
	goto J40__ON_ERROR
__38:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(*(*Int32_t)(unsafe.Pointer((*J40__code_spec)(unsafe.Pointer(spec)).Clusters + uintptr(i)*24 + 8)) <= int32(1)<<15)), int64(0)) != 0) {
		goto __39
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 144))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 144 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 144 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 144 + 3))))
	goto J40__ON_ERROR
__39:
	;
	goto __36
__36:
	if 0 != 0 {
		goto __35
	}
	goto __37
__37:
	;
	goto __34
__33:
	*(*Int32_t)(unsafe.Pointer((*J40__code_spec)(unsafe.Pointer(spec)).Clusters + uintptr(i)*24 + 8)) = 1
__34:
	;
	goto __31
__31:
	i++
	goto __30
	goto __32
__32:
	;
	i = 0
__40:
	if !(i < (*J40__code_spec)(unsafe.Pointer(spec)).Num_clusters) {
		goto __42
	}
	c = (*J40__code_spec)(unsafe.Pointer(spec)).Clusters + uintptr(i)*24
__43:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__prefix_code_tree(tls, st, *(*Int32_t)(unsafe.Pointer(c + 8)), bp, bp+4, c+16) != 0)), int64(0)) != 0) {
		goto __46
	}
	goto J40__ON_ERROR
__46:
	;
	goto __44
__44:
	if 0 != 0 {
		goto __43
	}
	goto __45
__45:
	;
	*(*Int16_t)(unsafe.Pointer(c + 8)) = Int16_t(*(*Int32_t)(unsafe.Pointer(bp)))
	*(*Int16_t)(unsafe.Pointer(c + 10)) = Int16_t(*(*Int32_t)(unsafe.Pointer(bp + 4)))
	goto __41
__41:
	i++
	goto __40
	goto __42
__42:
	;
	goto __22
__21:
	(*J40__code_spec)(unsafe.Pointer(spec)).Log_alpha_size = 5 + j40__u(tls, st, 2)
	i = 0
__47:
	if !(i < (*J40__code_spec)(unsafe.Pointer(spec)).Num_clusters) {
		goto __49
	}
__50:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__read_hybrid_int_config(tls, st, (*J40__code_spec)(unsafe.Pointer(spec)).Log_alpha_size, (*J40__code_spec)(unsafe.Pointer(spec)).Clusters+uintptr(i)*24) != 0)), int64(0)) != 0) {
		goto __53
	}
	goto J40__ON_ERROR
__53:
	;
	goto __51
__51:
	if 0 != 0 {
		goto __50
	}
	goto __52
__52:
	;
	goto __48
__48:
	i++
	goto __47
	goto __49
__49:
	;
	i = 0
__54:
	if !(i < (*J40__code_spec)(unsafe.Pointer(spec)).Num_clusters) {
		goto __56
	}
	c1 = (*J40__code_spec)(unsafe.Pointer(spec)).Clusters + uintptr(i)*24
__57:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__ans_table(tls, st, (*J40__code_spec)(unsafe.Pointer(spec)).Log_alpha_size, c1+8) != 0)), int64(0)) != 0) {
		goto __60
	}
	goto J40__ON_ERROR
__60:
	;
	goto __58
__58:
	if 0 != 0 {
		goto __57
	}
	goto __59
__59:
	;
__61:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_alias_map(tls, st, *(*uintptr)(unsafe.Pointer(c1 + 8)), (*J40__code_spec)(unsafe.Pointer(spec)).Log_alpha_size, c1+16) != 0)), int64(0)) != 0) {
		goto __64
	}
	goto J40__ON_ERROR
__64:
	;
	goto __62
__62:
	if 0 != 0 {
		goto __61
	}
	goto __63
__63:
	;
	goto __55
__55:
	i++
	goto __54
	goto __56
__56:
	;
__22:
	;
	(*J40__code_spec)(unsafe.Pointer(spec)).Num_dist = num_dist
	return J40_err(0)

J40__ON_ERROR:
	j40__free_code_spec(tls, spec)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__entropy_code_cluster(tls *libc.TLS, st uintptr, use_prefix_code int32, log_alpha_size Int32_t, cluster uintptr, ans_state uintptr) Int32_t {
	if use_prefix_code != 0 {
		return j40__prefix_code(tls, st, int32(*(*Int16_t)(unsafe.Pointer(cluster + 8))), int32(*(*Int16_t)(unsafe.Pointer(cluster + 10))), *(*uintptr)(unsafe.Pointer(cluster + 16)))
	} else {
		return j40__ans_code(tls, st, ans_state, J40__DIST_BITS-log_alpha_size, *(*uintptr)(unsafe.Pointer(cluster + 8)), *(*uintptr)(unsafe.Pointer(cluster + 16)))
	}
	return Int32_t(0)
}

// aka DecodeHybridVarLenUint
func j40__code(tls *libc.TLS, st uintptr, ctx Int32_t, dist_mult Int32_t, code uintptr) Int32_t {
	var spec uintptr = (*J40__code_st)(unsafe.Pointer(code)).Spec
	var token Int32_t
	var distance Int32_t
	var log_alpha_size Int32_t
	var cluster uintptr
	var use_prefix_code int32

	if (*J40__code_st)(unsafe.Pointer(code)).Num_to_copy > 0 {
		(*J40__code_st)(unsafe.Pointer(code)).Num_to_copy--
		return libc.AssignPtrInt32((*J40__code_st)(unsafe.Pointer(code)).Window+uintptr(libc.PostIncInt32(&(*J40__code_st)(unsafe.Pointer(code)).Num_decoded, 1)&MASK)*4, *(*Int32_t)(unsafe.Pointer((*J40__code_st)(unsafe.Pointer(code)).Window + uintptr(libc.PostIncInt32(&(*J40__code_st)(unsafe.Pointer(code)).Copy_pos, 1)&MASK)*4)))
	}

	use_prefix_code = (*J40__code_spec)(unsafe.Pointer(spec)).Use_prefix_code
	log_alpha_size = (*J40__code_spec)(unsafe.Pointer(spec)).Log_alpha_size
	cluster = (*J40__code_spec)(unsafe.Pointer(spec)).Clusters + uintptr(*(*Uint8_t)(unsafe.Pointer((*J40__code_spec)(unsafe.Pointer(spec)).Cluster_map + uintptr(ctx))))*24
	token = j40__entropy_code_cluster(tls, st, use_prefix_code, log_alpha_size, cluster, code+32)
	if token >= (*J40__code_spec)(unsafe.Pointer(spec)).Min_symbol {
		var lz_cluster uintptr = (*J40__code_spec)(unsafe.Pointer(spec)).Clusters + uintptr(*(*Uint8_t)(unsafe.Pointer((*J40__code_spec)(unsafe.Pointer(spec)).Cluster_map + uintptr((*J40__code_spec)(unsafe.Pointer(spec)).Num_dist-1))))*24
		(*J40__code_st)(unsafe.Pointer(code)).Num_to_copy = j40__hybrid_int(tls, st, token-(*J40__code_spec)(unsafe.Pointer(spec)).Min_symbol, (*J40__code_spec)(unsafe.Pointer(spec)).Lz_len_config) + (*J40__code_spec)(unsafe.Pointer(spec)).Min_length
		token = j40__entropy_code_cluster(tls, st, use_prefix_code, log_alpha_size, lz_cluster, code+32)
		distance = j40__hybrid_int(tls, st, token, *(*J40__hybrid_int_config)(unsafe.Pointer(lz_cluster)))
		if (*J40__st)(unsafe.Pointer(st)).Err != 0 {
			return 0
		}
		if !(dist_mult != 0) {
			distance++
		} else if distance >= 120 {
			distance = distance - 119
		} else {
			var special Int32_t = Int32_t(SPECIAL_DISTANCES[distance])

			distance = J40__max32(tls, 1, special>>4-7+dist_mult*(special&7))
		}
		distance = J40__min32(tls, J40__min32(tls, distance, (*J40__code_st)(unsafe.Pointer(code)).Num_decoded), int32(1)<<20)
		(*J40__code_st)(unsafe.Pointer(code)).Copy_pos = (*J40__code_st)(unsafe.Pointer(code)).Num_decoded - distance
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(distance == 0)), int64(0)) != 0 {
			(*J40__code_st)(unsafe.Pointer(code)).Window = j40__calloc(tls, uint64(uint32(1)<<20), uint64(unsafe.Sizeof(Int32_t(0))))
			if !(int32((*J40__code_st)(unsafe.Pointer(code)).Window) != 0) {
				j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
				return 0
			}
		}
		(*J40__code_st)(unsafe.Pointer(code)).Num_to_copy--
		return libc.AssignPtrInt32((*J40__code_st)(unsafe.Pointer(code)).Window+uintptr(libc.PostIncInt32(&(*J40__code_st)(unsafe.Pointer(code)).Num_decoded, 1)&MASK)*4, *(*Int32_t)(unsafe.Pointer((*J40__code_st)(unsafe.Pointer(code)).Window + uintptr(libc.PostIncInt32(&(*J40__code_st)(unsafe.Pointer(code)).Copy_pos, 1)&MASK)*4)))
	}

	token = j40__hybrid_int(tls, st, token, *(*J40__hybrid_int_config)(unsafe.Pointer(cluster)))
	if (*J40__st)(unsafe.Pointer(st)).Err != 0 {
		return 0
	}
	if (*J40__code_spec)(unsafe.Pointer(spec)).Lz77_enabled != 0 {
		if !(int32((*J40__code_st)(unsafe.Pointer(code)).Window) != 0) {
			(*J40__code_st)(unsafe.Pointer(code)).Window = j40__malloc(tls, uint64(uint64(unsafe.Sizeof(Int32_t(0))))<<20)
			if !(int32((*J40__code_st)(unsafe.Pointer(code)).Window) != 0) {
				j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
				return 0
			}
		}
		*(*Int32_t)(unsafe.Pointer((*J40__code_st)(unsafe.Pointer(code)).Window + uintptr(libc.PostIncInt32(&(*J40__code_st)(unsafe.Pointer(code)).Num_decoded, 1)&MASK)*4)) = token
	}
	return token
}

var MASK Int32_t = 0xfffff
var SPECIAL_DISTANCES = [120]Uint8_t{
	Uint8_t(0x71), Uint8_t(0x80), Uint8_t(0x81), Uint8_t(0x61), Uint8_t(0x72), Uint8_t(0x90), Uint8_t(0x82), Uint8_t(0x62), Uint8_t(0x91), Uint8_t(0x51), Uint8_t(0x92), Uint8_t(0x52),
	Uint8_t(0x73), Uint8_t(0xa0), Uint8_t(0x83), Uint8_t(0x63), Uint8_t(0xa1), Uint8_t(0x41), Uint8_t(0x93), Uint8_t(0x53), Uint8_t(0xa2), Uint8_t(0x42), Uint8_t(0x74), Uint8_t(0xb0),
	Uint8_t(0x84), Uint8_t(0x64), Uint8_t(0xb1), Uint8_t(0x31), Uint8_t(0xa3), Uint8_t(0x43), Uint8_t(0x94), Uint8_t(0x54), Uint8_t(0xb2), Uint8_t(0x32), Uint8_t(0x75), Uint8_t(0xa4),
	Uint8_t(0x44), Uint8_t(0xb3), Uint8_t(0x33), Uint8_t(0xc0), Uint8_t(0x85), Uint8_t(0x65), Uint8_t(0xc1), Uint8_t(0x21), Uint8_t(0x95), Uint8_t(0x55), Uint8_t(0xc2), Uint8_t(0x22),
	Uint8_t(0xb4), Uint8_t(0x34), Uint8_t(0xa5), Uint8_t(0x45), Uint8_t(0xc3), Uint8_t(0x23), Uint8_t(0x76), Uint8_t(0xd0), Uint8_t(0x86), Uint8_t(0x66), Uint8_t(0xd1), Uint8_t(0x11),
	Uint8_t(0x96), Uint8_t(0x56), Uint8_t(0xd2), Uint8_t(0x12), Uint8_t(0xb5), Uint8_t(0x35), Uint8_t(0xc4), Uint8_t(0x24), Uint8_t(0xa6), Uint8_t(0x46), Uint8_t(0xd3), Uint8_t(0x13),
	Uint8_t(0x77), Uint8_t(0xe0), Uint8_t(0x87), Uint8_t(0x67), Uint8_t(0xc5), Uint8_t(0x25), Uint8_t(0xe1), Uint8_t(0x01), Uint8_t(0xb6), Uint8_t(0x36), Uint8_t(0xd4), Uint8_t(0x14),
	Uint8_t(0x97), Uint8_t(0x57), Uint8_t(0xe2), Uint8_t(0x02), Uint8_t(0xa7), Uint8_t(0x47), Uint8_t(0xe3), Uint8_t(0x03), Uint8_t(0xc6), Uint8_t(0x26), Uint8_t(0xd5), Uint8_t(0x15),
	Uint8_t(0xf0), Uint8_t(0xb7), Uint8_t(0x37), Uint8_t(0xe4), Uint8_t(0x04), Uint8_t(0xf1), Uint8_t(0xf2), Uint8_t(0xd6), Uint8_t(0x16), Uint8_t(0xf3), Uint8_t(0xc7), Uint8_t(0x27),
	Uint8_t(0xe5), Uint8_t(0x05), Uint8_t(0xf4), Uint8_t(0xd7), Uint8_t(0x17), Uint8_t(0xe6), Uint8_t(0x06), Uint8_t(0xf5), Uint8_t(0xe7), Uint8_t(0x07), Uint8_t(0xf6), Uint8_t(0xf7),
}

func j40__free_code(tls *libc.TLS, code uintptr) {
	j40__free(tls, (*J40__code_st)(unsafe.Pointer(code)).Window)
	(*J40__code_st)(unsafe.Pointer(code)).Window = uintptr(0)
	(*J40__code_st)(unsafe.Pointer(code)).Window_cap = 0
}

func j40__finish_and_free_code(tls *libc.TLS, st uintptr, code uintptr) J40_err {
	if !!((*J40__code_spec)(unsafe.Pointer((*J40__code_st)(unsafe.Pointer(code)).Spec)).Use_prefix_code != 0) {
		goto __1
	}
	if !((*J40__code_st)(unsafe.Pointer(code)).Ans_state != 0) {
		goto __2
	}
__4:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __7
	}
	goto J40__ON_ERROR
__7:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__code_st)(unsafe.Pointer(code)).Ans_state == J40__ANS_INIT_STATE)), int64(0)) != 0) {
		goto __8
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 164))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 164 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 164 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 164 + 3))))
	goto J40__ON_ERROR
__8:
	;
	goto __5
__5:
	if 0 != 0 {
		goto __4
	}
	goto __6
__6:
	;
	goto __3
__2:
__9:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __12
	}
	goto J40__ON_ERROR
__12:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(j40__u(tls, st, 16) == J40__ANS_INIT_STATE&0xffff)), int64(0)) != 0) {
		goto __13
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 164))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 164 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 164 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 164 + 3))))
	goto J40__ON_ERROR
__13:
	;
	goto __10
__10:
	if 0 != 0 {
		goto __9
	}
	goto __11
__11:
	;
__14:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __17
	}
	goto J40__ON_ERROR
__17:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(j40__u(tls, st, 16) == int32(J40__ANS_INIT_STATE)>>16)), int64(0)) != 0) {
		goto __18
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 164))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 164 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 164 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 164 + 3))))
	goto J40__ON_ERROR
__18:
	;
	goto __15
__15:
	if 0 != 0 {
		goto __14
	}
	goto __16
__16:
	;
__3:
	;
__1:
	;
J40__ON_ERROR:
	j40__free_code(tls, code)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__free_code_spec(tls *libc.TLS, spec uintptr) {
	var i Int32_t
	if (*J40__code_spec)(unsafe.Pointer(spec)).Clusters != 0 {
		for i = 0; i < (*J40__code_spec)(unsafe.Pointer(spec)).Num_clusters; i++ {
			if (*J40__code_spec)(unsafe.Pointer(spec)).Use_prefix_code != 0 {
				j40__free(tls, *(*uintptr)(unsafe.Pointer((*J40__code_spec)(unsafe.Pointer(spec)).Clusters + uintptr(i)*24 + 16)))
			} else {
				j40__free(tls, *(*uintptr)(unsafe.Pointer((*J40__code_spec)(unsafe.Pointer(spec)).Clusters + uintptr(i)*24 + 8)))
				j40__free(tls, *(*uintptr)(unsafe.Pointer((*J40__code_spec)(unsafe.Pointer(spec)).Clusters + uintptr(i)*24 + 16)))
			}
		}
		j40__free(tls, (*J40__code_spec)(unsafe.Pointer(spec)).Clusters)
		(*J40__code_spec)(unsafe.Pointer(spec)).Clusters = uintptr(0)
	}
	j40__free(tls, (*J40__code_spec)(unsafe.Pointer(spec)).Cluster_map)
	(*J40__code_spec)(unsafe.Pointer(spec)).Cluster_map = uintptr(0)
}

const (
	J40__EC_ALPHA          = 0
	J40__EC_DEPTH          = 1
	J40__EC_SPOT_COLOUR    = 2
	J40__EC_SELECTION_MASK = 3
	J40__EC_BLACK          = 4
	J40__EC_CFA            = 5
	J40__EC_THERMAL        = 6
	J40__EC_NON_OPTIONAL   = 15
	J40__EC_OPTIONAL       = 16
)

type J40__ec_info = struct {
	Type        uint32
	Bpp         Int32_t
	Exp_bits    Int32_t
	Dim_shift   Int32_t
	Name_len    Int32_t
	__ccgo_pad1 [4]byte
	Name        uintptr
	Data        struct {
		Alpha_associated int32
		__ccgo_pad1      [12]byte
	}
}

const (
	J40__ORIENT_TL = 1
	J40__ORIENT_TR = 2
	J40__ORIENT_BR = 3
	J40__ORIENT_BL = 4
	J40__ORIENT_LT = 5
	J40__ORIENT_RT = 6
	J40__ORIENT_RB = 7
	J40__ORIENT_LB = 8
)

const (
	J40__CS_CHROMA = 99
	J40__CS_GREY   = 103
	J40__CS_XYB    = 120
)

const (
	J40__TF_709     = -1
	J40__TF_UNKNOWN = -2
	J40__TF_LINEAR  = -8
	J40__TF_SRGB    = -13
	J40__TF_PQ      = -16
	J40__TF_DCI     = -17
	J40__TF_HLG     = -18
	J40__GAMMA_MAX  = 10000000
)

const (
	J40__INTENT_PERC = 0
	J40__INTENT_REL  = 1
	J40__INTENT_SAT  = 2
	J40__INTENT_ABS  = 3
)

type J40__image_st = J40__image_st1

func j40__signature(tls *libc.TLS, st uintptr) J40_err {
	var sig Int32_t
	sig = j40__u(tls, st, 16)
__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(sig == 0x0aff)), int64(0)) != 0) {
		goto __5
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 94))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 94 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 94 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 94 + 3))))
	goto J40__ON_ERROR
__5:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__size_header(tls *libc.TLS, st uintptr, outw uintptr, outh uintptr) J40_err {
	var div8 Int32_t
	div8 = j40__u(tls, st, 1)
	*(*Int32_t)(unsafe.Pointer(outh)) = func() int32 {
		if div8 != 0 {
			return (j40__u(tls, st, 5) + 1) * 8
		}
		return j40__u32(tls, st, 1, 9, 1, 13, 1, 18, 1, 30)
	}()
	switch j40__u(tls, st, 3) {
	case 0:
		goto __2
	case 1:
		goto __3
	case 2:
		goto __4
	case 3:
		goto __5
	case 4:
		goto __6
	case 5:
		goto __7
	case 6:
		goto __8
	case 7:
		goto __9
	default:
		goto __10
	}
	goto __1
__2:
	*(*Int32_t)(unsafe.Pointer(outw)) = func() int32 {
		if div8 != 0 {
			return (j40__u(tls, st, 5) + 1) * 8
		}
		return j40__u32(tls, st, 1, 9, 1, 13, 1, 18, 1, 30)
	}()
	goto __1
__3:
	*(*Int32_t)(unsafe.Pointer(outw)) = *(*Int32_t)(unsafe.Pointer(outh))
	goto __1
__4:
	*(*Int32_t)(unsafe.Pointer(outw)) = Int32_t(Uint64_t(*(*Int32_t)(unsafe.Pointer(outh))) * uint64(6) / uint64(5))
	goto __1
__5:
	*(*Int32_t)(unsafe.Pointer(outw)) = Int32_t(Uint64_t(*(*Int32_t)(unsafe.Pointer(outh))) * uint64(4) / uint64(3))
	goto __1
__6:
	*(*Int32_t)(unsafe.Pointer(outw)) = Int32_t(Uint64_t(*(*Int32_t)(unsafe.Pointer(outh))) * uint64(3) / uint64(2))
	goto __1
__7:
	*(*Int32_t)(unsafe.Pointer(outw)) = Int32_t(Uint64_t(*(*Int32_t)(unsafe.Pointer(outh))) * uint64(16) / uint64(9))
	goto __1
__8:
	*(*Int32_t)(unsafe.Pointer(outw)) = Int32_t(Uint64_t(*(*Int32_t)(unsafe.Pointer(outh))) * uint64(5) / uint64(4))
	goto __1
__9:
__11:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __14
	}
	goto J40__ON_ERROR
__14:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(*(*Int32_t)(unsafe.Pointer(outh)) < 0x40000000)), int64(0)) != 0) {
		goto __15
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 61))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 61 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 61 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 61 + 3))))
	goto J40__ON_ERROR
__15:
	;
	goto __12
__12:
	if 0 != 0 {
		goto __11
	}
	goto __13
__13:
	;
	*(*Int32_t)(unsafe.Pointer(outw)) = *(*Int32_t)(unsafe.Pointer(outh)) * 2
	goto __1
__10:
	;
__1:
	;
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__bit_depth(tls *libc.TLS, st uintptr, outbpp uintptr, outexpbits uintptr) J40_err {
	var mantissa_bits Int32_t
	if !(j40__u(tls, st, 1) != 0) {
		goto __1
	}
	*(*Int32_t)(unsafe.Pointer(outbpp)) = j40__u32(tls, st, 32, 0, 16, 0, 24, 0, 1, 6)
	*(*Int32_t)(unsafe.Pointer(outexpbits)) = j40__u(tls, st, 4) + 1
	mantissa_bits = *(*Int32_t)(unsafe.Pointer(outbpp)) - *(*Int32_t)(unsafe.Pointer(outexpbits)) - 1
__3:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __6
	}
	goto J40__ON_ERROR
__6:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(2 <= mantissa_bits && mantissa_bits <= 23)), int64(0)) != 0) {
		goto __7
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 169))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 169 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 169 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 169 + 3))))
	goto J40__ON_ERROR
__7:
	;
	goto __4
__4:
	if 0 != 0 {
		goto __3
	}
	goto __5
__5:
	;
__8:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __11
	}
	goto J40__ON_ERROR
__11:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(2 <= *(*Int32_t)(unsafe.Pointer(outexpbits)) && *(*Int32_t)(unsafe.Pointer(outexpbits)) <= 8)), int64(0)) != 0) {
		goto __12
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 174))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 174 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 174 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 174 + 3))))
	goto J40__ON_ERROR
__12:
	;
	goto __9
__9:
	if 0 != 0 {
		goto __8
	}
	goto __10
__10:
	;
	goto __2
__1:
	*(*Int32_t)(unsafe.Pointer(outbpp)) = j40__u32(tls, st, 8, 0, 10, 0, 12, 0, 1, 6)
	*(*Int32_t)(unsafe.Pointer(outexpbits)) = 0
__13:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __16
	}
	goto J40__ON_ERROR
__16:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(1 <= *(*Int32_t)(unsafe.Pointer(outbpp)) && *(*Int32_t)(unsafe.Pointer(outbpp)) <= 31)), int64(0)) != 0) {
		goto __17
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 169))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 169 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 169 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 169 + 3))))
	goto J40__ON_ERROR
__17:
	;
	goto __14
__14:
	if 0 != 0 {
		goto __13
	}
	goto __15
__15:
	;
__2:
	;
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__name(tls *libc.TLS, st uintptr, outlen uintptr, outbuf uintptr) J40_err {
	var buf uintptr
	var i Int32_t
	var c Int32_t
	var cc Int32_t
	var len Int32_t
	buf = uintptr(0)
	len = j40__u32(tls, st, 0, 0, 0, 4, 16, 5, 48, 10)
	if !(len > 0) {
		goto __1
	}
__3:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __6
	}
	goto J40__ON_ERROR
__6:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignUintptr(&buf, j40__malloc(tls, Size_t(len)+uint64(1)))) != 0)), int64(0)) != 0) {
		goto __7
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__7:
	;
	goto __4
__4:
	if 0 != 0 {
		goto __3
	}
	goto __5
__5:
	;
	i = 0
__8:
	if !(i < len) {
		goto __10
	}
	*(*int8)(unsafe.Pointer(buf + uintptr(i))) = int8(j40__u(tls, st, 8))
__11:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __14
	}
	goto J40__ON_ERROR
__14:
	;
	goto __12
__12:
	if 0 != 0 {
		goto __11
	}
	goto __13
__13:
	;
	goto __9
__9:
	i++
	goto __8
	goto __10
__10:
	;
	*(*int8)(unsafe.Pointer(buf + uintptr(len))) = int8(0)
	i = 0
__15:
	if !(i < len) {
		goto __17
	}
	c = Int32_t(Uint8_t(*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&i, 1))))))
	cc = Int32_t(Uint8_t(*(*int8)(unsafe.Pointer(buf + uintptr(i)))))
	if c < 0x80 {
		c = 0
	} else {
		if c < 0xc2 {
			c = -1
		} else {
			if c < 0xe0 {
				c = 1
			} else {
				if c < 0xf0 {
					if func() int32 {
						if c == 0xe0 {
							return libc.Bool32(cc >= 0xa0)
						}
						return func() int32 {
							if c == 0xed {
								return libc.Bool32(cc < 0xa0)
							}
							return 1
						}()
					}() != 0 {
						c = 2
					} else {
						c = -1
					}
				} else {
					if c < 0xf5 {
						if func() int32 {
							if c == 0xf0 {
								return libc.Bool32(cc >= 0x90)
							}
							return func() int32 {
								if c == 0xf4 {
									return libc.Bool32(cc < 0x90)
								}
								return 1
							}()
						}() != 0 {
							c = 3
						} else {
							c = -1
						}
					} else {
						c = -1
					}
				}
			}
		}
	}
__18:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __21
	}
	goto J40__ON_ERROR
__21:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(c >= 0 && i+c < len)), int64(0)) != 0) {
		goto __22
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 179))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 179 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 179 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 179 + 3))))
	goto J40__ON_ERROR
__22:
	;
	goto __19
__19:
	if 0 != 0 {
		goto __18
	}
	goto __20
__20:
	;
__23:
	if !(libc.PostDecInt32(&c, 1) > 0) {
		goto __24
	}
__25:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __28
	}
	goto J40__ON_ERROR
__28:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&i, 1)))))&0xc0 == 0x80)), int64(0)) != 0) {
		goto __29
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 179))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 179 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 179 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 179 + 3))))
	goto J40__ON_ERROR
__29:
	;
	goto __26
__26:
	if 0 != 0 {
		goto __25
	}
	goto __27
__27:
	;
	goto __23
__24:
	;
	goto __16
__16:
	;
	goto __15
	goto __17
__17:
	;
	*(*uintptr)(unsafe.Pointer(outbuf)) = buf
	goto __2
__1:
__30:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __33
	}
	goto J40__ON_ERROR
__33:
	;
	goto __31
__31:
	if 0 != 0 {
		goto __30
	}
	goto __32
__32:
	;
	*(*uintptr)(unsafe.Pointer(outbuf)) = uintptr(0)
__2:
	;
	*(*Int32_t)(unsafe.Pointer(outlen)) = len
	return J40_err(0)
J40__ON_ERROR:
	j40__free(tls, buf)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__customxy(tls *libc.TLS, st uintptr, xy uintptr) J40_err {
	*(*float32)(unsafe.Pointer(xy)) = float32(J40__unpack_signed(tls, j40__u32(tls, st, 0, 19, 0x80000, 19, 0x100000, 20, 0x200000, 21))) / 100000.0
	*(*float32)(unsafe.Pointer(xy + 1*4)) = float32(J40__unpack_signed(tls, j40__u32(tls, st, 0, 19, 0x80000, 19, 0x100000, 20, 0x200000, 21))) / 100000.0
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__extensions(tls *libc.TLS, st uintptr) J40_err {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var extensions Uint64_t

	var i Int32_t
	var n Uint64_t
	extensions = j40__u64(tls, st)
	*(*Int64_t)(unsafe.Pointer(bp)) = int64(0)
	i = 0
__1:
	if !(i < 64) {
		goto __3
	}
	if !(extensions>>i&uint64(1) != 0) {
		goto __4
	}
	n = j40__u64(tls, st)
__5:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __8
	}
	goto J40__ON_ERROR
__8:
	;
	goto __6
__6:
	if 0 != 0 {
		goto __5
	}
	goto __7
__7:
	;
__9:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __12
	}
	goto J40__ON_ERROR
__12:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(n <= uint64(9223372036854775807) && J40__add64(tls, *(*Int64_t)(unsafe.Pointer(bp)), Int64_t(n), bp) != 0)), int64(0)) != 0) {
		goto __13
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 3))))
	goto J40__ON_ERROR
__13:
	;
	goto __10
__10:
	if 0 != 0 {
		goto __9
	}
	goto __11
__11:
	;
__4:
	;
	goto __2
__2:
	i++
	goto __1
	goto __3
__3:
	;
	return j40__skip(tls, st, *(*Int64_t)(unsafe.Pointer(bp)))
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__image_metadata(tls *libc.TLS, st uintptr) J40_err {
	var im uintptr
	var i Int32_t
	var j Int32_t
	var ec uintptr
	var cspace uint32
	var relative_to_max_display int32
	var extra_fields Int32_t
	var cw_mask Int32_t
	im = (*J40__st)(unsafe.Pointer(st)).Image

	(*J40__image_st)(unsafe.Pointer(im)).Orientation = J40__ORIENT_TL
	(*J40__image_st)(unsafe.Pointer(im)).Intr_width = 0
	(*J40__image_st)(unsafe.Pointer(im)).Intr_height = 0
	(*J40__image_st)(unsafe.Pointer(im)).Bpp = 8
	(*J40__image_st)(unsafe.Pointer(im)).Exp_bits = 0
	(*J40__image_st)(unsafe.Pointer(im)).Anim_tps_num = 0
	(*J40__image_st)(unsafe.Pointer(im)).Anim_tps_denom = 0
	(*J40__image_st)(unsafe.Pointer(im)).Anim_nloops = int64(0)
	(*J40__image_st)(unsafe.Pointer(im)).Anim_have_timecodes = 0
	(*J40__image_st)(unsafe.Pointer(im)).Icc = uintptr(0)
	(*J40__image_st)(unsafe.Pointer(im)).Iccsize = uint64(0)
	(*J40__image_st)(unsafe.Pointer(im)).Cspace = J40__CS_CHROMA
	libc.Xmemcpy(tls, im+76, uintptr(unsafe.Pointer(&SRGB_CHROMA)), uint64(unsafe.Sizeof(SRGB_CHROMA)))
	(*J40__image_st)(unsafe.Pointer(im)).Gamma_or_tf = J40__TF_SRGB
	(*J40__image_st)(unsafe.Pointer(im)).Render_intent = J40__INTENT_REL
	(*J40__image_st)(unsafe.Pointer(im)).Intensity_target = 255.0
	(*J40__image_st)(unsafe.Pointer(im)).Min_nits = 0.0
	(*J40__image_st)(unsafe.Pointer(im)).Linear_below = 0.0
	(*J40__image_st)(unsafe.Pointer(im)).Modular_16bit_buffers = 1
	(*J40__image_st)(unsafe.Pointer(im)).Xyb_encoded = 1
	libc.Xmemcpy(tls, im+148, uintptr(unsafe.Pointer(&OPSIN_INV_MAT)), uint64(unsafe.Sizeof(OPSIN_INV_MAT)))
	*(*float32)(unsafe.Pointer(im + 184)) = libc.AssignPtrFloat32(im+184+1*4, libc.AssignPtrFloat32(im+184+2*4, -0.0037930732552754493))
	*(*float32)(unsafe.Pointer(im + 196)) = float32(1.0) - 0.05465007330715401
	*(*float32)(unsafe.Pointer(im + 196 + 1*4)) = float32(1.0) - 0.07005449891748593
	*(*float32)(unsafe.Pointer(im + 196 + 2*4)) = float32(1.0) - 0.049935103337343655
	(*J40__image_st)(unsafe.Pointer(im)).Quant_bias_num = 0.145

__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__size_header(tls, st, im, im+4) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
__5:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __8
	}
	goto J40__ON_ERROR
__8:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__image_st)(unsafe.Pointer(im)).Width <= (*J40__limits1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Limits)).Width && (*J40__image_st)(unsafe.Pointer(im)).Height <= (*J40__limits1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Limits)).Height)), int64(0)) != 0) {
		goto __9
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 184))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 184 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 184 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 184 + 3))))
	goto J40__ON_ERROR
__9:
	;
	goto __6
__6:
	if 0 != 0 {
		goto __5
	}
	goto __7
__7:
	;
__10:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __13
	}
	goto J40__ON_ERROR
__13:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Int64_t((*J40__image_st)(unsafe.Pointer(im)).Width)*Int64_t((*J40__image_st)(unsafe.Pointer(im)).Height) <= (*J40__limits1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Limits)).Pixels)), int64(0)) != 0) {
		goto __14
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 184))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 184 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 184 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 184 + 3))))
	goto J40__ON_ERROR
__14:
	;
	goto __11
__11:
	if 0 != 0 {
		goto __10
	}
	goto __12
__12:
	;
	if !!(j40__u(tls, st, 1) != 0) {
		goto __15
	}
	extra_fields = j40__u(tls, st, 1)
	if !(extra_fields != 0) {
		goto __16
	}
	(*J40__image_st)(unsafe.Pointer(im)).Orientation = uint32(uint32(j40__u(tls, st, 3) + 1))
	if !(j40__u(tls, st, 1) != 0) {
		goto __17
	}
__18:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__size_header(tls, st, im+12, im+16) != 0)), int64(0)) != 0) {
		goto __21
	}
	goto J40__ON_ERROR
__21:
	;
	goto __19
__19:
	if 0 != 0 {
		goto __18
	}
	goto __20
__20:
	;
__17:
	;
	if !(j40__u(tls, st, 1) != 0) {
		goto __22
	}
__23:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 189))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 189 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 189 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 189 + 3))))
	goto J40__ON_ERROR
	goto __24
__24:
	if 0 != 0 {
		goto __23
	}
	goto __25
__25:
	;
__22:
	;
	if !(j40__u(tls, st, 1) != 0) {
		goto __26
	}
	(*J40__image_st)(unsafe.Pointer(im)).Anim_tps_num = j40__u32(tls, st, 100, 0, 1000, 0, 1, 10, 1, 30)
	(*J40__image_st)(unsafe.Pointer(im)).Anim_tps_denom = j40__u32(tls, st, 1, 0, 1001, 0, 1, 8, 1, 10)
	(*J40__image_st)(unsafe.Pointer(im)).Anim_nloops = j40__64u32(tls, st, 0, 0, 0, 3, 0, 16, 0, 32)
	(*J40__image_st)(unsafe.Pointer(im)).Anim_have_timecodes = j40__u(tls, st, 1)
__26:
	;
__16:
	;
__27:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__bit_depth(tls, st, im+20, im+24) != 0)), int64(0)) != 0) {
		goto __30
	}
	goto J40__ON_ERROR
__30:
	;
	goto __28
__28:
	if 0 != 0 {
		goto __27
	}
	goto __29
__29:
	;
__31:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __34
	}
	goto J40__ON_ERROR
__34:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__image_st)(unsafe.Pointer(im)).Bpp <= (*J40__limits1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Limits)).Bpp)), int64(0)) != 0) {
		goto __35
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 203))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 203 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 203 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 203 + 3))))
	goto J40__ON_ERROR
__35:
	;
	goto __32
__32:
	if 0 != 0 {
		goto __31
	}
	goto __33
__33:
	;
	(*J40__image_st)(unsafe.Pointer(im)).Modular_16bit_buffers = j40__u(tls, st, 1)
__36:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __39
	}
	goto J40__ON_ERROR
__39:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__image_st)(unsafe.Pointer(im)).Modular_16bit_buffers != 0 || !((*J40__limits1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Limits)).Needs_modular_16bit_buffers != 0))), int64(0)) != 0) {
		goto __40
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 208))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 208 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 208 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 208 + 3))))
	goto J40__ON_ERROR
__40:
	;
	goto __37
__37:
	if 0 != 0 {
		goto __36
	}
	goto __38
__38:
	;
	(*J40__image_st)(unsafe.Pointer(im)).Num_extra_channels = j40__u32(tls, st, 0, 0, 1, 0, 2, 4, 1, 12)
__41:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __44
	}
	goto J40__ON_ERROR
__44:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__image_st)(unsafe.Pointer(im)).Num_extra_channels <= (*J40__limits1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Limits)).Num_extra_channels)), int64(0)) != 0) {
		goto __45
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 213))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 213 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 213 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 213 + 3))))
	goto J40__ON_ERROR
__45:
	;
	goto __42
__42:
	if 0 != 0 {
		goto __41
	}
	goto __43
__43:
	;
__46:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __49
	}
	goto J40__ON_ERROR
__49:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(im+136, j40__calloc(tls, Size_t((*J40__image_st)(unsafe.Pointer(im)).Num_extra_channels), uint64(unsafe.Sizeof(J40__ec_info{}))))) != 0)), int64(0)) != 0) {
		goto __50
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__50:
	;
	goto __47
__47:
	if 0 != 0 {
		goto __46
	}
	goto __48
__48:
	;
	i = 0
__51:
	if !(i < (*J40__image_st)(unsafe.Pointer(im)).Num_extra_channels) {
		goto __53
	}
	(*J40__ec_info)(unsafe.Pointer((*J40__image_st)(unsafe.Pointer(im)).Ec_info + uintptr(i)*48)).Name = uintptr(0)
	goto __52
__52:
	i++
	goto __51
	goto __53
__53:
	;
	i = 0
__54:
	if !(i < (*J40__image_st)(unsafe.Pointer(im)).Num_extra_channels) {
		goto __56
	}
	ec = (*J40__image_st)(unsafe.Pointer(im)).Ec_info + uintptr(i)*48
	if !(j40__u(tls, st, 1) != 0) {
		goto __57
	}
	(*J40__ec_info)(unsafe.Pointer(ec)).Type = J40__EC_ALPHA
	(*J40__ec_info)(unsafe.Pointer(ec)).Bpp = 8
	(*J40__ec_info)(unsafe.Pointer(ec)).Exp_bits = libc.AssignPtrInt32(ec+12, libc.AssignPtrInt32(ec+16, 0))
	*(*int32)(unsafe.Pointer(ec + 32)) = 0
	goto __58
__57:
	(*J40__ec_info)(unsafe.Pointer(ec)).Type = uint32(uint32(j40__enum(tls, st)))
__59:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__bit_depth(tls, st, ec+4, ec+8) != 0)), int64(0)) != 0) {
		goto __62
	}
	goto J40__ON_ERROR
__62:
	;
	goto __60
__60:
	if 0 != 0 {
		goto __59
	}
	goto __61
__61:
	;
	(*J40__ec_info)(unsafe.Pointer(ec)).Dim_shift = j40__u32(tls, st, 0, 0, 3, 0, 4, 0, 1, 3)
__63:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__name(tls, st, ec+16, ec+24) != 0)), int64(0)) != 0) {
		goto __66
	}
	goto J40__ON_ERROR
__66:
	;
	goto __64
__64:
	if 0 != 0 {
		goto __63
	}
	goto __65
__65:
	;
	switch (*J40__ec_info)(unsafe.Pointer(ec)).Type {
	case J40__EC_ALPHA:
		goto __68
	case J40__EC_SPOT_COLOUR:
		goto __69
	case J40__EC_CFA:
		goto __70
	case J40__EC_BLACK:
		goto __71
	case J40__EC_DEPTH:
		goto __72
	case J40__EC_SELECTION_MASK:
		goto __73
	case J40__EC_THERMAL:
		goto __74
	case J40__EC_NON_OPTIONAL:
		goto __75
	case J40__EC_OPTIONAL:
		goto __76
	default:
		goto __77
	}
	goto __67
__68:
	*(*int32)(unsafe.Pointer(ec + 32)) = j40__u(tls, st, 1)
	goto __67
__69:
	*(*float32)(unsafe.Pointer(ec + 32)) = j40__f16(tls, st)
	*(*float32)(unsafe.Pointer(ec + 32 + 4)) = j40__f16(tls, st)
	*(*float32)(unsafe.Pointer(ec + 32 + 8)) = j40__f16(tls, st)
	*(*float32)(unsafe.Pointer(ec + 32 + 12)) = j40__f16(tls, st)
	goto __67
__70:
	*(*Int32_t)(unsafe.Pointer(ec + 32)) = j40__u32(tls, st, 1, 0, 0, 2, 3, 4, 19, 8)
	goto __67
__71:
__78:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __81
	}
	goto J40__ON_ERROR
__81:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__limits1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Limits)).Ec_black_allowed != 0)), int64(0)) != 0) {
		goto __82
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 218))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 218 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 218 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 218 + 3))))
	goto J40__ON_ERROR
__82:
	;
	goto __79
__79:
	if 0 != 0 {
		goto __78
	}
	goto __80
__80:
	;
	goto __67
__72:
__73:
__74:
__75:
__76:
	goto __67
__77:
__83:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 223))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 223 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 223 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 223 + 3))))
	goto J40__ON_ERROR
	goto __84
__84:
	if 0 != 0 {
		goto __83
	}
	goto __85
__85:
	;
__67:
	;
__58:
	;
__86:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __89
	}
	goto J40__ON_ERROR
__89:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__ec_info)(unsafe.Pointer(ec)).Bpp <= (*J40__limits1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Limits)).Bpp)), int64(0)) != 0) {
		goto __90
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 203))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 203 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 203 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 203 + 3))))
	goto J40__ON_ERROR
__90:
	;
	goto __87
__87:
	if 0 != 0 {
		goto __86
	}
	goto __88
__88:
	;
__91:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __94
	}
	goto J40__ON_ERROR
__94:
	;
	goto __92
__92:
	if 0 != 0 {
		goto __91
	}
	goto __93
__93:
	;
	goto __55
__55:
	i++
	goto __54
	goto __56
__56:
	;
	(*J40__image_st)(unsafe.Pointer(im)).Xyb_encoded = j40__u(tls, st, 1)
	if !!(j40__u(tls, st, 1) != 0) {
		goto __95
	}
	(*J40__image_st)(unsafe.Pointer(im)).Want_icc = j40__u(tls, st, 1)
	cspace = uint32(uint32(j40__enum(tls, st)))
	switch cspace {
	case uint32(0):
		goto __97
	case uint32(3):
		goto __98
	case uint32(1):
		goto __99
	case uint32(2):
		goto __100
	default:
		goto __101
	}
	goto __96
__97:
__98:
	(*J40__image_st)(unsafe.Pointer(im)).Cspace = J40__CS_CHROMA
	goto __96
__99:
	(*J40__image_st)(unsafe.Pointer(im)).Cspace = J40__CS_GREY
	goto __96
__100:
	(*J40__image_st)(unsafe.Pointer(im)).Cspace = J40__CS_XYB
	goto __96
__101:
__102:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 228))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 228 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 228 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 228 + 3))))
	goto J40__ON_ERROR
	goto __103
__103:
	if 0 != 0 {
		goto __102
	}
	goto __104
__104:
	;
__96:
	;
	if !!((*J40__image_st)(unsafe.Pointer(im)).Want_icc != 0) {
		goto __105
	}
	if !(cspace != uint32(2)) {
		goto __106
	}
	switch j40__enum(tls, st) {
	case 1:
		goto __108
	case 2:
		goto __109
	case 10:
		goto __110
	case 11:
		goto __111
	default:
		goto __112
	}
	goto __107
__108:
	goto __107
__109:
__113:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__customxy(tls, st, im+76) != 0)), int64(0)) != 0) {
		goto __116
	}
	goto J40__ON_ERROR
__116:
	;
	goto __114
__114:
	if 0 != 0 {
		goto __113
	}
	goto __115
__115:
	;
	goto __107
__110:
	libc.Xmemcpy(tls, im+76+uintptr(J40__CHROMA_WHITE)*8, uintptr(unsafe.Pointer(&E)), uint64(unsafe.Sizeof(E)))
	goto __107
__111:
	libc.Xmemcpy(tls, im+76+uintptr(J40__CHROMA_WHITE)*8, uintptr(unsafe.Pointer(&DCI)), uint64(unsafe.Sizeof(DCI)))
	goto __107
__112:
__117:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 233))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 233 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 233 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 233 + 3))))
	goto J40__ON_ERROR
	goto __118
__118:
	if 0 != 0 {
		goto __117
	}
	goto __119
__119:
	;
__107:
	;
	if !(cspace != uint32(1)) {
		goto __120
	}
	switch j40__enum(tls, st) {
	case 1:
		goto __122
	case 2:
		goto __123
	case 9:
		goto __124
	case 11:
		goto __125
	default:
		goto __126
	}
	goto __121
__122:
	goto __121
__123:
__127:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__customxy(tls, st, im+76+1*8) != 0)), int64(0)) != 0) {
		goto __130
	}
	goto J40__ON_ERROR
__130:
	;
	goto __128
__128:
	if 0 != 0 {
		goto __127
	}
	goto __129
__129:
	;
__131:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__customxy(tls, st, im+76+2*8) != 0)), int64(0)) != 0) {
		goto __134
	}
	goto J40__ON_ERROR
__134:
	;
	goto __132
__132:
	if 0 != 0 {
		goto __131
	}
	goto __133
__133:
	;
__135:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__customxy(tls, st, im+76+3*8) != 0)), int64(0)) != 0) {
		goto __138
	}
	goto J40__ON_ERROR
__138:
	;
	goto __136
__136:
	if 0 != 0 {
		goto __135
	}
	goto __137
__137:
	;
	goto __121
__124:
	libc.Xmemcpy(tls, im+76+uintptr(J40__CHROMA_RED)*8, uintptr(unsafe.Pointer(&BT2100)), uint64(unsafe.Sizeof(BT2100)))
	goto __121
__125:
	libc.Xmemcpy(tls, im+76+uintptr(J40__CHROMA_RED)*8, uintptr(unsafe.Pointer(&P3)), uint64(unsafe.Sizeof(P3)))
	goto __121
__126:
__139:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 238))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 238 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 238 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 238 + 3))))
	goto J40__ON_ERROR
	goto __140
__140:
	if 0 != 0 {
		goto __139
	}
	goto __141
__141:
	;
__121:
	;
__120:
	;
__106:
	;
	if !(j40__u(tls, st, 1) != 0) {
		goto __142
	}
	(*J40__image_st)(unsafe.Pointer(im)).Gamma_or_tf = j40__u(tls, st, 24)
__144:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __147
	}
	goto J40__ON_ERROR
__147:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__image_st)(unsafe.Pointer(im)).Gamma_or_tf > 0 && (*J40__image_st)(unsafe.Pointer(im)).Gamma_or_tf <= J40__GAMMA_MAX)), int64(0)) != 0) {
		goto __148
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 243))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 243 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 243 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 243 + 3))))
	goto J40__ON_ERROR
__148:
	;
	goto __145
__145:
	if 0 != 0 {
		goto __144
	}
	goto __146
__146:
	;
	if !(cspace == uint32(2)) {
		goto __149
	}
__150:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __153
	}
	goto J40__ON_ERROR
__153:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__image_st)(unsafe.Pointer(im)).Gamma_or_tf == 3333333)), int64(0)) != 0) {
		goto __154
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 243))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 243 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 243 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 243 + 3))))
	goto J40__ON_ERROR
__154:
	;
	goto __151
__151:
	if 0 != 0 {
		goto __150
	}
	goto __152
__152:
	;
__149:
	;
	goto __143
__142:
	(*J40__image_st)(unsafe.Pointer(im)).Gamma_or_tf = -j40__enum(tls, st)
__155:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __158
	}
	goto J40__ON_ERROR
__158:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(int32(1)<<-J40__TF_709|int32(1)<<-J40__TF_UNKNOWN|int32(1)<<-J40__TF_LINEAR|int32(1)<<-J40__TF_SRGB|int32(1)<<-J40__TF_PQ|int32(1)<<-J40__TF_DCI|int32(1)<<-J40__TF_HLG)>>-(*J40__image_st)(unsafe.Pointer(im)).Gamma_or_tf&1 != 0)), int64(0)) != 0) {
		goto __159
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 248))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 248 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 248 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 248 + 3))))
	goto J40__ON_ERROR
__159:
	;
	goto __156
__156:
	if 0 != 0 {
		goto __155
	}
	goto __157
__157:
	;
__143:
	;
	(*J40__image_st)(unsafe.Pointer(im)).Render_intent = uint32(uint32(j40__enum(tls, st)))
__160:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __163
	}
	goto J40__ON_ERROR
__163:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(int32(1)<<J40__INTENT_PERC|int32(1)<<J40__INTENT_REL|int32(1)<<J40__INTENT_SAT|int32(1)<<J40__INTENT_ABS)>>(*J40__image_st)(unsafe.Pointer(im)).Render_intent&1 != 0)), int64(0)) != 0) {
		goto __164
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 253))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 253 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 253 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 253 + 3))))
	goto J40__ON_ERROR
__164:
	;
	goto __161
__161:
	if 0 != 0 {
		goto __160
	}
	goto __162
__162:
	;
__105:
	;
__95:
	;
	if !(extra_fields != 0) {
		goto __165
	}
	if !!(j40__u(tls, st, 1) != 0) {
		goto __166
	}
	(*J40__image_st)(unsafe.Pointer(im)).Intensity_target = j40__f16(tls, st)
__167:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __170
	}
	goto J40__ON_ERROR
__170:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__image_st)(unsafe.Pointer(im)).Intensity_target > float32(0))), int64(0)) != 0) {
		goto __171
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 258))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 258 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 258 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 258 + 3))))
	goto J40__ON_ERROR
__171:
	;
	goto __168
__168:
	if 0 != 0 {
		goto __167
	}
	goto __169
__169:
	;
	(*J40__image_st)(unsafe.Pointer(im)).Min_nits = j40__f16(tls, st)
__172:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __175
	}
	goto J40__ON_ERROR
__175:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(float32(0) < (*J40__image_st)(unsafe.Pointer(im)).Min_nits && (*J40__image_st)(unsafe.Pointer(im)).Min_nits <= (*J40__image_st)(unsafe.Pointer(im)).Intensity_target)), int64(0)) != 0) {
		goto __176
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 258))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 258 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 258 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 258 + 3))))
	goto J40__ON_ERROR
__176:
	;
	goto __173
__173:
	if 0 != 0 {
		goto __172
	}
	goto __174
__174:
	;
	relative_to_max_display = j40__u(tls, st, 1)
	(*J40__image_st)(unsafe.Pointer(im)).Linear_below = j40__f16(tls, st)
	if !(relative_to_max_display != 0) {
		goto __177
	}
__179:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __182
	}
	goto J40__ON_ERROR
__182:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(float32(0) <= (*J40__image_st)(unsafe.Pointer(im)).Linear_below && (*J40__image_st)(unsafe.Pointer(im)).Linear_below <= float32(1))), int64(0)) != 0) {
		goto __183
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 258))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 258 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 258 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 258 + 3))))
	goto J40__ON_ERROR
__183:
	;
	goto __180
__180:
	if 0 != 0 {
		goto __179
	}
	goto __181
__181:
	;
	*(*float32)(unsafe.Pointer(im + 124)) *= -1.0
	goto __178
__177:
__184:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __187
	}
	goto J40__ON_ERROR
__187:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(float32(0) <= (*J40__image_st)(unsafe.Pointer(im)).Linear_below)), int64(0)) != 0) {
		goto __188
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 258))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 258 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 258 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 258 + 3))))
	goto J40__ON_ERROR
__188:
	;
	goto __185
__185:
	if 0 != 0 {
		goto __184
	}
	goto __186
__186:
	;
__178:
	;
__166:
	;
__165:
	;
__189:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__extensions(tls, st) != 0)), int64(0)) != 0) {
		goto __192
	}
	goto J40__ON_ERROR
__192:
	;
	goto __190
__190:
	if 0 != 0 {
		goto __189
	}
	goto __191
__191:
	;
__15:
	;
	if !!(j40__u(tls, st, 1) != 0) {
		goto __193
	}
	if !((*J40__image_st)(unsafe.Pointer(im)).Xyb_encoded != 0) {
		goto __194
	}
	i = 0
__195:
	if !(i < 3) {
		goto __197
	}
	j = 0
__198:
	if !(j < 3) {
		goto __200
	}
	*(*float32)(unsafe.Pointer(im + 148 + uintptr(i)*12 + uintptr(j)*4)) = j40__f16(tls, st)
	goto __199
__199:
	j++
	goto __198
	goto __200
__200:
	;
	goto __196
__196:
	i++
	goto __195
	goto __197
__197:
	;
	i = 0
__201:
	if !(i < 3) {
		goto __203
	}
	*(*float32)(unsafe.Pointer(im + 184 + uintptr(i)*4)) = j40__f16(tls, st)
	goto __202
__202:
	i++
	goto __201
	goto __203
__203:
	;
	i = 0
__204:
	if !(i < 3) {
		goto __206
	}
	*(*float32)(unsafe.Pointer(im + 196 + uintptr(i)*4)) = j40__f16(tls, st)
	goto __205
__205:
	i++
	goto __204
	goto __206
__206:
	;
	(*J40__image_st)(unsafe.Pointer(im)).Quant_bias_num = j40__f16(tls, st)
__194:
	;
	cw_mask = j40__u(tls, st, 3)
	if !(cw_mask&1 != 0) {
		goto __207
	}
__208:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 263))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 263 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 263 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 263 + 3))))
	goto J40__ON_ERROR
	goto __209
__209:
	if 0 != 0 {
		goto __208
	}
	goto __210
__210:
	;
__207:
	;
	if !(cw_mask&2 != 0) {
		goto __211
	}
__212:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 280))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 280 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 280 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 280 + 3))))
	goto J40__ON_ERROR
	goto __213
__213:
	if 0 != 0 {
		goto __212
	}
	goto __214
__214:
	;
__211:
	;
	if !(cw_mask&4 != 0) {
		goto __215
	}
__216:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 297))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 297 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 297 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 297 + 3))))
	goto J40__ON_ERROR
	goto __217
__217:
	if 0 != 0 {
		goto __216
	}
	goto __218
__218:
	;
__215:
	;
__193:
	;
__219:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __222
	}
	goto J40__ON_ERROR
__222:
	;
	goto __220
__220:
	if 0 != 0 {
		goto __219
	}
	goto __221
__221:
	;
	return J40_err(0)

J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

var SRGB_CHROMA = [4][2]float32{
	{0.3127, 0.3290}, {0.639998686, 0.330010138},
	{0.300003784, 0.600003357}, {0.150002046, 0.059997204},
}
var OPSIN_INV_MAT = [3][3]float32{
	{11.031566901960783, -9.866943921568629, -0.16462299647058826},
	{-3.254147380392157, 4.418770392156863, -0.16462299647058826},
	{-3.6588512862745097, 2.7129230470588235, 1.9459282392156863},
}
var E = [2]float32{float32(float32(1)) / 3., float32(float32(1)) / 3.}
var DCI = [2]float32{0.314, 0.351}
var BT2100 = [3][2]float32{{0.708, 0.292}, {0.170, 0.797}, {0.131, 0.046}}
var P3 = [3][2]float32{{0.680, 0.320}, {0.265, 0.690}, {0.150, 0.060}}

func j40__free_image_state(tls *libc.TLS, im uintptr) {
	var i Int32_t
	if (*J40__image_st)(unsafe.Pointer(im)).Ec_info != 0 {
		for i = 0; i < (*J40__image_st)(unsafe.Pointer(im)).Num_extra_channels; i++ {
			j40__free(tls, (*J40__ec_info)(unsafe.Pointer((*J40__image_st)(unsafe.Pointer(im)).Ec_info+uintptr(i)*48)).Name)
		}
		j40__free(tls, (*J40__image_st)(unsafe.Pointer(im)).Ec_info)
		(*J40__image_st)(unsafe.Pointer(im)).Ec_info = uintptr(0)
	}
	j40__free(tls, (*J40__image_st)(unsafe.Pointer(im)).Icc)
	(*J40__image_st)(unsafe.Pointer(im)).Icc = uintptr(0)
	(*J40__image_st)(unsafe.Pointer(im)).Num_extra_channels = 0
}

func j40__icc(tls *libc.TLS, st uintptr) J40_err {
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var enc_size Size_t
	var index Size_t

	var byte Int32_t
	var prev Int32_t
	var pprev Int32_t
	var ctx Int32_t
	*(*J40__code_spec)(unsafe.Pointer(bp)) = J40__code_spec{}
	*(*J40__code_st)(unsafe.Pointer(bp + 56)) = J40__code_st{Spec: bp}
	byte = 0
	prev = 0
	pprev = 0

	enc_size = j40__u64(tls, st)
__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__read_code_spec(tls, st, 41, bp) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
	index = uint64(0)
__5:
	if !(index < enc_size) {
		goto __7
	}
	pprev = prev
	prev = byte
	ctx = 0
	if !(index > uint64(128)) {
		goto __8
	}
	if !(prev < 16) {
		goto __9
	}
	if prev < 2 {
		ctx = prev + 3
	} else {
		ctx = 5
	}
	goto __10
__9:
	if !(prev > 240) {
		goto __11
	}
	ctx = 6 + libc.Bool32(prev == 255)
	goto __12
__11:
	if !(97 <= prev|32 && prev|32 <= 122) {
		goto __13
	}
	ctx = 1
	goto __14
__13:
	if !(prev == 44 || prev == 46 || 48 <= prev && prev < 58) {
		goto __15
	}
	ctx = 2
	goto __16
__15:
	ctx = 8
__16:
	;
__14:
	;
__12:
	;
__10:
	;
	if !(pprev < 16) {
		goto __17
	}
	ctx = ctx + 2*8
	goto __18
__17:
	if !(pprev > 240) {
		goto __19
	}
	ctx = ctx + 3*8
	goto __20
__19:
	if !(97 <= pprev|32 && pprev|32 <= 122) {
		goto __21
	}
	ctx = ctx + 0*8
	goto __22
__21:
	if !(pprev == 44 || pprev == 46 || 48 <= pprev && pprev < 58) {
		goto __23
	}
	ctx = ctx + 1*8
	goto __24
__23:
	ctx = ctx + 4*8
__24:
	;
__22:
	;
__20:
	;
__18:
	;
__8:
	;
	byte = j40__code(tls, st, ctx, 0, bp+56)

__25:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __28
	}
	goto J40__ON_ERROR
__28:
	;
	goto __26
__26:
	if 0 != 0 {
		goto __25
	}
	goto __27
__27:
	;
	goto __6
__6:
	index++
	goto __5
	goto __7
__7:
	;
__29:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__finish_and_free_code(tls, st, bp+56) != 0)), int64(0)) != 0) {
		goto __32
	}
	goto J40__ON_ERROR
__32:
	;
	goto __30
__30:
	if 0 != 0 {
		goto __29
	}
	goto __31
__31:
	;
	j40__free_code_spec(tls, bp)

	return J40_err(0)

J40__ON_ERROR:
	j40__free_code(tls, bp+56)
	j40__free_code_spec(tls, bp)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

type J40__tree_node = struct {
	Branch struct {
		Prop     Int32_t
		Value    Int32_t
		Leftoff  Int32_t
		Rightoff Int32_t
	}
}

func j40__tree(tls *libc.TLS, st uintptr, max_tree_size Int32_t, tree uintptr, codespec uintptr) J40_err {
	bp := tls.Alloc(52)
	defer tls.Free(52)

	var tree_idx Int32_t

	var ctx_id Int32_t
	var nodes_left Int32_t
	var depth Int32_t
	var nodes_upto_this_depth Int32_t
	var newptr uintptr
	var n uintptr
	var prop Int32_t
	var val Int32_t
	var shift Int32_t
	*(*J40__code_st)(unsafe.Pointer(bp)) = J40__code_st{Spec: codespec}
	*(*uintptr)(unsafe.Pointer(bp + 40)) = uintptr(0)
	tree_idx = 0
	*(*Int32_t)(unsafe.Pointer(bp + 48)) = 8
	ctx_id = 0
	nodes_left = 1
	depth = 0
	nodes_upto_this_depth = 1

__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__read_code_spec(tls, st, 6, codespec) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
__5:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __8
	}
	goto J40__ON_ERROR
__8:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(bp+40, j40__malloc(tls, uint64(unsafe.Sizeof(J40__tree_node{}))*Size_t(*(*Int32_t)(unsafe.Pointer(bp + 48)))))) != 0)), int64(0)) != 0) {
		goto __9
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__9:
	;
	goto __6
__6:
	if 0 != 0 {
		goto __5
	}
	goto __7
__7:
	;
__10:
	if !(libc.PostDecInt32(&nodes_left, 1) > 0) {
		goto __11
	}

	if !(tree_idx == nodes_upto_this_depth) {
		goto __12
	}
__13:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __16
	}
	goto J40__ON_ERROR
__16:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(libc.PreIncInt32(&depth, 1) <= (*J40__limits1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Limits)).Tree_depth)), int64(0)) != 0) {
		goto __17
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 314))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 314 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 314 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 314 + 3))))
	goto J40__ON_ERROR
__17:
	;
	goto __14
__14:
	if 0 != 0 {
		goto __13
	}
	goto __15
__15:
	;
	nodes_upto_this_depth = nodes_upto_this_depth + (nodes_left + 1)
__12:
	;
	prop = j40__code(tls, st, 1, 0, bp)
__18:
	newptr = j40__realloc32(tls, st, *(*uintptr)(unsafe.Pointer(bp + 40)), uint64(unsafe.Sizeof(J40__tree_node{})), tree_idx+1, bp+48)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(newptr != 0)), int64(1)) != 0) {
		goto __21
	}
	*(*uintptr)(unsafe.Pointer(bp + 40)) = newptr
	goto __22
__21:
	goto J40__ON_ERROR
__22:
	;
	goto __19
__19:
	if 0 != 0 {
		goto __18
	}
	goto __20
__20:
	;
	n = *(*uintptr)(unsafe.Pointer(bp + 40)) + uintptr(libc.PostIncInt32(&tree_idx, 1))*16
	if !(prop > 0) {
		goto __23
	}
	*(*Int32_t)(unsafe.Pointer(n)) = -prop
	*(*Int32_t)(unsafe.Pointer(n + 4)) = J40__unpack_signed(tls, j40__code(tls, st, 0, 0, bp))
	*(*Int32_t)(unsafe.Pointer(n + 8)) = libc.PreIncInt32(&nodes_left, 1)
	*(*Int32_t)(unsafe.Pointer(n + 12)) = libc.PreIncInt32(&nodes_left, 1)
	goto __24
__23:
	*(*Int32_t)(unsafe.Pointer(n)) = libc.PostIncInt32(&ctx_id, 1)
	*(*Int32_t)(unsafe.Pointer(n + 4)) = j40__code(tls, st, 2, 0, bp)
	*(*Int32_t)(unsafe.Pointer(n + 8)) = J40__unpack_signed(tls, j40__code(tls, st, 3, 0, bp))
	shift = j40__code(tls, st, 4, 0, bp)
__25:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __28
	}
	goto J40__ON_ERROR
__28:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(shift < 31)), int64(0)) != 0) {
		goto __29
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 319))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 319 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 319 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 319 + 3))))
	goto J40__ON_ERROR
__29:
	;
	goto __26
__26:
	if 0 != 0 {
		goto __25
	}
	goto __27
__27:
	;
	val = j40__code(tls, st, 5, 0, bp)
__30:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __33
	}
	goto J40__ON_ERROR
__33:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((val+1)>>(31-shift) == 0)), int64(0)) != 0) {
		goto __34
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 319))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 319 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 319 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 319 + 3))))
	goto J40__ON_ERROR
__34:
	;
	goto __31
__31:
	if 0 != 0 {
		goto __30
	}
	goto __32
__32:
	;
	*(*Int32_t)(unsafe.Pointer(n + 12)) = (val + 1) << shift
__24:
	;
__35:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __38
	}
	goto J40__ON_ERROR
__38:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tree_idx+nodes_left <= max_tree_size)), int64(0)) != 0) {
		goto __39
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 314))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 314 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 314 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 314 + 3))))
	goto J40__ON_ERROR
__39:
	;
	goto __36
__36:
	if 0 != 0 {
		goto __35
	}
	goto __37
__37:
	;
	goto __10
__11:
	;
__40:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__finish_and_free_code(tls, st, bp) != 0)), int64(0)) != 0) {
		goto __43
	}
	goto J40__ON_ERROR
__43:
	;
	goto __41
__41:
	if 0 != 0 {
		goto __40
	}
	goto __42
__42:
	;
	j40__free_code_spec(tls, codespec)
	libc.Xmemset(tls, codespec, 0, uint64(unsafe.Sizeof(J40__code_spec{})))
__44:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__read_code_spec(tls, st, ctx_id, codespec) != 0)), int64(0)) != 0) {
		goto __47
	}
	goto J40__ON_ERROR
__47:
	;
	goto __45
__45:
	if 0 != 0 {
		goto __44
	}
	goto __46
__46:
	;
	*(*uintptr)(unsafe.Pointer(tree)) = *(*uintptr)(unsafe.Pointer(bp + 40))
	return J40_err(0)

J40__ON_ERROR:
	j40__free(tls, *(*uintptr)(unsafe.Pointer(bp + 40)))
	j40__free_code(tls, bp)
	j40__free_code_spec(tls, codespec)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

const (
	J40__TR_RCT     = 0
	J40__TR_PALETTE = 1
	J40__TR_SQUEEZE = 2
)

type J40__transform = struct {
	Tr          uint32
	__ccgo_pad1 [20]byte
}

type J40__wp_params = struct {
	P1 Int8_t
	P2 Int8_t
	P3 [5]Int8_t
	W  [4]Int8_t
}

type J40__modular = struct {
	Use_global_tree  int32
	Wp               J40__wp_params
	__ccgo_pad1      [1]byte
	Nb_transforms    Int32_t
	__ccgo_pad2      [4]byte
	Transform        uintptr
	Tree             uintptr
	Codespec         J40__code_spec
	Code             J40__code_st
	Num_channels     Int32_t
	Nb_meta_channels Int32_t
	Channel          uintptr
	Dist_mult        Int32_t
	__ccgo_pad3      [4]byte
}

func j40__init_modular_common(tls *libc.TLS, m uintptr) {
	(*J40__modular)(unsafe.Pointer(m)).Transform = uintptr(0)
	(*J40__modular)(unsafe.Pointer(m)).Tree = uintptr(0)
	libc.Xmemset(tls, m+40, 0, uint64(unsafe.Sizeof(J40__code_spec{})))
	libc.Xmemset(tls, m+96, 0, uint64(unsafe.Sizeof(J40__code_st{})))
	(*J40__modular)(unsafe.Pointer(m)).Code.Spec = m + 40
	(*J40__modular)(unsafe.Pointer(m)).Channel = uintptr(0)
}

func j40__init_modular(tls *libc.TLS, st uintptr, num_channels Int32_t, w uintptr, h uintptr, m uintptr) J40_err {
	var i Int32_t

	j40__init_modular_common(tls, m)
	(*J40__modular)(unsafe.Pointer(m)).Num_channels = num_channels

__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(m+144, j40__calloc(tls, Size_t(num_channels), uint64(unsafe.Sizeof(J40__plane{}))))) != 0)), int64(0)) != 0) {
		goto __5
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__5:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
	i = 0
__6:
	if !(i < num_channels) {
		goto __8
	}
	(*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(i)*24)).Width = *(*Int32_t)(unsafe.Pointer(w + uintptr(i)*4))
	(*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(i)*24)).Height = *(*Int32_t)(unsafe.Pointer(h + uintptr(i)*4))
	(*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(i)*24)).Hshift = libc.AssignPtrInt8((*J40__modular)(unsafe.Pointer(m)).Channel+uintptr(i)*24+2, int8(0))
	goto __7
__7:
	i++
	goto __6
	goto __8
__8:
	;
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__init_modular_for_global(tls *libc.TLS, st uintptr, frame_is_modular int32, frame_do_ycbcr int32, frame_log_upsampling Int32_t, frame_ec_log_upsampling uintptr, frame_width Int32_t, frame_height Int32_t, m uintptr) J40_err {
	var im uintptr
	var i Int32_t
	var log_upsampling Int32_t
	im = (*J40__st)(unsafe.Pointer(st)).Image

	j40__init_modular_common(tls, m)
	(*J40__modular)(unsafe.Pointer(m)).Num_channels = (*J40__image_st)(unsafe.Pointer(im)).Num_extra_channels
	if !(frame_is_modular != 0) {
		goto __1
	}
	*(*Int32_t)(unsafe.Pointer(m + 136)) += func() int32 {
		if !(frame_do_ycbcr != 0) && !((*J40__image_st)(unsafe.Pointer(im)).Xyb_encoded != 0) && (*J40__image_st)(unsafe.Pointer(im)).Cspace == J40__CS_GREY {
			return 1
		}
		return 3
	}()
__1:
	;
	if !((*J40__modular)(unsafe.Pointer(m)).Num_channels == 0) {
		goto __2
	}
	return J40_err(0)
__2:
	;
__3:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __6
	}
	goto J40__ON_ERROR
__6:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(m+144, j40__calloc(tls, Size_t((*J40__modular)(unsafe.Pointer(m)).Num_channels), uint64(unsafe.Sizeof(J40__plane{}))))) != 0)), int64(0)) != 0) {
		goto __7
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__7:
	;
	goto __4
__4:
	if 0 != 0 {
		goto __3
	}
	goto __5
__5:
	;
	i = 0
__8:
	if !(i < (*J40__image_st)(unsafe.Pointer(im)).Num_extra_channels) {
		goto __10
	}
	log_upsampling = func() int32 {
		if frame_ec_log_upsampling != 0 {
			return *(*Int32_t)(unsafe.Pointer(frame_ec_log_upsampling + uintptr(i)*4))
		}
		return 0
	}() + (*J40__ec_info)(unsafe.Pointer((*J40__image_st)(unsafe.Pointer(im)).Ec_info+uintptr(i)*48)).Dim_shift
__11:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __14
	}
	goto J40__ON_ERROR
__14:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(log_upsampling >= frame_log_upsampling)), int64(0)) != 0) {
		goto __15
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 324))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 324 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 324 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 324 + 3))))
	goto J40__ON_ERROR
__15:
	;
	goto __12
__12:
	if 0 != 0 {
		goto __11
	}
	goto __13
__13:
	;
__16:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __19
	}
	goto J40__ON_ERROR
__19:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(log_upsampling == 0)), int64(0)) != 0) {
		goto __20
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 329))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 329 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 329 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 329 + 3))))
	goto J40__ON_ERROR
__20:
	;
	goto __17
__17:
	if 0 != 0 {
		goto __16
	}
	goto __18
__18:
	;
	(*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(i)*24)).Width = frame_width
	(*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(i)*24)).Height = frame_height
	(*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(i)*24)).Hshift = libc.AssignPtrInt8((*J40__modular)(unsafe.Pointer(m)).Channel+uintptr(i)*24+2, int8(0))
	goto __9
__9:
	i++
	goto __8
	goto __10
__10:
	;
__21:
	if !(i < (*J40__modular)(unsafe.Pointer(m)).Num_channels) {
		goto __23
	}
	(*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(i)*24)).Width = frame_width
	(*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(i)*24)).Height = frame_height
	(*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(i)*24)).Hshift = libc.AssignPtrInt8((*J40__modular)(unsafe.Pointer(m)).Channel+uintptr(i)*24+2, int8(0))
	goto __22
__22:
	i++
	goto __21
	goto __23
__23:
	;
	return J40_err(0)

J40__ON_ERROR:
	j40__free(tls, (*J40__modular)(unsafe.Pointer(m)).Channel)
	(*J40__modular)(unsafe.Pointer(m)).Channel = uintptr(0)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__init_modular_for_pass_group(tls *libc.TLS, st uintptr, num_gm_channels Int32_t, gw Int32_t, gh Int32_t, minshift Int32_t, maxshift Int32_t, gm uintptr, m uintptr) J40_err {
	var i Int32_t
	var max_channels Int32_t
	var gc uintptr
	var c uintptr

	j40__init_modular_common(tls, m)
	(*J40__modular)(unsafe.Pointer(m)).Num_channels = 0
	max_channels = (*J40__modular)(unsafe.Pointer(gm)).Num_channels - num_gm_channels

__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(m+144, j40__calloc(tls, Size_t(max_channels), uint64(unsafe.Sizeof(J40__plane{}))))) != 0)), int64(0)) != 0) {
		goto __5
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__5:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
	i = num_gm_channels
__6:
	if !(i < (*J40__modular)(unsafe.Pointer(gm)).Num_channels) {
		goto __8
	}
	gc = (*J40__modular)(unsafe.Pointer(gm)).Channel + uintptr(i)*24
	c = (*J40__modular)(unsafe.Pointer(m)).Channel + uintptr((*J40__modular)(unsafe.Pointer(m)).Num_channels)*24
	if !(int32((*J40__plane)(unsafe.Pointer(gc)).Hshift) < 3 || int32((*J40__plane)(unsafe.Pointer(gc)).Vshift) < 3) {
		goto __9
	}

	_ = minshift
	_ = maxshift

	(*J40__plane)(unsafe.Pointer(c)).Hshift = (*J40__plane)(unsafe.Pointer(gc)).Hshift
	(*J40__plane)(unsafe.Pointer(c)).Vshift = (*J40__plane)(unsafe.Pointer(gc)).Vshift
	(*J40__plane)(unsafe.Pointer(c)).Width = gw >> int32((*J40__plane)(unsafe.Pointer(gc)).Hshift)
	(*J40__plane)(unsafe.Pointer(c)).Height = gh >> int32((*J40__plane)(unsafe.Pointer(gc)).Vshift)
	(*J40__modular)(unsafe.Pointer(m)).Num_channels++
__9:
	;
	goto __7
__7:
	i++
	goto __6
	goto __8
__8:
	;
	if !((*J40__modular)(unsafe.Pointer(m)).Num_channels == 0) {
		goto __10
	}
	j40__free(tls, (*J40__modular)(unsafe.Pointer(m)).Channel)
	(*J40__modular)(unsafe.Pointer(m)).Channel = uintptr(0)
__10:
	;
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__combine_modular_from_pass_group(tls *libc.TLS, num_gm_channels Int32_t, gy Int32_t, gx Int32_t, minshift Int32_t, maxshift Int32_t, gm uintptr, m uintptr) {
	var gcidx Int32_t
	var cidx Int32_t
	var y Int32_t
	var gx0 Int32_t
	var gy0 Int32_t
	gcidx = num_gm_channels
	cidx = 0
	for ; gcidx < (*J40__modular)(unsafe.Pointer(gm)).Num_channels; gcidx++ {
		var gc uintptr = (*J40__modular)(unsafe.Pointer(gm)).Channel + uintptr(gcidx)*24
		var c uintptr = (*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(cidx)*24

		if int32((*J40__plane)(unsafe.Pointer(gc)).Hshift) < 3 || int32((*J40__plane)(unsafe.Pointer(gc)).Vshift) < 3 {
			var pixel_size Size_t = Size_t(int32(1) << (int32((*J40__plane)(unsafe.Pointer(gc)).Type) & 31))
			var gc_stride Size_t = Size_t((*J40__plane)(unsafe.Pointer(gc)).Stride_bytes)
			var c_stride Size_t = Size_t((*J40__plane)(unsafe.Pointer(c)).Stride_bytes)
			_ = minshift
			_ = maxshift

			gx0 = gx >> int32((*J40__plane)(unsafe.Pointer(gc)).Hshift)
			gy0 = gy >> int32((*J40__plane)(unsafe.Pointer(gc)).Vshift)

			for y = 0; y < (*J40__plane)(unsafe.Pointer(c)).Height; y++ {
				libc.Xmemcpy(tls,
					uintptr((*J40__plane)(unsafe.Pointer(gc)).Pixels+gc_stride*Size_t(gy0+y)+pixel_size*Size_t(gx0)),
					uintptr((*J40__plane)(unsafe.Pointer(c)).Pixels+c_stride*Size_t(y)),
					pixel_size*Size_t((*J40__plane)(unsafe.Pointer(c)).Width))
			}
			cidx++
		}
	}

}

func j40__modular_header(tls *libc.TLS, st uintptr, global_tree uintptr, global_codespec uintptr, m uintptr) J40_err {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var num_channels Int32_t
	var nb_meta_channels Int32_t

	var i Int32_t
	var j Int32_t
	var default_wp int32
	var begin_c Int32_t
	var type1 Int32_t
	var newptr uintptr
	var input J40__plane
	var begin_c1 Int32_t
	var num_c Int32_t
	var end_c Int32_t
	var nb_colours Int32_t
	var newptr1 uintptr
	var tr uintptr
	var num_sq Int32_t
	var max_tree_size Int32_t
	*(*uintptr)(unsafe.Pointer(bp)) = (*J40__modular)(unsafe.Pointer(m)).Channel
	num_channels = (*J40__modular)(unsafe.Pointer(m)).Num_channels
	nb_meta_channels = 0
	*(*Int32_t)(unsafe.Pointer(bp + 8)) = (*J40__modular)(unsafe.Pointer(m)).Num_channels

	(*J40__modular)(unsafe.Pointer(m)).Use_global_tree = j40__u(tls, st, 1)
__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(!((*J40__modular)(unsafe.Pointer(m)).Use_global_tree != 0) || global_tree != 0)), int64(0)) != 0) {
		goto __5
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 367))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 367 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 367 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 367 + 3))))
	goto J40__ON_ERROR
__5:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
	default_wp = j40__u(tls, st, 1)
	(*J40__modular)(unsafe.Pointer(m)).Wp.P1 = func() int8 {
		if default_wp != 0 {
			return int8(16)
		}
		return Int8_t(j40__u(tls, st, 5))
	}()
	(*J40__modular)(unsafe.Pointer(m)).Wp.P2 = func() int8 {
		if default_wp != 0 {
			return int8(10)
		}
		return Int8_t(j40__u(tls, st, 5))
	}()
	i = 0
__6:
	if !(i < 5) {
		goto __8
	}
	*(*Int8_t)(unsafe.Pointer(m + 4 + 2 + uintptr(i))) = func() int8 {
		if default_wp != 0 {
			return int8(7 * libc.Bool32(i < 3))
		}
		return Int8_t(j40__u(tls, st, 5))
	}()
	goto __7
__7:
	i++
	goto __6
	goto __8
__8:
	;
	i = 0
__9:
	if !(i < 4) {
		goto __11
	}
	*(*Int8_t)(unsafe.Pointer(m + 4 + 7 + uintptr(i))) = func() int8 {
		if default_wp != 0 {
			return int8(12 + libc.Bool32(i < 1))
		}
		return Int8_t(j40__u(tls, st, 4))
	}()
	goto __10
__10:
	i++
	goto __9
	goto __11
__11:
	;
	*(*Int32_t)(unsafe.Pointer(bp + 12)) = libc.AssignPtrInt32(m+16, j40__u32(tls, st, 0, 0, 1, 0, 2, 4, 18, 8))
__12:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __15
	}
	goto J40__ON_ERROR
__15:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__modular)(unsafe.Pointer(m)).Nb_transforms <= (*J40__limits1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Limits)).Nb_transforms)), int64(0)) != 0) {
		goto __16
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 372))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 372 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 372 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 372 + 3))))
	goto J40__ON_ERROR
__16:
	;
	goto __13
__13:
	if 0 != 0 {
		goto __12
	}
	goto __14
__14:
	;
__17:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __20
	}
	goto J40__ON_ERROR
__20:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(m+24, j40__malloc(tls, uint64(unsafe.Sizeof(J40__transform{}))*Size_t(*(*Int32_t)(unsafe.Pointer(bp + 12)))))) != 0)), int64(0)) != 0) {
		goto __21
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__21:
	;
	goto __18
__18:
	if 0 != 0 {
		goto __17
	}
	goto __19
__19:
	;
	i = 0
__22:
	if !(i < (*J40__modular)(unsafe.Pointer(m)).Nb_transforms) {
		goto __24
	}
	tr = (*J40__modular)(unsafe.Pointer(m)).Transform + uintptr(i)*24

	*(*uint32)(unsafe.Pointer(tr)) = uint32(uint32(j40__u(tls, st, 2)))
	switch *(*uint32)(unsafe.Pointer(tr)) {
	case J40__TR_RCT:
		goto __26

	case J40__TR_PALETTE:
		goto __27

	case J40__TR_SQUEEZE:
		goto __28

	default:
		goto __29
	}
	goto __25

__26:
	begin_c = libc.AssignPtrInt32(tr+4, j40__u32(tls, st, 0, 3, 8, 6, 72, 10, 1096, 13))
	type1 = libc.AssignPtrInt32(tr+8, j40__u32(tls, st, 6, 0, 0, 2, 2, 4, 10, 6))
__30:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __33
	}
	goto J40__ON_ERROR
__33:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(type1 < 42)), int64(0)) != 0) {
		goto __34
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 377))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 377 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 377 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 377 + 3))))
	goto J40__ON_ERROR
__34:
	;
	goto __31
__31:
	if 0 != 0 {
		goto __30
	}
	goto __32
__32:
	;
__35:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __38
	}
	goto J40__ON_ERROR
__38:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(begin_c+3 <= num_channels)), int64(0)) != 0) {
		goto __39
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 382))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 382 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 382 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 382 + 3))))
	goto J40__ON_ERROR
__39:
	;
	goto __36
__36:
	if 0 != 0 {
		goto __35
	}
	goto __37
__37:
	;
__40:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __43
	}
	goto J40__ON_ERROR
__43:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(begin_c >= nb_meta_channels || begin_c+3 <= nb_meta_channels)), int64(0)) != 0) {
		goto __44
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 382))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 382 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 382 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 382 + 3))))
	goto J40__ON_ERROR
__44:
	;
	goto __41
__41:
	if 0 != 0 {
		goto __40
	}
	goto __42
__42:
	;
__45:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __48
	}
	goto J40__ON_ERROR
__48:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(j40__plane_all_equal_sized(tls, *(*uintptr)(unsafe.Pointer(bp))+uintptr(begin_c)*24, *(*uintptr)(unsafe.Pointer(bp))+uintptr(begin_c)*24+uintptr(3)*24) != 0)), int64(0)) != 0) {
		goto __49
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 387))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 387 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 387 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 387 + 3))))
	goto J40__ON_ERROR
__49:
	;
	goto __46
__46:
	if 0 != 0 {
		goto __45
	}
	goto __47
__47:
	;
	goto __25

__27:
	begin_c1 = libc.AssignPtrInt32(tr+4, j40__u32(tls, st, 0, 3, 8, 6, 72, 10, 1096, 13))
	num_c = libc.AssignPtrInt32(tr+8, j40__u32(tls, st, 1, 0, 3, 0, 4, 0, 1, 13))
	end_c = begin_c1 + num_c
	nb_colours = libc.AssignPtrInt32(tr+12, j40__u32(tls, st, 0, 8, 256, 10, 1280, 12, 5376, 16))
	*(*Int32_t)(unsafe.Pointer(tr + 16)) = j40__u32(tls, st, 0, 0, 1, 8, 257, 10, 1281, 16)
	*(*Int32_t)(unsafe.Pointer(tr + 20)) = j40__u(tls, st, 4)
__50:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __53
	}
	goto J40__ON_ERROR
__53:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(*(*Int32_t)(unsafe.Pointer(tr + 20)) < J40__NUM_PRED)), int64(0)) != 0) {
		goto __54
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 392))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 392 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 392 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 392 + 3))))
	goto J40__ON_ERROR
__54:
	;
	goto __51
__51:
	if 0 != 0 {
		goto __50
	}
	goto __52
__52:
	;
__55:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __58
	}
	goto J40__ON_ERROR
__58:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(end_c <= num_channels)), int64(0)) != 0) {
		goto __59
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 397))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 397 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 397 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 397 + 3))))
	goto J40__ON_ERROR
__59:
	;
	goto __56
__56:
	if 0 != 0 {
		goto __55
	}
	goto __57
__57:
	;
	if !(begin_c1 < nb_meta_channels) {
		goto __60
	}
__62:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __65
	}
	goto J40__ON_ERROR
__65:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(end_c <= nb_meta_channels)), int64(0)) != 0) {
		goto __66
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 397))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 397 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 397 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 397 + 3))))
	goto J40__ON_ERROR
__66:
	;
	goto __63
__63:
	if 0 != 0 {
		goto __62
	}
	goto __64
__64:
	;
	nb_meta_channels = nb_meta_channels + (2 - num_c)
	goto __61
__60:
	nb_meta_channels = nb_meta_channels + 1
__61:
	;
__67:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __70
	}
	goto J40__ON_ERROR
__70:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(j40__plane_all_equal_sized(tls, *(*uintptr)(unsafe.Pointer(bp))+uintptr(begin_c1)*24, *(*uintptr)(unsafe.Pointer(bp))+uintptr(end_c)*24) != 0)), int64(0)) != 0) {
		goto __71
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 402))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 402 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 402 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 402 + 3))))
	goto J40__ON_ERROR
__71:
	;
	goto __68
__68:
	if 0 != 0 {
		goto __67
	}
	goto __69
__69:
	;
__72:
	newptr = j40__realloc32(tls, st, *(*uintptr)(unsafe.Pointer(bp)), uint64(unsafe.Sizeof(J40__plane{})), num_channels+1, bp+8)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(newptr != 0)), int64(1)) != 0) {
		goto __75
	}
	*(*uintptr)(unsafe.Pointer(bp)) = newptr
	goto __76
__75:
	goto J40__ON_ERROR
__76:
	;
	goto __73
__73:
	if 0 != 0 {
		goto __72
	}
	goto __74
__74:
	;
	input = *(*J40__plane)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + uintptr(begin_c1)*24))
	libc.Xmemmove(tls, *(*uintptr)(unsafe.Pointer(bp))+uintptr(1)*24, *(*uintptr)(unsafe.Pointer(bp)), uint64(unsafe.Sizeof(J40__plane{}))*Size_t(begin_c1))
	libc.Xmemmove(tls, *(*uintptr)(unsafe.Pointer(bp))+uintptr(begin_c1)*24+uintptr(2)*24, *(*uintptr)(unsafe.Pointer(bp))+uintptr(end_c)*24, uint64(unsafe.Sizeof(J40__plane{}))*Size_t(num_channels-end_c))
	(*J40__plane)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Width = nb_colours
	(*J40__plane)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Height = num_c
	(*J40__plane)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Hshift = int8(0)
	(*J40__plane)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Vshift = int8(-1)
	*(*J40__plane)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + uintptr(begin_c1+1)*24)) = input
	num_channels = num_channels + (2 - num_c)
	goto __25

__28:
	num_sq = j40__u32(tls, st, 0, 0, 1, 4, 9, 6, 41, 8)
	if !(num_sq == 0) {
		goto __77
	}
	*(*int32)(unsafe.Pointer(tr + 4)) = 1
	goto __78
__77:
__79:
	newptr1 = j40__realloc32(tls, st, *(*uintptr)(unsafe.Pointer(m + 24)), uint64(unsafe.Sizeof(J40__transform{})), (*J40__modular)(unsafe.Pointer(m)).Nb_transforms+num_sq-1, bp+12)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(newptr1 != 0)), int64(1)) != 0) {
		goto __82
	}
	*(*uintptr)(unsafe.Pointer(m + 24)) = newptr1
	goto __83
__82:
	goto J40__ON_ERROR
__83:
	;
	goto __80
__80:
	if 0 != 0 {
		goto __79
	}
	goto __81
__81:
	;
	j = 0
__84:
	if !(j < num_sq) {
		goto __86
	}
	tr = (*J40__modular)(unsafe.Pointer(m)).Transform + uintptr(i+j)*24
	*(*uint32)(unsafe.Pointer(tr)) = J40__TR_SQUEEZE
	*(*int32)(unsafe.Pointer(tr + 4)) = 0
	*(*int32)(unsafe.Pointer(tr + 8)) = j40__u(tls, st, 1)
	*(*int32)(unsafe.Pointer(tr + 12)) = j40__u(tls, st, 1)
	*(*Int32_t)(unsafe.Pointer(tr + 16)) = j40__u32(tls, st, 0, 3, 8, 6, 72, 10, 1096, 13)
	*(*Int32_t)(unsafe.Pointer(tr + 20)) = j40__u32(tls, st, 1, 0, 2, 0, 3, 0, 4, 4)
	goto __85
__85:
	j++
	goto __84
	goto __86
__86:
	;
	i = i + (num_sq - 1)
	*(*Int32_t)(unsafe.Pointer(m + 16)) += num_sq - 1
__78:
	;
__87:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 407))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 407 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 407 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 407 + 3))))
	goto J40__ON_ERROR
	goto __88
__88:
	if 0 != 0 {
		goto __87
	}
	goto __89
__89:
	;
	goto __25

__29:
__90:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 437))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 437 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 437 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 437 + 3))))
	goto J40__ON_ERROR
	goto __91
__91:
	if 0 != 0 {
		goto __90
	}
	goto __92
__92:
	;
__25:
	;
__93:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __96
	}
	goto J40__ON_ERROR
__96:
	;
	goto __94
__94:
	if 0 != 0 {
		goto __93
	}
	goto __95
__95:
	;
	goto __23
__23:
	i++
	goto __22
	goto __24
__24:
	;
__97:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __100
	}
	goto J40__ON_ERROR
__100:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(num_channels <= (*J40__limits1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Limits)).Nb_channels_tr)), int64(0)) != 0) {
		goto __101
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 372))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 372 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 372 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 372 + 3))))
	goto J40__ON_ERROR
__101:
	;
	goto __98
__98:
	if 0 != 0 {
		goto __97
	}
	goto __99
__99:
	;
	if !((*J40__modular)(unsafe.Pointer(m)).Use_global_tree != 0) {
		goto __102
	}
	(*J40__modular)(unsafe.Pointer(m)).Tree = global_tree
	libc.Xmemcpy(tls, m+40, global_codespec, uint64(unsafe.Sizeof(J40__code_spec{})))
	goto __103
__102:
	max_tree_size = 1024
	i = 0
__104:
	if !(i < num_channels) {
		goto __106
	}
	max_tree_size = J40__clamp_add32(tls, max_tree_size,
		J40__clamp_mul32(tls, (*J40__plane)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))+uintptr(i)*24)).Width, (*J40__plane)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))+uintptr(i)*24)).Height))
	goto __105
__105:
	i++
	goto __104
	goto __106
__106:
	;
	max_tree_size = J40__min32(tls, int32(1)<<20, max_tree_size)
__107:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__tree(tls, st, max_tree_size, m+32, m+40) != 0)), int64(0)) != 0) {
		goto __110
	}
	goto J40__ON_ERROR
__110:
	;
	goto __108
__108:
	if 0 != 0 {
		goto __107
	}
	goto __109
__109:
	;
__103:
	;
	(*J40__modular)(unsafe.Pointer(m)).Channel = *(*uintptr)(unsafe.Pointer(bp))
	(*J40__modular)(unsafe.Pointer(m)).Num_channels = num_channels
	(*J40__modular)(unsafe.Pointer(m)).Nb_meta_channels = nb_meta_channels
	(*J40__modular)(unsafe.Pointer(m)).Dist_mult = 0
	i = nb_meta_channels
__111:
	if !(i < num_channels) {
		goto __113
	}
	(*J40__modular)(unsafe.Pointer(m)).Dist_mult = J40__max32(tls, (*J40__modular)(unsafe.Pointer(m)).Dist_mult, (*J40__plane)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))+uintptr(i)*24)).Width)
	goto __112
__112:
	i++
	goto __111
	goto __113
__113:
	;
	(*J40__modular)(unsafe.Pointer(m)).Dist_mult = J40__min32(tls, (*J40__modular)(unsafe.Pointer(m)).Dist_mult, int32(1)<<21)
	return J40_err(0)

J40__ON_ERROR:
	j40__free(tls, *(*uintptr)(unsafe.Pointer(bp)))
	j40__free(tls, (*J40__modular)(unsafe.Pointer(m)).Transform)
	if !!((*J40__modular)(unsafe.Pointer(m)).Use_global_tree != 0) {
		goto __114
	}
	j40__free(tls, (*J40__modular)(unsafe.Pointer(m)).Tree)
	j40__free_code_spec(tls, m+40)
__114:
	;
	(*J40__modular)(unsafe.Pointer(m)).Num_channels = 0
	(*J40__modular)(unsafe.Pointer(m)).Channel = uintptr(0)
	(*J40__modular)(unsafe.Pointer(m)).Transform = uintptr(0)
	(*J40__modular)(unsafe.Pointer(m)).Tree = uintptr(0)
	libc.Xmemset(tls, m+40, 0, uint64(unsafe.Sizeof(J40__code_spec{})))
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__allocate_modular(tls *libc.TLS, st uintptr, m uintptr) J40_err {
	var pixel_type Uint8_t
	var i Int32_t
	var c uintptr
	if (*J40__image_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Image)).Modular_16bit_buffers != 0 {
		pixel_type = J40__PLANE_I16
	} else {
		pixel_type = J40__PLANE_I32
	}
	i = 0
__1:
	if !(i < (*J40__modular)(unsafe.Pointer(m)).Num_channels) {
		goto __3
	}
	c = (*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(i)*24
__4:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_plane(tls, st, pixel_type, (*J40__plane)(unsafe.Pointer(c)).Width, (*J40__plane)(unsafe.Pointer(c)).Height, J40__PLANE_FORCE_PAD, c) != 0)), int64(0)) != 0) {
		goto __7
	}
	goto J40__ON_ERROR
__7:
	;
	goto __5
__5:
	if 0 != 0 {
		goto __4
	}
	goto __6
__6:
	;
	goto __2
__2:
	i++
	goto __1
	goto __3
__3:
	;
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__free_modular(tls *libc.TLS, m uintptr) {
	var i Int32_t
	j40__free_code(tls, m+96)
	if !((*J40__modular)(unsafe.Pointer(m)).Use_global_tree != 0) {
		j40__free(tls, (*J40__modular)(unsafe.Pointer(m)).Tree)
		j40__free_code_spec(tls, m+40)
	}
	for i = 0; i < (*J40__modular)(unsafe.Pointer(m)).Num_channels; i++ {
		j40__free_plane(tls, (*J40__modular)(unsafe.Pointer(m)).Channel+uintptr(i)*24)
	}
	j40__free(tls, (*J40__modular)(unsafe.Pointer(m)).Transform)
	j40__free(tls, (*J40__modular)(unsafe.Pointer(m)).Channel)
	(*J40__modular)(unsafe.Pointer(m)).Use_global_tree = 0
	(*J40__modular)(unsafe.Pointer(m)).Tree = uintptr(0)
	libc.Xmemset(tls, m+40, 0, uint64(unsafe.Sizeof(J40__code_spec{})))
	(*J40__modular)(unsafe.Pointer(m)).Transform = uintptr(0)
	(*J40__modular)(unsafe.Pointer(m)).Num_channels = 0
	(*J40__modular)(unsafe.Pointer(m)).Channel = uintptr(0)
}

var sJ40__24DIVP1 = [64]Int32_t{
	0x1000000, 0x800000, 0x555555, 0x400000, 0x333333, 0x2aaaaa, 0x249249, 0x200000,
	0x1c71c7, 0x199999, 0x1745d1, 0x155555, 0x13b13b, 0x124924, 0x111111, 0x100000,
	0xf0f0f, 0xe38e3, 0xd7943, 0xccccc, 0xc30c3, 0xba2e8, 0xb2164, 0xaaaaa,
	0xa3d70, 0x9d89d, 0x97b42, 0x92492, 0x8d3dc, 0x88888, 0x84210, 0x80000,
	0x7c1f0, 0x78787, 0x75075, 0x71c71, 0x6eb3e, 0x6bca1, 0x69069, 0x66666,
	0x63e70, 0x61861, 0x5f417, 0x5d174, 0x5b05b, 0x590b2, 0x57262, 0x55555,
	0x53978, 0x51eb8, 0x50505, 0x4ec4e, 0x4d487, 0x4bda1, 0x4a790, 0x49249,
	0x47dc1, 0x469ee, 0x456c7, 0x44444, 0x4325c, 0x42108, 0x41041, 0x40000,
}

type J40__wp32 = struct {
	Width       Int32_t
	Params      J40__wp_params
	__ccgo_pad1 [1]byte
	Errors      uintptr
	Pred        [5]Int32_t
	Trueerrw    Int32_t
	Trueerrn    Int32_t
	Trueerrnw   Int32_t
	Trueerrne   Int32_t
	__ccgo_pad2 [4]byte
}

type J40__neighbors16 = struct {
	W   Int16_t
	N   Int16_t
	Nw  Int16_t
	Ne  Int16_t
	Nn  Int16_t
	Nee Int16_t
	Ww  Int16_t
	Nww Int16_t
}

func J40__init_neighbors16(tls *libc.TLS, plane uintptr, x Int32_t, y Int32_t) J40__neighbors16 {
	var p J40__neighbors16
	var pixels uintptr = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(plane)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(plane)).Stride_bytes)*Size_t(y))
	}()
	var width Int32_t = (*J40__plane)(unsafe.Pointer(plane)).Width
	var stride Int32_t = (*J40__plane)(unsafe.Pointer(plane)).Stride_bytes >> (int32((*J40__plane)(unsafe.Pointer(plane)).Type) & 31)

	p.W = func() int16 {
		if x > 0 {
			return *(*Int16_t)(unsafe.Pointer(pixels + uintptr(x-1)*2))
		}
		return func() int16 {
			if y > 0 {
				return *(*Int16_t)(unsafe.Pointer(pixels + uintptr(x-stride)*2))
			}
			return int16(0)
		}()
	}()
	p.N = func() int16 {
		if y > 0 {
			return *(*Int16_t)(unsafe.Pointer(pixels + uintptr(x-stride)*2))
		}
		return p.W
	}()
	p.Nw = func() int16 {
		if x > 0 && y > 0 {
			return *(*Int16_t)(unsafe.Pointer(pixels + uintptr(x-1-stride)*2))
		}
		return p.W
	}()
	p.Ne = func() int16 {
		if x+1 < width && y > 0 {
			return *(*Int16_t)(unsafe.Pointer(pixels + uintptr(x+1-stride)*2))
		}
		return p.N
	}()
	p.Nn = func() int16 {
		if y > 1 {
			return *(*Int16_t)(unsafe.Pointer(pixels + uintptr(x-2*stride)*2))
		}
		return p.N
	}()
	p.Nee = func() int16 {
		if x+2 < width && y > 0 {
			return *(*Int16_t)(unsafe.Pointer(pixels + uintptr(x+2-stride)*2))
		}
		return p.Ne
	}()
	p.Ww = func() int16 {
		if x > 1 {
			return *(*Int16_t)(unsafe.Pointer(pixels + uintptr(x-2)*2))
		}
		return p.W
	}()
	p.Nww = func() int16 {
		if x > 1 && y > 0 {
			return *(*Int16_t)(unsafe.Pointer(pixels + uintptr(x-2-stride)*2))
		}
		return p.Ww
	}()
	return p
}

func j40__gradient32(tls *libc.TLS, w Int32_t, n Int32_t, nw Int32_t) Int32_t {
	var lo Int32_t = J40__min32(tls, w, n)
	var hi Int32_t = J40__max32(tls, w, n)
	return J40__min32(tls, J40__max32(tls, lo, w+n-nw), hi)
}

func j40__init_wp32(tls *libc.TLS, st uintptr, params J40__wp_params, width Int32_t, wp uintptr) J40_err {
	var i Int32_t

	(*J40__wp32)(unsafe.Pointer(wp)).Width = width
	(*J40__wp32)(unsafe.Pointer(wp)).Params = params
__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(wp+16, j40__calloc(tls, Size_t(width)*uint64(2), uint64(20)))) != 0)), int64(0)) != 0) {
		goto __5
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__5:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
	i = 0
__6:
	if !(i < 5) {
		goto __8
	}
	*(*Int32_t)(unsafe.Pointer(wp + 24 + uintptr(i)*4)) = 0
	goto __7
__7:
	i++
	goto __6
	goto __8
__8:
	;
	(*J40__wp32)(unsafe.Pointer(wp)).Trueerrw = libc.AssignPtrInt32(wp+48, libc.AssignPtrInt32(wp+52, libc.AssignPtrInt32(wp+56, 0)))
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

// also works when wp is zero-initialized (in which case does nothing)
func j40__wp_before_predict_internal32(tls *libc.TLS, wp uintptr, x Int32_t, y Int32_t, pw Int16_t, pn Int16_t, pnw Int16_t, pne Int16_t, pnn Int16_t) {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var err uintptr
	var nerr uintptr

	var wsum int32
	var sum int32
	var logw Int32_t
	var i Int32_t
	var errw uintptr
	var errn uintptr
	var errnw uintptr
	var errne uintptr
	var errww uintptr
	var errw2 uintptr

	if !(int32((*J40__wp32)(unsafe.Pointer(wp)).Errors) != 0) {
		return
	}

	err = (*J40__wp32)(unsafe.Pointer(wp)).Errors + uintptr(func() int32 {
		if y&1 != 0 {
			return (*J40__wp32)(unsafe.Pointer(wp)).Width
		}
		return 0
	}())*20
	nerr = (*J40__wp32)(unsafe.Pointer(wp)).Errors + uintptr(func() int32 {
		if y&1 != 0 {
			return 0
		}
		return (*J40__wp32)(unsafe.Pointer(wp)).Width
	}())*20

	errw = func() uintptr {
		if x > 0 {
			return err + uintptr(x-1)*20
		}
		return uintptr(unsafe.Pointer(&ZERO))
	}()
	errn = func() uintptr {
		if y > 0 {
			return nerr + uintptr(x)*20
		}
		return uintptr(unsafe.Pointer(&ZERO))
	}()
	if x > 0 && y > 0 {
		errnw = nerr + uintptr(x-1)*20
	} else {
		errnw = errn
	}
	if x+1 < (*J40__wp32)(unsafe.Pointer(wp)).Width && y > 0 {
		errne = nerr + uintptr(x+1)*20
	} else {
		errne = errn
	}
	errww = func() uintptr {
		if x > 1 {
			return err + uintptr(x-2)*20
		}
		return uintptr(unsafe.Pointer(&ZERO))
	}()
	errw2 = func() uintptr {
		if x+1 < (*J40__wp32)(unsafe.Pointer(wp)).Width {
			return uintptr(unsafe.Pointer(&ZERO))
		}
		return errw
	}()

	(*J40__wp32)(unsafe.Pointer(wp)).Trueerrw = func() int32 {
		if x > 0 {
			return *(*int32)(unsafe.Pointer(err + uintptr(x-1)*20 + 4*4))
		}
		return 0
	}()
	(*J40__wp32)(unsafe.Pointer(wp)).Trueerrn = func() int32 {
		if y > 0 {
			return *(*int32)(unsafe.Pointer(nerr + uintptr(x)*20 + 4*4))
		}
		return 0
	}()
	(*J40__wp32)(unsafe.Pointer(wp)).Trueerrnw = func() int32 {
		if x > 0 && y > 0 {
			return *(*int32)(unsafe.Pointer(nerr + uintptr(x-1)*20 + 4*4))
		}
		return (*J40__wp32)(unsafe.Pointer(wp)).Trueerrn
	}()
	(*J40__wp32)(unsafe.Pointer(wp)).Trueerrne = func() int32 {
		if x+1 < (*J40__wp32)(unsafe.Pointer(wp)).Width && y > 0 {
			return *(*int32)(unsafe.Pointer(nerr + uintptr(x+1)*20 + 4*4))
		}
		return (*J40__wp32)(unsafe.Pointer(wp)).Trueerrn
	}()

	*(*Int32_t)(unsafe.Pointer(wp + 24)) = (int32(pw) + int32(pne) - int32(pn)) * 8
	*(*Int32_t)(unsafe.Pointer(wp + 24 + 1*4)) = int32(pn)*8 - ((*J40__wp32)(unsafe.Pointer(wp)).Trueerrw+(*J40__wp32)(unsafe.Pointer(wp)).Trueerrn+(*J40__wp32)(unsafe.Pointer(wp)).Trueerrne)*Int32_t((*J40__wp32)(unsafe.Pointer(wp)).Params.P1)>>5
	*(*Int32_t)(unsafe.Pointer(wp + 24 + 2*4)) = int32(pw)*8 - ((*J40__wp32)(unsafe.Pointer(wp)).Trueerrw+(*J40__wp32)(unsafe.Pointer(wp)).Trueerrn+(*J40__wp32)(unsafe.Pointer(wp)).Trueerrnw)*Int32_t((*J40__wp32)(unsafe.Pointer(wp)).Params.P2)>>5
	*(*Int32_t)(unsafe.Pointer(wp + 24 + 3*4)) = int32(pn)*8 - ((*J40__wp32)(unsafe.Pointer(wp)).Trueerrnw*Int32_t(*(*Int8_t)(unsafe.Pointer(wp + 4 + 2)))+(*J40__wp32)(unsafe.Pointer(wp)).Trueerrn*Int32_t(*(*Int8_t)(unsafe.Pointer(wp + 4 + 2 + 1)))+(*J40__wp32)(unsafe.Pointer(wp)).Trueerrne*Int32_t(*(*Int8_t)(unsafe.Pointer(wp + 4 + 2 + 2)))+(int32(pnn)-int32(pn))*8*int32(*(*Int8_t)(unsafe.Pointer(wp + 4 + 2 + 3)))+(int32(pnw)-int32(pw))*8*int32(*(*Int8_t)(unsafe.Pointer(wp + 4 + 2 + 4))))>>5
	for i = 0; i < 4; i++ {
		var errsum int32 = *(*int32)(unsafe.Pointer(errn + uintptr(i)*4)) + *(*int32)(unsafe.Pointer(errw + uintptr(i)*4)) + *(*int32)(unsafe.Pointer(errnw + uintptr(i)*4)) + *(*int32)(unsafe.Pointer(errww + uintptr(i)*4)) + *(*int32)(unsafe.Pointer(errne + uintptr(i)*4)) + *(*int32)(unsafe.Pointer(errw2 + uintptr(i)*4))
		var shift Int32_t = J40__max32(tls, J40__floor_lg32(tls, uint32(errsum)+uint32(1))-5, 0)

		*(*int32)(unsafe.Pointer(bp + uintptr(i)*4)) = int32(int64(4) + Int64_t(*(*Int8_t)(unsafe.Pointer(wp + 4 + 7 + uintptr(i))))*Int64_t(sJ40__24DIVP1[errsum>>shift])>>shift)
	}
	logw = J40__floor_lg32(tls, uint32(*(*int32)(unsafe.Pointer(bp))+*(*int32)(unsafe.Pointer(bp + 1*4))+*(*int32)(unsafe.Pointer(bp + 2*4))+*(*int32)(unsafe.Pointer(bp + 3*4)))) - 4
	wsum = libc.AssignInt32(&sum, 0)
	for i = 0; i < 4; i++ {
		wsum = wsum + libc.AssignShrPtrInt32(bp+uintptr(i)*4, int(logw))
		sum = sum + *(*Int32_t)(unsafe.Pointer(wp + 24 + uintptr(i)*4))**(*int32)(unsafe.Pointer(bp + uintptr(i)*4))
	}

	*(*Int32_t)(unsafe.Pointer(wp + 24 + 4*4)) = int32((Int64_t(sum) + Int64_t(wsum>>1) - int64(1)) * Int64_t(sJ40__24DIVP1[wsum-1]) >> 24)
	if (*J40__wp32)(unsafe.Pointer(wp)).Trueerrn^(*J40__wp32)(unsafe.Pointer(wp)).Trueerrw|((*J40__wp32)(unsafe.Pointer(wp)).Trueerrn^(*J40__wp32)(unsafe.Pointer(wp)).Trueerrnw) <= 0 {
		var lo int32 = J40__min32(tls, int32(pw), J40__min32(tls, int32(pn), int32(pne))) * 8
		var hi int32 = J40__max32(tls, int32(pw), J40__max32(tls, int32(pn), int32(pne))) * 8
		*(*Int32_t)(unsafe.Pointer(wp + 24 + 4*4)) = J40__min32(tls, J40__max32(tls, lo, *(*Int32_t)(unsafe.Pointer(wp + 24 + 4*4))), hi)
	}
}

var ZERO = [4]int32{0, 0, 0, 0}

func j40__wp_before_predict32(tls *libc.TLS, wp uintptr, x Int32_t, y Int32_t, p uintptr) {
	j40__wp_before_predict_internal32(tls, wp, x, y, (*J40__neighbors16)(unsafe.Pointer(p)).W, (*J40__neighbors16)(unsafe.Pointer(p)).N, (*J40__neighbors16)(unsafe.Pointer(p)).Nw, (*J40__neighbors16)(unsafe.Pointer(p)).Ne, (*J40__neighbors16)(unsafe.Pointer(p)).Nn)
}

func j40__predict32(tls *libc.TLS, st uintptr, pred Int32_t, wp uintptr, p uintptr) Int32_t {
	switch pred {
	case 0:
		return 0
	case 1:
		return Int32_t((*J40__neighbors16)(unsafe.Pointer(p)).W)
	case 2:
		return Int32_t((*J40__neighbors16)(unsafe.Pointer(p)).N)
	case 3:
		return (int32((*J40__neighbors16)(unsafe.Pointer(p)).W) + int32((*J40__neighbors16)(unsafe.Pointer(p)).N)) / 2
	case 4:
		if J40__abs32(tls, int32((*J40__neighbors16)(unsafe.Pointer(p)).N)-int32((*J40__neighbors16)(unsafe.Pointer(p)).Nw)) < J40__abs32(tls, int32((*J40__neighbors16)(unsafe.Pointer(p)).W)-int32((*J40__neighbors16)(unsafe.Pointer(p)).Nw)) {
			return int32((*J40__neighbors16)(unsafe.Pointer(p)).W)
		}
		return int32((*J40__neighbors16)(unsafe.Pointer(p)).N)
	case 5:
		return j40__gradient32(tls, int32((*J40__neighbors16)(unsafe.Pointer(p)).W), int32((*J40__neighbors16)(unsafe.Pointer(p)).N), int32((*J40__neighbors16)(unsafe.Pointer(p)).Nw))
	case 6:
		return (*(*Int32_t)(unsafe.Pointer(wp + 24 + 4*4)) + 3) >> 3
	case 7:
		return Int32_t((*J40__neighbors16)(unsafe.Pointer(p)).Ne)
	case 8:
		return Int32_t((*J40__neighbors16)(unsafe.Pointer(p)).Nw)
	case 9:
		return Int32_t((*J40__neighbors16)(unsafe.Pointer(p)).Ww)
	case 10:
		return (int32((*J40__neighbors16)(unsafe.Pointer(p)).W) + int32((*J40__neighbors16)(unsafe.Pointer(p)).Nw)) / 2
	case 11:
		return (int32((*J40__neighbors16)(unsafe.Pointer(p)).N) + int32((*J40__neighbors16)(unsafe.Pointer(p)).Nw)) / 2
	case 12:
		return (int32((*J40__neighbors16)(unsafe.Pointer(p)).N) + int32((*J40__neighbors16)(unsafe.Pointer(p)).Ne)) / 2
	case 13:
		return (6*int32((*J40__neighbors16)(unsafe.Pointer(p)).N) - 2*int32((*J40__neighbors16)(unsafe.Pointer(p)).Nn) + 7*int32((*J40__neighbors16)(unsafe.Pointer(p)).W) + int32((*J40__neighbors16)(unsafe.Pointer(p)).Ww) + int32((*J40__neighbors16)(unsafe.Pointer(p)).Nee) + 3*int32((*J40__neighbors16)(unsafe.Pointer(p)).Ne) + 8) / 16
	default:
		j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 442))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 442 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 442 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 442 + 3))))
		return 0
	}
	return Int32_t(0)
}

// also works when wp is zero-initialized (in which case does nothing)
func j40__wp_after_predict32(tls *libc.TLS, wp uintptr, x Int32_t, y Int32_t, val Int32_t) {
	if (*J40__wp32)(unsafe.Pointer(wp)).Errors != 0 {
		var err uintptr = (*J40__wp32)(unsafe.Pointer(wp)).Errors + uintptr(func() int32 {
			if y&1 != 0 {
				return (*J40__wp32)(unsafe.Pointer(wp)).Width
			}
			return 0
		}()+x)*20
		var i Int32_t

		for i = 0; i < 4; i++ {
			*(*Int32_t)(unsafe.Pointer(err + uintptr(i)*4)) = (J40__abs32(tls, *(*Int32_t)(unsafe.Pointer(wp + 24 + uintptr(i)*4))-val*8) + 3) >> 3
		}
		*(*Int32_t)(unsafe.Pointer(err + 4*4)) = *(*Int32_t)(unsafe.Pointer(wp + 24 + 4*4)) - val*8
	}
}

// also works when wp is zero-initialized (in which case does nothing)
func j40__reset_wp32(tls *libc.TLS, wp uintptr) {
	var i Int32_t
	if (*J40__wp32)(unsafe.Pointer(wp)).Errors != 0 {
		libc.Xmemset(tls, (*J40__wp32)(unsafe.Pointer(wp)).Errors, 0, Size_t((*J40__wp32)(unsafe.Pointer(wp)).Width)*uint64(2)*Size_t(20))
	}
	for i = 0; i < 5; i++ {
		*(*Int32_t)(unsafe.Pointer(wp + 24 + uintptr(i)*4)) = 0
	}
	(*J40__wp32)(unsafe.Pointer(wp)).Trueerrw = libc.AssignPtrInt32(wp+48, libc.AssignPtrInt32(wp+52, libc.AssignPtrInt32(wp+56, 0)))
}

func j40__free_wp32(tls *libc.TLS, wp uintptr) {
	j40__free(tls, (*J40__wp32)(unsafe.Pointer(wp)).Errors)
	(*J40__wp32)(unsafe.Pointer(wp)).Errors = uintptr(0)
	(*J40__wp32)(unsafe.Pointer(wp)).Width = 0
}

func j40__modular_channel16(tls *libc.TLS, st uintptr, m uintptr, cidx Int32_t, sidx Int64_t) J40_err {
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var c uintptr
	var width Int32_t
	var height Int32_t
	var y Int32_t
	var x Int32_t
	var i Int32_t
	var nrefcmap Int32_t
	var refcmap uintptr

	var lasttree Int32_t
	var use_wp Int32_t
	var refc uintptr
	var rw int32
	var rn int32
	var rnw int32
	var refcidx Int32_t
	var refc1 uintptr
	var n uintptr

	var val int32
	var outpixels uintptr
	c = (*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(cidx)*24
	width = (*J40__plane)(unsafe.Pointer(c)).Width
	height = (*J40__plane)(unsafe.Pointer(c)).Height
	refcmap = uintptr(0)
	*(*J40__wp32)(unsafe.Pointer(bp)) = J40__wp32{}

	lasttree = 0
	use_wp = 0
	i = 0
__1:
	if !(i <= lasttree && !(use_wp != 0)) {
		goto __3
	}
	if !(*(*Int32_t)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Tree + uintptr(i)*16)) < 0) {
		goto __4
	}
	use_wp = use_wp | libc.Bool32(^*(*Int32_t)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Tree + uintptr(i)*16)) == 15)
	lasttree = J40__max32(tls, lasttree,
		i+J40__max32(tls, *(*Int32_t)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Tree + uintptr(i)*16 + 8)), *(*Int32_t)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Tree + uintptr(i)*16 + 12))))
	goto __5
__4:
	use_wp = use_wp | libc.Bool32(*(*Int32_t)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Tree + uintptr(i)*16 + 4)) == 6)
__5:
	;
	goto __2
__2:
	i++
	goto __1
	goto __3
__3:
	;
	if !(use_wp != 0) {
		goto __6
	}
__7:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_wp32(tls, st, (*J40__modular)(unsafe.Pointer(m)).Wp, width, bp) != 0)), int64(0)) != 0) {
		goto __10
	}
	goto J40__ON_ERROR
__10:
	;
	goto __8
__8:
	if 0 != 0 {
		goto __7
	}
	goto __9
__9:
	;
__6:
	;
__11:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __14
	}
	goto J40__ON_ERROR
__14:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignUintptr(&refcmap, j40__malloc(tls, uint64(unsafe.Sizeof(Int32_t(0)))*Size_t(cidx)))) != 0)), int64(0)) != 0) {
		goto __15
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__15:
	;
	goto __12
__12:
	if 0 != 0 {
		goto __11
	}
	goto __13
__13:
	;
	nrefcmap = 0
	i = cidx - 1
__16:
	if !(i >= 0) {
		goto __18
	}
	refc = (*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(i)*24
	if !((*J40__plane)(unsafe.Pointer(c)).Width != (*J40__plane)(unsafe.Pointer(refc)).Width || (*J40__plane)(unsafe.Pointer(c)).Height != (*J40__plane)(unsafe.Pointer(refc)).Height) {
		goto __19
	}
	goto __17
__19:
	;
	if !(int32((*J40__plane)(unsafe.Pointer(c)).Hshift) != int32((*J40__plane)(unsafe.Pointer(refc)).Hshift) || int32((*J40__plane)(unsafe.Pointer(c)).Vshift) != int32((*J40__plane)(unsafe.Pointer(refc)).Vshift)) {
		goto __20
	}
	goto __17
__20:
	;
	*(*Int32_t)(unsafe.Pointer(refcmap + uintptr(libc.PostIncInt32(&nrefcmap, 1))*4)) = i
	goto __17
__17:
	i--
	goto __16
	goto __18
__18:
	;
	y = 0
__21:
	if !(y < height) {
		goto __23
	}
	outpixels = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(c)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(c)).Stride_bytes)*Size_t(y))
	}()
	x = 0
__24:
	if !(x < width) {
		goto __26
	}
	n = (*J40__modular)(unsafe.Pointer(m)).Tree
	*(*J40__neighbors16)(unsafe.Pointer(bp + 64)) = J40__init_neighbors16(tls, c, x, y)

	j40__wp_before_predict32(tls, bp, x, y, bp+64)

__27:
	if !(*(*Int32_t)(unsafe.Pointer(n)) < 0) {
		goto __28
	}

	switch ^*(*Int32_t)(unsafe.Pointer(n)) {
	case 0:
		goto __30
	case 1:
		goto __31
	case 2:
		goto __32
	case 3:
		goto __33
	case 4:
		goto __34
	case 5:
		goto __35
	case 6:
		goto __36
	case 7:
		goto __37
	case 8:
		goto __38
	case 9:
		goto __39
	case 10:
		goto __40
	case 11:
		goto __41
	case 12:
		goto __42
	case 13:
		goto __43
	case 14:
		goto __44
	case 15:
		goto __45
	default:
		goto __46
	}
	goto __29
__30:
	val = cidx
	goto __29
__31:
	val = int32(sidx)
	goto __29
__32:
	val = y
	goto __29
__33:
	val = x
	goto __29
__34:
	val = J40__abs32(tls, int32((*J40__neighbors16)(unsafe.Pointer(bp+64)).N))
	goto __29
__35:
	val = J40__abs32(tls, int32((*J40__neighbors16)(unsafe.Pointer(bp+64)).W))
	goto __29
__36:
	val = int32((*J40__neighbors16)(unsafe.Pointer(bp + 64)).N)
	goto __29
__37:
	val = int32((*J40__neighbors16)(unsafe.Pointer(bp + 64)).W)
	goto __29
__38:
	if x > 0 {
		val = int32((*J40__neighbors16)(unsafe.Pointer(bp+64)).W) - (int32((*J40__neighbors16)(unsafe.Pointer(bp+64)).Ww) + int32((*J40__neighbors16)(unsafe.Pointer(bp+64)).Nw) - int32((*J40__neighbors16)(unsafe.Pointer(bp+64)).Nww))
	} else {
		val = int32((*J40__neighbors16)(unsafe.Pointer(bp + 64)).W)
	}
	goto __29
__39:
	val = int32((*J40__neighbors16)(unsafe.Pointer(bp+64)).W) + int32((*J40__neighbors16)(unsafe.Pointer(bp+64)).N) - int32((*J40__neighbors16)(unsafe.Pointer(bp+64)).Nw)
	goto __29
__40:
	val = int32((*J40__neighbors16)(unsafe.Pointer(bp+64)).W) - int32((*J40__neighbors16)(unsafe.Pointer(bp+64)).Nw)
	goto __29
__41:
	val = int32((*J40__neighbors16)(unsafe.Pointer(bp+64)).Nw) - int32((*J40__neighbors16)(unsafe.Pointer(bp+64)).N)
	goto __29
__42:
	val = int32((*J40__neighbors16)(unsafe.Pointer(bp+64)).N) - int32((*J40__neighbors16)(unsafe.Pointer(bp+64)).Ne)
	goto __29
__43:
	val = int32((*J40__neighbors16)(unsafe.Pointer(bp+64)).N) - int32((*J40__neighbors16)(unsafe.Pointer(bp+64)).Nn)
	goto __29
__44:
	val = int32((*J40__neighbors16)(unsafe.Pointer(bp+64)).W) - int32((*J40__neighbors16)(unsafe.Pointer(bp+64)).Ww)
	goto __29
__45:
	val = (*J40__wp32)(unsafe.Pointer(bp)).Trueerrw
	if !(J40__abs32(tls, val) < J40__abs32(tls, (*J40__wp32)(unsafe.Pointer(bp)).Trueerrn)) {
		goto __47
	}
	val = (*J40__wp32)(unsafe.Pointer(bp)).Trueerrn
__47:
	;
	if !(J40__abs32(tls, val) < J40__abs32(tls, (*J40__wp32)(unsafe.Pointer(bp)).Trueerrnw)) {
		goto __48
	}
	val = (*J40__wp32)(unsafe.Pointer(bp)).Trueerrnw
__48:
	;
	if !(J40__abs32(tls, val) < J40__abs32(tls, (*J40__wp32)(unsafe.Pointer(bp)).Trueerrne)) {
		goto __49
	}
	val = (*J40__wp32)(unsafe.Pointer(bp)).Trueerrne
__49:
	;
	goto __29
__46:
	refcidx = (^*(*Int32_t)(unsafe.Pointer(n)) - 16) / 4
__50:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __53
	}
	goto J40__ON_ERROR
__53:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(refcidx < nrefcmap)), int64(0)) != 0) {
		goto __54
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 447))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 447 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 447 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 447 + 3))))
	goto J40__ON_ERROR
__54:
	;
	goto __51
__51:
	if 0 != 0 {
		goto __50
	}
	goto __52
__52:
	;
	refc1 = (*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(*(*Int32_t)(unsafe.Pointer(refcmap + uintptr(refcidx)*4)))*24

	val = int32(*(*Int16_t)(unsafe.Pointer(func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(refc1)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(refc1)).Stride_bytes)*Size_t(y))
	}() + uintptr(x)*2)))
	if !(^*(*Int32_t)(unsafe.Pointer(n))&2 != 0) {
		goto __55
	}
	if x > 0 {
		rw = int32(*(*Int16_t)(unsafe.Pointer(func() uintptr {
			return uintptr((*J40__plane)(unsafe.Pointer(refc1)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(refc1)).Stride_bytes)*Size_t(y))
		}() + uintptr(x-1)*2)))
	} else {
		rw = 0
	}
	if y > 0 {
		rn = int32(*(*Int16_t)(unsafe.Pointer(func() uintptr {
			return uintptr((*J40__plane)(unsafe.Pointer(refc1)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(refc1)).Stride_bytes)*Size_t(y-1))
		}() + uintptr(x)*2)))
	} else {
		rn = rw
	}
	if x > 0 && y > 0 {
		rnw = int32(*(*Int16_t)(unsafe.Pointer(func() uintptr {
			return uintptr((*J40__plane)(unsafe.Pointer(refc1)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(refc1)).Stride_bytes)*Size_t(y-1))
		}() + uintptr(x-1)*2)))
	} else {
		rnw = rw
	}
	val = val - j40__gradient32(tls, rw, rn, rnw)
__55:
	;
	if !(^*(*Int32_t)(unsafe.Pointer(n))&1 != 0) {
		goto __56
	}
	val = J40__abs32(tls, val)
__56:
	;
	goto __29
__29:
	;
	n += 16 * func() uintptr {
		if val > *(*Int32_t)(unsafe.Pointer(n + 4)) {
			return uintptr(*(*Int32_t)(unsafe.Pointer(n + 8)))
		}
		return uintptr(*(*Int32_t)(unsafe.Pointer(n + 12)))
	}()
	goto __27
__28:
	;
	val = j40__code(tls, st, *(*Int32_t)(unsafe.Pointer(n)), (*J40__modular)(unsafe.Pointer(m)).Dist_mult, m+96)

	val = J40__unpack_signed(tls, val)**(*Int32_t)(unsafe.Pointer(n + 12)) + *(*Int32_t)(unsafe.Pointer(n + 8))
	val = val + j40__predict32(tls, st, *(*Int32_t)(unsafe.Pointer(n + 4)), bp, bp+64)
__57:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __60
	}
	goto J40__ON_ERROR
__60:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(-32767-1 <= val && val <= 32767)), int64(0)) != 0) {
		goto __61
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 452))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 452 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 452 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 452 + 3))))
	goto J40__ON_ERROR
__61:
	;
	goto __58
__58:
	if 0 != 0 {
		goto __57
	}
	goto __59
__59:
	;
	*(*int16)(unsafe.Pointer(outpixels + uintptr(x)*2)) = int16(val)
	j40__wp_after_predict32(tls, bp, x, y, val)
	goto __25
__25:
	x++
	goto __24
	goto __26
__26:
	;
	goto __22
__22:
	y++
	goto __21
	goto __23
__23:
	;
	j40__free_wp32(tls, bp)
	j40__free(tls, refcmap)
	return J40_err(0)

J40__ON_ERROR:
	j40__free_wp32(tls, bp)
	j40__free(tls, refcmap)
	j40__free_plane(tls, c)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

type J40__wp64 = struct {
	Width       Int32_t
	Params      J40__wp_params
	__ccgo_pad1 [1]byte
	Errors      uintptr
	Pred        [5]Int64_t
	Trueerrw    Int64_t
	Trueerrn    Int64_t
	Trueerrnw   Int64_t
	Trueerrne   Int64_t
}

type J40__neighbors32 = struct {
	W   Int32_t
	N   Int32_t
	Nw  Int32_t
	Ne  Int32_t
	Nn  Int32_t
	Nee Int32_t
	Ww  Int32_t
	Nww Int32_t
}

func J40__init_neighbors32(tls *libc.TLS, plane uintptr, x Int32_t, y Int32_t) J40__neighbors32 {
	var p J40__neighbors32
	var pixels uintptr = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(plane)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(plane)).Stride_bytes)*Size_t(y))
	}()
	var width Int32_t = (*J40__plane)(unsafe.Pointer(plane)).Width
	var stride Int32_t = (*J40__plane)(unsafe.Pointer(plane)).Stride_bytes >> (int32((*J40__plane)(unsafe.Pointer(plane)).Type) & 31)

	p.W = func() int32 {
		if x > 0 {
			return *(*Int32_t)(unsafe.Pointer(pixels + uintptr(x-1)*4))
		}
		return func() int32 {
			if y > 0 {
				return *(*Int32_t)(unsafe.Pointer(pixels + uintptr(x-stride)*4))
			}
			return 0
		}()
	}()
	p.N = func() int32 {
		if y > 0 {
			return *(*Int32_t)(unsafe.Pointer(pixels + uintptr(x-stride)*4))
		}
		return p.W
	}()
	p.Nw = func() int32 {
		if x > 0 && y > 0 {
			return *(*Int32_t)(unsafe.Pointer(pixels + uintptr(x-1-stride)*4))
		}
		return p.W
	}()
	p.Ne = func() int32 {
		if x+1 < width && y > 0 {
			return *(*Int32_t)(unsafe.Pointer(pixels + uintptr(x+1-stride)*4))
		}
		return p.N
	}()
	p.Nn = func() int32 {
		if y > 1 {
			return *(*Int32_t)(unsafe.Pointer(pixels + uintptr(x-2*stride)*4))
		}
		return p.N
	}()
	p.Nee = func() int32 {
		if x+2 < width && y > 0 {
			return *(*Int32_t)(unsafe.Pointer(pixels + uintptr(x+2-stride)*4))
		}
		return p.Ne
	}()
	p.Ww = func() int32 {
		if x > 1 {
			return *(*Int32_t)(unsafe.Pointer(pixels + uintptr(x-2)*4))
		}
		return p.W
	}()
	p.Nww = func() int32 {
		if x > 1 && y > 0 {
			return *(*Int32_t)(unsafe.Pointer(pixels + uintptr(x-2-stride)*4))
		}
		return p.Ww
	}()
	return p
}

func j40__gradient64(tls *libc.TLS, w Int64_t, n Int64_t, nw Int64_t) Int64_t {
	var lo Int64_t = J40__min64(tls, w, n)
	var hi Int64_t = J40__max64(tls, w, n)
	return J40__min64(tls, J40__max64(tls, lo, w+n-nw), hi)
}

func j40__init_wp64(tls *libc.TLS, st uintptr, params J40__wp_params, width Int32_t, wp uintptr) J40_err {
	var i Int32_t

	(*J40__wp64)(unsafe.Pointer(wp)).Width = width
	(*J40__wp64)(unsafe.Pointer(wp)).Params = params
__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(wp+16, j40__calloc(tls, Size_t(width)*uint64(2), uint64(40)))) != 0)), int64(0)) != 0) {
		goto __5
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__5:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
	i = 0
__6:
	if !(i < 5) {
		goto __8
	}
	*(*Int64_t)(unsafe.Pointer(wp + 24 + uintptr(i)*8)) = int64(0)
	goto __7
__7:
	i++
	goto __6
	goto __8
__8:
	;
	(*J40__wp64)(unsafe.Pointer(wp)).Trueerrw = libc.AssignPtrInt64(wp+72, libc.AssignPtrInt64(wp+80, libc.AssignPtrInt64(wp+88, int64(0))))
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

// also works when wp is zero-initialized (in which case does nothing)
func j40__wp_before_predict_internal64(tls *libc.TLS, wp uintptr, x Int32_t, y Int32_t, pw Int32_t, pn Int32_t, pnw Int32_t, pne Int32_t, pnn Int32_t) {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var err uintptr
	var nerr uintptr

	var wsum int64
	var sum int64
	var logw Int32_t
	var i Int32_t
	var errw uintptr
	var errn uintptr
	var errnw uintptr
	var errne uintptr
	var errww uintptr
	var errw2 uintptr

	if !(int32((*J40__wp64)(unsafe.Pointer(wp)).Errors) != 0) {
		return
	}

	err = (*J40__wp64)(unsafe.Pointer(wp)).Errors + uintptr(func() int32 {
		if y&1 != 0 {
			return (*J40__wp64)(unsafe.Pointer(wp)).Width
		}
		return 0
	}())*40
	nerr = (*J40__wp64)(unsafe.Pointer(wp)).Errors + uintptr(func() int32 {
		if y&1 != 0 {
			return 0
		}
		return (*J40__wp64)(unsafe.Pointer(wp)).Width
	}())*40

	errw = func() uintptr {
		if x > 0 {
			return err + uintptr(x-1)*40
		}
		return uintptr(unsafe.Pointer(&ZERO1))
	}()
	errn = func() uintptr {
		if y > 0 {
			return nerr + uintptr(x)*40
		}
		return uintptr(unsafe.Pointer(&ZERO1))
	}()
	if x > 0 && y > 0 {
		errnw = nerr + uintptr(x-1)*40
	} else {
		errnw = errn
	}
	if x+1 < (*J40__wp64)(unsafe.Pointer(wp)).Width && y > 0 {
		errne = nerr + uintptr(x+1)*40
	} else {
		errne = errn
	}
	errww = func() uintptr {
		if x > 1 {
			return err + uintptr(x-2)*40
		}
		return uintptr(unsafe.Pointer(&ZERO1))
	}()
	errw2 = func() uintptr {
		if x+1 < (*J40__wp64)(unsafe.Pointer(wp)).Width {
			return uintptr(unsafe.Pointer(&ZERO1))
		}
		return errw
	}()

	(*J40__wp64)(unsafe.Pointer(wp)).Trueerrw = func() int64 {
		if x > 0 {
			return *(*int64)(unsafe.Pointer(err + uintptr(x-1)*40 + 4*8))
		}
		return int64(0)
	}()
	(*J40__wp64)(unsafe.Pointer(wp)).Trueerrn = func() int64 {
		if y > 0 {
			return *(*int64)(unsafe.Pointer(nerr + uintptr(x)*40 + 4*8))
		}
		return int64(0)
	}()
	(*J40__wp64)(unsafe.Pointer(wp)).Trueerrnw = func() int64 {
		if x > 0 && y > 0 {
			return *(*int64)(unsafe.Pointer(nerr + uintptr(x-1)*40 + 4*8))
		}
		return (*J40__wp64)(unsafe.Pointer(wp)).Trueerrn
	}()
	(*J40__wp64)(unsafe.Pointer(wp)).Trueerrne = func() int64 {
		if x+1 < (*J40__wp64)(unsafe.Pointer(wp)).Width && y > 0 {
			return *(*int64)(unsafe.Pointer(nerr + uintptr(x+1)*40 + 4*8))
		}
		return (*J40__wp64)(unsafe.Pointer(wp)).Trueerrn
	}()

	*(*Int64_t)(unsafe.Pointer(wp + 24)) = Int64_t((pw + pne - pn) * 8)
	*(*Int64_t)(unsafe.Pointer(wp + 24 + 1*8)) = Int64_t(pn*8) - ((*J40__wp64)(unsafe.Pointer(wp)).Trueerrw+(*J40__wp64)(unsafe.Pointer(wp)).Trueerrn+(*J40__wp64)(unsafe.Pointer(wp)).Trueerrne)*Int64_t((*J40__wp64)(unsafe.Pointer(wp)).Params.P1)>>5
	*(*Int64_t)(unsafe.Pointer(wp + 24 + 2*8)) = Int64_t(pw*8) - ((*J40__wp64)(unsafe.Pointer(wp)).Trueerrw+(*J40__wp64)(unsafe.Pointer(wp)).Trueerrn+(*J40__wp64)(unsafe.Pointer(wp)).Trueerrnw)*Int64_t((*J40__wp64)(unsafe.Pointer(wp)).Params.P2)>>5
	*(*Int64_t)(unsafe.Pointer(wp + 24 + 3*8)) = Int64_t(pn*8) - ((*J40__wp64)(unsafe.Pointer(wp)).Trueerrnw*Int64_t(*(*Int8_t)(unsafe.Pointer(wp + 4 + 2)))+(*J40__wp64)(unsafe.Pointer(wp)).Trueerrn*Int64_t(*(*Int8_t)(unsafe.Pointer(wp + 4 + 2 + 1)))+(*J40__wp64)(unsafe.Pointer(wp)).Trueerrne*Int64_t(*(*Int8_t)(unsafe.Pointer(wp + 4 + 2 + 2)))+Int64_t((pnn-pn)*8*Int32_t(*(*Int8_t)(unsafe.Pointer(wp + 4 + 2 + 3))))+Int64_t((pnw-pw)*8*Int32_t(*(*Int8_t)(unsafe.Pointer(wp + 4 + 2 + 4)))))>>5
	for i = 0; i < 4; i++ {
		var errsum int64 = *(*int64)(unsafe.Pointer(errn + uintptr(i)*8)) + *(*int64)(unsafe.Pointer(errw + uintptr(i)*8)) + *(*int64)(unsafe.Pointer(errnw + uintptr(i)*8)) + *(*int64)(unsafe.Pointer(errww + uintptr(i)*8)) + *(*int64)(unsafe.Pointer(errne + uintptr(i)*8)) + *(*int64)(unsafe.Pointer(errw2 + uintptr(i)*8))
		var shift Int32_t = J40__max32(tls, J40__floor_lg64(tls, uint64(errsum)+uint64(1))-5, 0)

		*(*int64)(unsafe.Pointer(bp + uintptr(i)*8)) = int64(4) + Int64_t(*(*Int8_t)(unsafe.Pointer(wp + 4 + 7 + uintptr(i))))*Int64_t(sJ40__24DIVP1[errsum>>shift])>>shift
	}
	logw = J40__floor_lg64(tls, uint64(*(*int64)(unsafe.Pointer(bp))+*(*int64)(unsafe.Pointer(bp + 1*8))+*(*int64)(unsafe.Pointer(bp + 2*8))+*(*int64)(unsafe.Pointer(bp + 3*8)))) - 4
	wsum = libc.AssignInt64(&sum, int64(0))
	for i = 0; i < 4; i++ {
		wsum = wsum + libc.AssignShrPtrInt64(bp+uintptr(i)*8, int(int64(logw)))
		sum = sum + *(*Int64_t)(unsafe.Pointer(wp + 24 + uintptr(i)*8))**(*int64)(unsafe.Pointer(bp + uintptr(i)*8))
	}

	*(*Int64_t)(unsafe.Pointer(wp + 24 + 4*8)) = (sum + wsum>>1 - int64(1)) * Int64_t(sJ40__24DIVP1[wsum-int64(1)]) >> 24
	if (*J40__wp64)(unsafe.Pointer(wp)).Trueerrn^(*J40__wp64)(unsafe.Pointer(wp)).Trueerrw|((*J40__wp64)(unsafe.Pointer(wp)).Trueerrn^(*J40__wp64)(unsafe.Pointer(wp)).Trueerrnw) <= int64(0) {
		var lo int64 = J40__min64(tls, int64(pw), J40__min64(tls, int64(pn), int64(pne))) * int64(8)
		var hi int64 = J40__max64(tls, int64(pw), J40__max64(tls, int64(pn), int64(pne))) * int64(8)
		*(*Int64_t)(unsafe.Pointer(wp + 24 + 4*8)) = J40__min64(tls, J40__max64(tls, lo, *(*Int64_t)(unsafe.Pointer(wp + 24 + 4*8))), hi)
	}
}

var ZERO1 = [4]int64{int64(0), int64(0), int64(0), int64(0)}

func j40__wp_before_predict64(tls *libc.TLS, wp uintptr, x Int32_t, y Int32_t, p uintptr) {
	j40__wp_before_predict_internal64(tls, wp, x, y, (*J40__neighbors32)(unsafe.Pointer(p)).W, (*J40__neighbors32)(unsafe.Pointer(p)).N, (*J40__neighbors32)(unsafe.Pointer(p)).Nw, (*J40__neighbors32)(unsafe.Pointer(p)).Ne, (*J40__neighbors32)(unsafe.Pointer(p)).Nn)
}

func j40__predict64(tls *libc.TLS, st uintptr, pred Int32_t, wp uintptr, p uintptr) Int64_t {
	switch pred {
	case 0:
		return int64(0)
	case 1:
		return Int64_t((*J40__neighbors32)(unsafe.Pointer(p)).W)
	case 2:
		return Int64_t((*J40__neighbors32)(unsafe.Pointer(p)).N)
	case 3:
		return Int64_t(((*J40__neighbors32)(unsafe.Pointer(p)).W + (*J40__neighbors32)(unsafe.Pointer(p)).N) / 2)
	case 4:
		if J40__abs64(tls, int64((*J40__neighbors32)(unsafe.Pointer(p)).N-(*J40__neighbors32)(unsafe.Pointer(p)).Nw)) < J40__abs64(tls, int64((*J40__neighbors32)(unsafe.Pointer(p)).W-(*J40__neighbors32)(unsafe.Pointer(p)).Nw)) {
			return int64((*J40__neighbors32)(unsafe.Pointer(p)).W)
		}
		return int64((*J40__neighbors32)(unsafe.Pointer(p)).N)
	case 5:
		return j40__gradient64(tls, int64((*J40__neighbors32)(unsafe.Pointer(p)).W), int64((*J40__neighbors32)(unsafe.Pointer(p)).N), int64((*J40__neighbors32)(unsafe.Pointer(p)).Nw))
	case 6:
		return (*(*Int64_t)(unsafe.Pointer(wp + 24 + 4*8)) + int64(3)) >> 3
	case 7:
		return Int64_t((*J40__neighbors32)(unsafe.Pointer(p)).Ne)
	case 8:
		return Int64_t((*J40__neighbors32)(unsafe.Pointer(p)).Nw)
	case 9:
		return Int64_t((*J40__neighbors32)(unsafe.Pointer(p)).Ww)
	case 10:
		return Int64_t(((*J40__neighbors32)(unsafe.Pointer(p)).W + (*J40__neighbors32)(unsafe.Pointer(p)).Nw) / 2)
	case 11:
		return Int64_t(((*J40__neighbors32)(unsafe.Pointer(p)).N + (*J40__neighbors32)(unsafe.Pointer(p)).Nw) / 2)
	case 12:
		return Int64_t(((*J40__neighbors32)(unsafe.Pointer(p)).N + (*J40__neighbors32)(unsafe.Pointer(p)).Ne) / 2)
	case 13:
		return Int64_t((6*(*J40__neighbors32)(unsafe.Pointer(p)).N - 2*(*J40__neighbors32)(unsafe.Pointer(p)).Nn + 7*(*J40__neighbors32)(unsafe.Pointer(p)).W + (*J40__neighbors32)(unsafe.Pointer(p)).Ww + (*J40__neighbors32)(unsafe.Pointer(p)).Nee + 3*(*J40__neighbors32)(unsafe.Pointer(p)).Ne + 8) / 16)
	default:
		j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 442))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 442 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 442 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 442 + 3))))
		return 0
	}
	return Int64_t(0)
}

// also works when wp is zero-initialized (in which case does nothing)
func j40__wp_after_predict64(tls *libc.TLS, wp uintptr, x Int32_t, y Int32_t, val Int64_t) {
	if (*J40__wp64)(unsafe.Pointer(wp)).Errors != 0 {
		var err uintptr = (*J40__wp64)(unsafe.Pointer(wp)).Errors + uintptr(func() int32 {
			if y&1 != 0 {
				return (*J40__wp64)(unsafe.Pointer(wp)).Width
			}
			return 0
		}()+x)*40
		var i Int32_t

		for i = 0; i < 4; i++ {
			*(*Int64_t)(unsafe.Pointer(err + uintptr(i)*8)) = (J40__abs64(tls, *(*Int64_t)(unsafe.Pointer(wp + 24 + uintptr(i)*8))-val*int64(8)) + int64(3)) >> 3
		}
		*(*Int64_t)(unsafe.Pointer(err + 4*8)) = *(*Int64_t)(unsafe.Pointer(wp + 24 + 4*8)) - val*int64(8)
	}
}

// also works when wp is zero-initialized (in which case does nothing)
func j40__reset_wp64(tls *libc.TLS, wp uintptr) {
	var i Int32_t
	if (*J40__wp64)(unsafe.Pointer(wp)).Errors != 0 {
		libc.Xmemset(tls, (*J40__wp64)(unsafe.Pointer(wp)).Errors, 0, Size_t((*J40__wp64)(unsafe.Pointer(wp)).Width)*uint64(2)*Size_t(40))
	}
	for i = 0; i < 5; i++ {
		*(*Int64_t)(unsafe.Pointer(wp + 24 + uintptr(i)*8)) = int64(0)
	}
	(*J40__wp64)(unsafe.Pointer(wp)).Trueerrw = libc.AssignPtrInt64(wp+72, libc.AssignPtrInt64(wp+80, libc.AssignPtrInt64(wp+88, int64(0))))
}

func j40__free_wp64(tls *libc.TLS, wp uintptr) {
	j40__free(tls, (*J40__wp64)(unsafe.Pointer(wp)).Errors)
	(*J40__wp64)(unsafe.Pointer(wp)).Errors = uintptr(0)
	(*J40__wp64)(unsafe.Pointer(wp)).Width = 0
}

func j40__modular_channel32(tls *libc.TLS, st uintptr, m uintptr, cidx Int32_t, sidx Int64_t) J40_err {
	bp := tls.Alloc(128)
	defer tls.Free(128)

	var c uintptr
	var width Int32_t
	var height Int32_t
	var y Int32_t
	var x Int32_t
	var i Int32_t
	var nrefcmap Int32_t
	var refcmap uintptr

	var lasttree Int32_t
	var use_wp Int32_t
	var refc uintptr
	var rw int64
	var rn int64
	var rnw int64
	var refcidx Int32_t
	var refc1 uintptr
	var n uintptr

	var val int64
	var outpixels uintptr
	c = (*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(cidx)*24
	width = (*J40__plane)(unsafe.Pointer(c)).Width
	height = (*J40__plane)(unsafe.Pointer(c)).Height
	refcmap = uintptr(0)
	*(*J40__wp64)(unsafe.Pointer(bp)) = J40__wp64{}

	lasttree = 0
	use_wp = 0
	i = 0
__1:
	if !(i <= lasttree && !(use_wp != 0)) {
		goto __3
	}
	if !(*(*Int32_t)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Tree + uintptr(i)*16)) < 0) {
		goto __4
	}
	use_wp = use_wp | libc.Bool32(^*(*Int32_t)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Tree + uintptr(i)*16)) == 15)
	lasttree = J40__max32(tls, lasttree,
		i+J40__max32(tls, *(*Int32_t)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Tree + uintptr(i)*16 + 8)), *(*Int32_t)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Tree + uintptr(i)*16 + 12))))
	goto __5
__4:
	use_wp = use_wp | libc.Bool32(*(*Int32_t)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Tree + uintptr(i)*16 + 4)) == 6)
__5:
	;
	goto __2
__2:
	i++
	goto __1
	goto __3
__3:
	;
	if !(use_wp != 0) {
		goto __6
	}
__7:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_wp64(tls, st, (*J40__modular)(unsafe.Pointer(m)).Wp, width, bp) != 0)), int64(0)) != 0) {
		goto __10
	}
	goto J40__ON_ERROR
__10:
	;
	goto __8
__8:
	if 0 != 0 {
		goto __7
	}
	goto __9
__9:
	;
__6:
	;
__11:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __14
	}
	goto J40__ON_ERROR
__14:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignUintptr(&refcmap, j40__malloc(tls, uint64(unsafe.Sizeof(Int32_t(0)))*Size_t(cidx)))) != 0)), int64(0)) != 0) {
		goto __15
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__15:
	;
	goto __12
__12:
	if 0 != 0 {
		goto __11
	}
	goto __13
__13:
	;
	nrefcmap = 0
	i = cidx - 1
__16:
	if !(i >= 0) {
		goto __18
	}
	refc = (*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(i)*24
	if !((*J40__plane)(unsafe.Pointer(c)).Width != (*J40__plane)(unsafe.Pointer(refc)).Width || (*J40__plane)(unsafe.Pointer(c)).Height != (*J40__plane)(unsafe.Pointer(refc)).Height) {
		goto __19
	}
	goto __17
__19:
	;
	if !(int32((*J40__plane)(unsafe.Pointer(c)).Hshift) != int32((*J40__plane)(unsafe.Pointer(refc)).Hshift) || int32((*J40__plane)(unsafe.Pointer(c)).Vshift) != int32((*J40__plane)(unsafe.Pointer(refc)).Vshift)) {
		goto __20
	}
	goto __17
__20:
	;
	*(*Int32_t)(unsafe.Pointer(refcmap + uintptr(libc.PostIncInt32(&nrefcmap, 1))*4)) = i
	goto __17
__17:
	i--
	goto __16
	goto __18
__18:
	;
	y = 0
__21:
	if !(y < height) {
		goto __23
	}
	outpixels = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(c)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(c)).Stride_bytes)*Size_t(y))
	}()
	x = 0
__24:
	if !(x < width) {
		goto __26
	}
	n = (*J40__modular)(unsafe.Pointer(m)).Tree
	*(*J40__neighbors32)(unsafe.Pointer(bp + 96)) = J40__init_neighbors32(tls, c, x, y)

	j40__wp_before_predict64(tls, bp, x, y, bp+96)

__27:
	if !(*(*Int32_t)(unsafe.Pointer(n)) < 0) {
		goto __28
	}

	switch ^*(*Int32_t)(unsafe.Pointer(n)) {
	case 0:
		goto __30
	case 1:
		goto __31
	case 2:
		goto __32
	case 3:
		goto __33
	case 4:
		goto __34
	case 5:
		goto __35
	case 6:
		goto __36
	case 7:
		goto __37
	case 8:
		goto __38
	case 9:
		goto __39
	case 10:
		goto __40
	case 11:
		goto __41
	case 12:
		goto __42
	case 13:
		goto __43
	case 14:
		goto __44
	case 15:
		goto __45
	default:
		goto __46
	}
	goto __29
__30:
	val = int64(cidx)
	goto __29
__31:
	val = sidx
	goto __29
__32:
	val = int64(y)
	goto __29
__33:
	val = int64(x)
	goto __29
__34:
	val = J40__abs64(tls, int64((*J40__neighbors32)(unsafe.Pointer(bp+96)).N))
	goto __29
__35:
	val = J40__abs64(tls, int64((*J40__neighbors32)(unsafe.Pointer(bp+96)).W))
	goto __29
__36:
	val = int64((*J40__neighbors32)(unsafe.Pointer(bp + 96)).N)
	goto __29
__37:
	val = int64((*J40__neighbors32)(unsafe.Pointer(bp + 96)).W)
	goto __29
__38:
	if x > 0 {
		val = int64((*J40__neighbors32)(unsafe.Pointer(bp+96)).W - ((*J40__neighbors32)(unsafe.Pointer(bp+96)).Ww + (*J40__neighbors32)(unsafe.Pointer(bp+96)).Nw - (*J40__neighbors32)(unsafe.Pointer(bp+96)).Nww))
	} else {
		val = int64((*J40__neighbors32)(unsafe.Pointer(bp + 96)).W)
	}
	goto __29
__39:
	val = int64((*J40__neighbors32)(unsafe.Pointer(bp+96)).W + (*J40__neighbors32)(unsafe.Pointer(bp+96)).N - (*J40__neighbors32)(unsafe.Pointer(bp+96)).Nw)
	goto __29
__40:
	val = int64((*J40__neighbors32)(unsafe.Pointer(bp+96)).W - (*J40__neighbors32)(unsafe.Pointer(bp+96)).Nw)
	goto __29
__41:
	val = int64((*J40__neighbors32)(unsafe.Pointer(bp+96)).Nw - (*J40__neighbors32)(unsafe.Pointer(bp+96)).N)
	goto __29
__42:
	val = int64((*J40__neighbors32)(unsafe.Pointer(bp+96)).N - (*J40__neighbors32)(unsafe.Pointer(bp+96)).Ne)
	goto __29
__43:
	val = int64((*J40__neighbors32)(unsafe.Pointer(bp+96)).N - (*J40__neighbors32)(unsafe.Pointer(bp+96)).Nn)
	goto __29
__44:
	val = int64((*J40__neighbors32)(unsafe.Pointer(bp+96)).W - (*J40__neighbors32)(unsafe.Pointer(bp+96)).Ww)
	goto __29
__45:
	val = (*J40__wp64)(unsafe.Pointer(bp)).Trueerrw
	if !(J40__abs64(tls, val) < J40__abs64(tls, (*J40__wp64)(unsafe.Pointer(bp)).Trueerrn)) {
		goto __47
	}
	val = (*J40__wp64)(unsafe.Pointer(bp)).Trueerrn
__47:
	;
	if !(J40__abs64(tls, val) < J40__abs64(tls, (*J40__wp64)(unsafe.Pointer(bp)).Trueerrnw)) {
		goto __48
	}
	val = (*J40__wp64)(unsafe.Pointer(bp)).Trueerrnw
__48:
	;
	if !(J40__abs64(tls, val) < J40__abs64(tls, (*J40__wp64)(unsafe.Pointer(bp)).Trueerrne)) {
		goto __49
	}
	val = (*J40__wp64)(unsafe.Pointer(bp)).Trueerrne
__49:
	;
	goto __29
__46:
	refcidx = (^*(*Int32_t)(unsafe.Pointer(n)) - 16) / 4
__50:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __53
	}
	goto J40__ON_ERROR
__53:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(refcidx < nrefcmap)), int64(0)) != 0) {
		goto __54
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 447))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 447 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 447 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 447 + 3))))
	goto J40__ON_ERROR
__54:
	;
	goto __51
__51:
	if 0 != 0 {
		goto __50
	}
	goto __52
__52:
	;
	refc1 = (*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(*(*Int32_t)(unsafe.Pointer(refcmap + uintptr(refcidx)*4)))*24

	val = int64(*(*Int32_t)(unsafe.Pointer(func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(refc1)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(refc1)).Stride_bytes)*Size_t(y))
	}() + uintptr(x)*4)))
	if !(^*(*Int32_t)(unsafe.Pointer(n))&2 != 0) {
		goto __55
	}
	if x > 0 {
		rw = int64(*(*Int32_t)(unsafe.Pointer(func() uintptr {
			return uintptr((*J40__plane)(unsafe.Pointer(refc1)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(refc1)).Stride_bytes)*Size_t(y))
		}() + uintptr(x-1)*4)))
	} else {
		rw = int64(0)
	}
	if y > 0 {
		rn = int64(*(*Int32_t)(unsafe.Pointer(func() uintptr {
			return uintptr((*J40__plane)(unsafe.Pointer(refc1)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(refc1)).Stride_bytes)*Size_t(y-1))
		}() + uintptr(x)*4)))
	} else {
		rn = rw
	}
	if x > 0 && y > 0 {
		rnw = int64(*(*Int32_t)(unsafe.Pointer(func() uintptr {
			return uintptr((*J40__plane)(unsafe.Pointer(refc1)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(refc1)).Stride_bytes)*Size_t(y-1))
		}() + uintptr(x-1)*4)))
	} else {
		rnw = rw
	}
	val = val - j40__gradient64(tls, rw, rn, rnw)
__55:
	;
	if !(^*(*Int32_t)(unsafe.Pointer(n))&1 != 0) {
		goto __56
	}
	val = J40__abs64(tls, val)
__56:
	;
	goto __29
__29:
	;
	n += 16 * func() uintptr {
		if val > int64(*(*Int32_t)(unsafe.Pointer(n + 4))) {
			return uintptr(*(*Int32_t)(unsafe.Pointer(n + 8)))
		}
		return uintptr(*(*Int32_t)(unsafe.Pointer(n + 12)))
	}()
	goto __27
__28:
	;
	val = int64(j40__code(tls, st, *(*Int32_t)(unsafe.Pointer(n)), (*J40__modular)(unsafe.Pointer(m)).Dist_mult, m+96))

	val = int64(J40__unpack_signed(tls, Int32_t(val))**(*Int32_t)(unsafe.Pointer(n + 12)) + *(*Int32_t)(unsafe.Pointer(n + 8)))
	val = val + j40__predict64(tls, st, *(*Int32_t)(unsafe.Pointer(n + 4)), bp, bp+96)
__57:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __60
	}
	goto J40__ON_ERROR
__60:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int64(-32767-1) <= val && val <= int64(32767))), int64(0)) != 0) {
		goto __61
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 452))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 452 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 452 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 452 + 3))))
	goto J40__ON_ERROR
__61:
	;
	goto __58
__58:
	if 0 != 0 {
		goto __57
	}
	goto __59
__59:
	;
	*(*int32)(unsafe.Pointer(outpixels + uintptr(x)*4)) = int32(val)
	j40__wp_after_predict64(tls, bp, x, y, val)
	goto __25
__25:
	x++
	goto __24
	goto __26
__26:
	;
	goto __22
__22:
	y++
	goto __21
	goto __23
__23:
	;
	j40__free_wp64(tls, bp)
	j40__free(tls, refcmap)
	return J40_err(0)

J40__ON_ERROR:
	j40__free_wp64(tls, bp)
	j40__free(tls, refcmap)
	j40__free_plane(tls, c)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__modular_channel(tls *libc.TLS, st uintptr, m uintptr, cidx Int32_t, sidx Int64_t) J40_err {
	if int32((*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel+uintptr(cidx)*24)).Type) == J40__PLANE_I16 {
		return j40__modular_channel16(tls, st, m, cidx, sidx)
	} else {
		return j40__modular_channel32(tls, st, m, cidx, sidx)
	}
	return J40_err(0)
}

var sJ40__PALETTE_DELTAS = [144][3]Int16_t{
	{int16(0), int16(0), int16(0)}, {int16(-0), int16(-0), int16(-0)}, {int16(4), int16(4), int16(4)}, {int16(-4), int16(-4), int16(-4)}, {int16(11), int16(0), int16(0)}, {int16(-11), int16(-0), int16(-0)}, {int16(0), int16(0), int16(-13)}, {int16(-0), int16(-0), int16(- -13)}, {int16(0), int16(-12), int16(0)}, {int16(-0), int16(- -12), int16(-0)}, {int16(-10), int16(-10), int16(-10)}, {int16(- -10), int16(- -10), int16(- -10)},
	{int16(-18), int16(-18), int16(-18)}, {int16(- -18), int16(- -18), int16(- -18)}, {int16(-27), int16(-27), int16(-27)}, {int16(- -27), int16(- -27), int16(- -27)}, {int16(-18), int16(-18), int16(0)}, {int16(- -18), int16(- -18), int16(-0)}, {int16(0), int16(0), int16(-32)}, {int16(-0), int16(-0), int16(- -32)}, {int16(-32), int16(0), int16(0)}, {int16(- -32), int16(-0), int16(-0)}, {int16(-37), int16(-37), int16(-37)}, {int16(- -37), int16(- -37), int16(- -37)},
	{int16(0), int16(-32), int16(-32)}, {int16(-0), int16(- -32), int16(- -32)}, {int16(24), int16(24), int16(45)}, {int16(-24), int16(-24), int16(-45)}, {int16(50), int16(50), int16(50)}, {int16(-50), int16(-50), int16(-50)}, {int16(-45), int16(-24), int16(-24)}, {int16(- -45), int16(- -24), int16(- -24)}, {int16(-24), int16(-45), int16(-45)}, {int16(- -24), int16(- -45), int16(- -45)}, {int16(0), int16(-24), int16(-24)}, {int16(-0), int16(- -24), int16(- -24)},
	{int16(-34), int16(-34), int16(0)}, {int16(- -34), int16(- -34), int16(-0)}, {int16(-24), int16(0), int16(-24)}, {int16(- -24), int16(-0), int16(- -24)}, {int16(-45), int16(-45), int16(-24)}, {int16(- -45), int16(- -45), int16(- -24)}, {int16(64), int16(64), int16(64)}, {int16(-64), int16(-64), int16(-64)}, {int16(-32), int16(0), int16(-32)}, {int16(- -32), int16(-0), int16(- -32)}, {int16(0), int16(-32), int16(0)}, {int16(-0), int16(- -32), int16(-0)},
	{int16(-32), int16(0), int16(32)}, {int16(- -32), int16(-0), int16(-32)}, {int16(-24), int16(-45), int16(-24)}, {int16(- -24), int16(- -45), int16(- -24)}, {int16(45), int16(24), int16(45)}, {int16(-45), int16(-24), int16(-45)}, {int16(24), int16(-24), int16(-45)}, {int16(-24), int16(- -24), int16(- -45)}, {int16(-45), int16(-24), int16(24)}, {int16(- -45), int16(- -24), int16(-24)}, {int16(80), int16(80), int16(80)}, {int16(-80), int16(-80), int16(-80)},
	{int16(64), int16(0), int16(0)}, {int16(-64), int16(-0), int16(-0)}, {int16(0), int16(0), int16(-64)}, {int16(-0), int16(-0), int16(- -64)}, {int16(0), int16(-64), int16(-64)}, {int16(-0), int16(- -64), int16(- -64)}, {int16(-24), int16(-24), int16(45)}, {int16(- -24), int16(- -24), int16(-45)}, {int16(96), int16(96), int16(96)}, {int16(-96), int16(-96), int16(-96)}, {int16(64), int16(64), int16(0)}, {int16(-64), int16(-64), int16(-0)},
	{int16(45), int16(-24), int16(-24)}, {int16(-45), int16(- -24), int16(- -24)}, {int16(34), int16(-34), int16(0)}, {int16(-34), int16(- -34), int16(-0)}, {int16(112), int16(112), int16(112)}, {int16(-112), int16(-112), int16(-112)}, {int16(24), int16(-45), int16(-45)}, {int16(-24), int16(- -45), int16(- -45)}, {int16(45), int16(45), int16(-24)}, {int16(-45), int16(-45), int16(- -24)}, {int16(0), int16(-32), int16(32)}, {int16(-0), int16(- -32), int16(-32)},
	{int16(24), int16(-24), int16(45)}, {int16(-24), int16(- -24), int16(-45)}, {int16(0), int16(96), int16(96)}, {int16(-0), int16(-96), int16(-96)}, {int16(45), int16(-24), int16(24)}, {int16(-45), int16(- -24), int16(-24)}, {int16(24), int16(-45), int16(-24)}, {int16(-24), int16(- -45), int16(- -24)}, {int16(-24), int16(-45), int16(24)}, {int16(- -24), int16(- -45), int16(-24)}, {int16(0), int16(-64), int16(0)}, {int16(-0), int16(- -64), int16(-0)},
	{int16(96), int16(0), int16(0)}, {int16(-96), int16(-0), int16(-0)}, {int16(128), int16(128), int16(128)}, {int16(-128), int16(-128), int16(-128)}, {int16(64), int16(0), int16(64)}, {int16(-64), int16(-0), int16(-64)}, {int16(144), int16(144), int16(144)}, {int16(-144), int16(-144), int16(-144)}, {int16(96), int16(96), int16(0)}, {int16(-96), int16(-96), int16(-0)}, {int16(-36), int16(-36), int16(36)}, {int16(- -36), int16(- -36), int16(-36)},
	{int16(45), int16(-24), int16(-45)}, {int16(-45), int16(- -24), int16(- -45)}, {int16(45), int16(-45), int16(-24)}, {int16(-45), int16(- -45), int16(- -24)}, {int16(0), int16(0), int16(-96)}, {int16(-0), int16(-0), int16(- -96)}, {int16(0), int16(128), int16(128)}, {int16(-0), int16(-128), int16(-128)}, {int16(0), int16(96), int16(0)}, {int16(-0), int16(-96), int16(-0)}, {int16(45), int16(24), int16(-45)}, {int16(-45), int16(-24), int16(- -45)},
	{int16(-128), int16(0), int16(0)}, {int16(- -128), int16(-0), int16(-0)}, {int16(24), int16(-45), int16(24)}, {int16(-24), int16(- -45), int16(-24)}, {int16(-45), int16(24), int16(-45)}, {int16(- -45), int16(-24), int16(- -45)}, {int16(64), int16(0), int16(-64)}, {int16(-64), int16(-0), int16(- -64)}, {int16(64), int16(-64), int16(-64)}, {int16(-64), int16(- -64), int16(- -64)}, {int16(96), int16(0), int16(96)}, {int16(-96), int16(-0), int16(-96)},
	{int16(45), int16(-45), int16(24)}, {int16(-45), int16(- -45), int16(-24)}, {int16(24), int16(45), int16(-45)}, {int16(-24), int16(-45), int16(- -45)}, {int16(64), int16(64), int16(-64)}, {int16(-64), int16(-64), int16(- -64)}, {int16(128), int16(128), int16(0)}, {int16(-128), int16(-128), int16(-0)}, {int16(0), int16(0), int16(-128)}, {int16(-0), int16(-0), int16(- -128)}, {int16(-24), int16(45), int16(-45)}, {int16(- -24), int16(-45), int16(- -45)},
}

func j40__inverse_rct16(tls *libc.TLS, m uintptr, tr uintptr) {
	bp := tls.Alloc(72)
	defer tls.Free(72)

	var x Int32_t
	var y Int32_t
	var i Int32_t

	for i = 0; i < 3; i++ {
		*(*J40__plane)(unsafe.Pointer(bp + uintptr(i)*24)) = *(*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(*(*Int32_t)(unsafe.Pointer(tr + 4))+i)*24))
	}

	switch *(*Int32_t)(unsafe.Pointer(tr + 8)) % 7 {
	case 0:
		break
	case 1:
		for y = 0; y < (*J40__plane)(unsafe.Pointer(bp)).Height; y++ {
			var pp0 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp)).Stride_bytes)*Size_t(y))
			}()
			var pp2 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp+2*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp+2*24)).Stride_bytes)*Size_t(y))
			}()
			for x = 0; x < (*J40__plane)(unsafe.Pointer(bp)).Width; x++ {
				*(*int16)(unsafe.Pointer(pp2 + uintptr(x)*2)) = int16(int32(*(*int16)(unsafe.Pointer(pp2 + uintptr(x)*2))) + int32(*(*int16)(unsafe.Pointer(pp0 + uintptr(x)*2))))
			}
		}
		break
	case 2:
		for y = 0; y < (*J40__plane)(unsafe.Pointer(bp)).Height; y++ {
			var pp0 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp)).Stride_bytes)*Size_t(y))
			}()
			var pp1 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp+1*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp+1*24)).Stride_bytes)*Size_t(y))
			}()
			var pp2 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp+2*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp+2*24)).Stride_bytes)*Size_t(y))
			}()
			for x = 0; x < (*J40__plane)(unsafe.Pointer(bp)).Width; x++ {
				*(*int16)(unsafe.Pointer(pp2 + uintptr(x)*2)) = int16(int32(*(*int16)(unsafe.Pointer(pp1 + uintptr(x)*2))) + int32(*(*int16)(unsafe.Pointer(pp0 + uintptr(x)*2))))
			}
		}
		break
	case 3:
		for y = 0; y < (*J40__plane)(unsafe.Pointer(bp)).Height; y++ {
			var pp0 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp)).Stride_bytes)*Size_t(y))
			}()
			var pp1 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp+1*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp+1*24)).Stride_bytes)*Size_t(y))
			}()
			var pp2 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp+2*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp+2*24)).Stride_bytes)*Size_t(y))
			}()
			for x = 0; x < (*J40__plane)(unsafe.Pointer(bp)).Width; x++ {
				*(*int16)(unsafe.Pointer(pp1 + uintptr(x)*2)) = int16(int32(*(*int16)(unsafe.Pointer(pp1 + uintptr(x)*2))) + int32(*(*int16)(unsafe.Pointer(pp0 + uintptr(x)*2))))
				*(*int16)(unsafe.Pointer(pp2 + uintptr(x)*2)) = int16(int32(*(*int16)(unsafe.Pointer(pp2 + uintptr(x)*2))) + int32(*(*int16)(unsafe.Pointer(pp0 + uintptr(x)*2))))
			}
		}
		break
	case 4:
		for y = 0; y < (*J40__plane)(unsafe.Pointer(bp)).Height; y++ {
			var pp0 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp)).Stride_bytes)*Size_t(y))
			}()
			var pp1 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp+1*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp+1*24)).Stride_bytes)*Size_t(y))
			}()
			var pp2 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp+2*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp+2*24)).Stride_bytes)*Size_t(y))
			}()
			for x = 0; x < (*J40__plane)(unsafe.Pointer(bp)).Width; x++ {
				*(*int16)(unsafe.Pointer(pp1 + uintptr(x)*2)) = int16(int32(*(*int16)(unsafe.Pointer(pp1 + uintptr(x)*2))) + int32(J40__floor_avg16(tls, *(*int16)(unsafe.Pointer(pp0 + uintptr(x)*2)), *(*int16)(unsafe.Pointer(pp2 + uintptr(x)*2)))))
			}
		}
		break
	case 5:
		for y = 0; y < (*J40__plane)(unsafe.Pointer(bp)).Height; y++ {
			var pp0 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp)).Stride_bytes)*Size_t(y))
			}()
			var pp1 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp+1*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp+1*24)).Stride_bytes)*Size_t(y))
			}()
			var pp2 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp+2*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp+2*24)).Stride_bytes)*Size_t(y))
			}()
			for x = 0; x < (*J40__plane)(unsafe.Pointer(bp)).Width; x++ {
				*(*int16)(unsafe.Pointer(pp1 + uintptr(x)*2)) = int16(int32(*(*int16)(unsafe.Pointer(pp1 + uintptr(x)*2))) + int32(*(*int16)(unsafe.Pointer(pp0 + uintptr(x)*2))) + int32(*(*int16)(unsafe.Pointer(pp2 + uintptr(x)*2)))>>1)
				*(*int16)(unsafe.Pointer(pp2 + uintptr(x)*2)) = int16(int32(*(*int16)(unsafe.Pointer(pp2 + uintptr(x)*2))) + int32(*(*int16)(unsafe.Pointer(pp0 + uintptr(x)*2))))
			}
		}
		break
	case 6:
		for y = 0; y < (*J40__plane)(unsafe.Pointer(bp)).Height; y++ {
			var pp0 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp)).Stride_bytes)*Size_t(y))
			}()
			var pp1 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp+1*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp+1*24)).Stride_bytes)*Size_t(y))
			}()
			var pp2 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp+2*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp+2*24)).Stride_bytes)*Size_t(y))
			}()
			for x = 0; x < (*J40__plane)(unsafe.Pointer(bp)).Width; x++ {
				var tmp int32 = int32(*(*int16)(unsafe.Pointer(pp0 + uintptr(x)*2))) - int32(*(*int16)(unsafe.Pointer(pp2 + uintptr(x)*2)))>>1
				var p1 int32 = int32(*(*int16)(unsafe.Pointer(pp2 + uintptr(x)*2))) + tmp
				var p2 int32 = tmp - int32(*(*int16)(unsafe.Pointer(pp1 + uintptr(x)*2)))>>1
				*(*int16)(unsafe.Pointer(pp0 + uintptr(x)*2)) = int16(p2 + int32(*(*int16)(unsafe.Pointer(pp1 + uintptr(x)*2))))
				*(*int16)(unsafe.Pointer(pp1 + uintptr(x)*2)) = int16(p1)
				*(*int16)(unsafe.Pointer(pp2 + uintptr(x)*2)) = int16(p2)
			}
		}
		break
	default:
	}

	for i = 0; i < 3; i++ {
		*(*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(*(*Int32_t)(unsafe.Pointer(tr + 4))+Int32_t(*(*Uint8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&PERMUTATIONS)) + uintptr(*(*Int32_t)(unsafe.Pointer(tr + 8))/7)*3 + uintptr(i)))))*24)) = *(*J40__plane)(unsafe.Pointer(bp + uintptr(i)*24))
	}
}

var PERMUTATIONS = [6][3]Uint8_t{{Uint8_t(0), Uint8_t(1), Uint8_t(2)}, {Uint8_t(1), Uint8_t(2), Uint8_t(0)}, {Uint8_t(2), Uint8_t(0), Uint8_t(1)}, {Uint8_t(0), Uint8_t(2), Uint8_t(1)}, {Uint8_t(1), Uint8_t(0), Uint8_t(2)}, {Uint8_t(2), Uint8_t(1), Uint8_t(0)}}

func j40__inverse_palette16(tls *libc.TLS, st uintptr, m uintptr, tr uintptr) J40_err {
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var first Int32_t
	var last Int32_t
	var bpp Int32_t
	var i Int32_t
	var j Int32_t
	var y Int32_t
	var x Int32_t
	var idxc uintptr
	var width Int32_t
	var height Int32_t
	var use_pred int32
	var use_wp int32

	var idx int16
	var val int16
	var is_delta int32

	var idxline uintptr
	var line uintptr
	var palp uintptr
	var c uintptr
	first = *(*Int32_t)(unsafe.Pointer(tr + 4)) + 1
	last = *(*Int32_t)(unsafe.Pointer(tr + 4)) + *(*Int32_t)(unsafe.Pointer(tr + 8))
	bpp = (*J40__image_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Image)).Bpp
	idxc = (*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(last)*24
	width = (*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(first)*24)).Width
	height = (*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(first)*24)).Height
	use_pred = libc.Bool32(*(*Int32_t)(unsafe.Pointer(tr + 16)) > 0)
	use_wp = libc.Bool32(use_pred != 0 && *(*Int32_t)(unsafe.Pointer(tr + 20)) == 6)
	*(*J40__wp32)(unsafe.Pointer(bp)) = J40__wp32{}

	libc.Xmemmove(tls, (*J40__modular)(unsafe.Pointer(m)).Channel+uintptr(last)*24, (*J40__modular)(unsafe.Pointer(m)).Channel+uintptr(first)*24, uint64(unsafe.Sizeof(J40__plane{}))*Size_t((*J40__modular)(unsafe.Pointer(m)).Num_channels-first))
	*(*Int32_t)(unsafe.Pointer(m + 136)) += last - first

	i = first
__1:
	if !(i < last) {
		goto __3
	}
	(*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(i)*24)).Type = Uint8_t(0)
	goto __2
__2:
	i++
	goto __1
	goto __3
__3:
	;
	i = first
__4:
	if !(i < last) {
		goto __6
	}
__7:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_plane(tls, st, J40__PLANE_I16, width, height, uint32(0), (*J40__modular)(unsafe.Pointer(m)).Channel+uintptr(i)*24) != 0)), int64(0)) != 0) {
		goto __10
	}
	goto J40__ON_ERROR
__10:
	;
	goto __8
__8:
	if 0 != 0 {
		goto __7
	}
	goto __9
__9:
	;
	goto __5
__5:
	i++
	goto __4
	goto __6
__6:
	;
	if !(use_wp != 0) {
		goto __11
	}
__12:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_wp32(tls, st, (*J40__modular)(unsafe.Pointer(m)).Wp, width, bp) != 0)), int64(0)) != 0) {
		goto __15
	}
	goto J40__ON_ERROR
__15:
	;
	goto __13
__13:
	if 0 != 0 {
		goto __12
	}
	goto __14
__14:
	;
__11:
	;
	i = 0
__16:
	if !(i < *(*Int32_t)(unsafe.Pointer(tr + 8))) {
		goto __18
	}
	palp = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel)).Stride_bytes)*Size_t(i))
	}()
	c = (*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(first+i)*24
	y = 0
__19:
	if !(y < height) {
		goto __21
	}

	idxline = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(idxc)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(idxc)).Stride_bytes)*Size_t(y))
	}()
	line = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(c)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(c)).Stride_bytes)*Size_t(y))
	}()
	x = 0
__22:
	if !(x < width) {
		goto __24
	}
	idx = *(*int16)(unsafe.Pointer(idxline + uintptr(x)*2))
	is_delta = libc.Bool32(int32(idx) < *(*Int32_t)(unsafe.Pointer(tr + 16)))
	if !(int32(idx) < 0) {
		goto __25
	}
	if !(i < 3) {
		goto __27
	}
	idx = int16(^int32(idx) % 143)
	val = *(*Int16_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&sJ40__PALETTE_DELTAS)) + uintptr(int32(idx)+1)*6 + uintptr(i)*2))
	if !(bpp > 8) {
		goto __29
	}
	val = int16(int32(val) << (J40__min32(tls, bpp, 24) - 8))
__29:
	;
	goto __28
__27:
	val = int16(0)
__28:
	;
	goto __26
__25:
	if !(int32(idx) < *(*Int32_t)(unsafe.Pointer(tr + 12))) {
		goto __30
	}
	val = *(*int16)(unsafe.Pointer(palp + uintptr(idx)*2))
	goto __31
__30:
	idx = int16(int32(idx) - *(*Int32_t)(unsafe.Pointer(tr + 12)))
	if !(int32(idx) < 64) {
		goto __32
	}
	val = int16(func() int32 {
		if i < 3 {
			return int32(idx) >> (2 * i)
		}
		return 0
	}()*(int32(1)<<bpp-1)/4 + int32(1)<<J40__max32(tls, 0, bpp-3))
	goto __33
__32:
	val = int16(int32(idx) - 64)
	j = 0
__34:
	if !(j < i) {
		goto __36
	}
	val = int16(int32(val) / 5)
	goto __35
__35:
	j++
	goto __34
	goto __36
__36:
	;
	val = int16(int32(val) % 5 * (int32(1)<<bpp - 1) / 4)
__33:
	;
__31:
	;
__26:
	;
	if !(use_pred != 0) {
		goto __37
	}
	*(*J40__neighbors16)(unsafe.Pointer(bp + 64)) = J40__init_neighbors16(tls, c, x, y)
	j40__wp_before_predict32(tls, bp, x, y, bp+64)

	if !(is_delta != 0) {
		goto __38
	}
	val = int16(int32(val) + j40__predict32(tls, st, *(*Int32_t)(unsafe.Pointer(tr + 20)), bp, bp+64))
__38:
	;
	j40__wp_after_predict32(tls, bp, x, y, int32(val))
__37:
	;
	*(*int16)(unsafe.Pointer(line + uintptr(x)*2)) = val
	goto __23
__23:
	x++
	goto __22
	goto __24
__24:
	;
	goto __20
__20:
	y++
	goto __19
	goto __21
__21:
	;
	j40__reset_wp32(tls, bp)
	goto __17
__17:
	i++
	goto __16
	goto __18
__18:
	;
	j40__free_wp32(tls, bp)
	j40__free_plane(tls, (*J40__modular)(unsafe.Pointer(m)).Channel)
	libc.Xmemmove(tls, (*J40__modular)(unsafe.Pointer(m)).Channel, (*J40__modular)(unsafe.Pointer(m)).Channel+uintptr(1)*24, uint64(unsafe.Sizeof(J40__plane{}))*Size_t(libc.PreDecInt32(&(*J40__modular)(unsafe.Pointer(m)).Num_channels, 1)))
	return J40_err(0)

J40__ON_ERROR:
	j40__free_wp32(tls, bp)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__inverse_rct32(tls *libc.TLS, m uintptr, tr uintptr) {
	bp := tls.Alloc(72)
	defer tls.Free(72)

	var x Int32_t
	var y Int32_t
	var i Int32_t

	for i = 0; i < 3; i++ {
		*(*J40__plane)(unsafe.Pointer(bp + uintptr(i)*24)) = *(*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(*(*Int32_t)(unsafe.Pointer(tr + 4))+i)*24))
	}

	switch *(*Int32_t)(unsafe.Pointer(tr + 8)) % 7 {
	case 0:
		break
	case 1:
		for y = 0; y < (*J40__plane)(unsafe.Pointer(bp)).Height; y++ {
			var pp0 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp)).Stride_bytes)*Size_t(y))
			}()
			var pp2 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp+2*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp+2*24)).Stride_bytes)*Size_t(y))
			}()
			for x = 0; x < (*J40__plane)(unsafe.Pointer(bp)).Width; x++ {
				*(*int32)(unsafe.Pointer(pp2 + uintptr(x)*4)) = *(*int32)(unsafe.Pointer(pp2 + uintptr(x)*4)) + *(*int32)(unsafe.Pointer(pp0 + uintptr(x)*4))
			}
		}
		break
	case 2:
		for y = 0; y < (*J40__plane)(unsafe.Pointer(bp)).Height; y++ {
			var pp0 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp)).Stride_bytes)*Size_t(y))
			}()
			var pp1 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp+1*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp+1*24)).Stride_bytes)*Size_t(y))
			}()
			var pp2 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp+2*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp+2*24)).Stride_bytes)*Size_t(y))
			}()
			for x = 0; x < (*J40__plane)(unsafe.Pointer(bp)).Width; x++ {
				*(*int32)(unsafe.Pointer(pp2 + uintptr(x)*4)) = *(*int32)(unsafe.Pointer(pp1 + uintptr(x)*4)) + *(*int32)(unsafe.Pointer(pp0 + uintptr(x)*4))
			}
		}
		break
	case 3:
		for y = 0; y < (*J40__plane)(unsafe.Pointer(bp)).Height; y++ {
			var pp0 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp)).Stride_bytes)*Size_t(y))
			}()
			var pp1 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp+1*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp+1*24)).Stride_bytes)*Size_t(y))
			}()
			var pp2 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp+2*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp+2*24)).Stride_bytes)*Size_t(y))
			}()
			for x = 0; x < (*J40__plane)(unsafe.Pointer(bp)).Width; x++ {
				*(*int32)(unsafe.Pointer(pp1 + uintptr(x)*4)) = *(*int32)(unsafe.Pointer(pp1 + uintptr(x)*4)) + *(*int32)(unsafe.Pointer(pp0 + uintptr(x)*4))
				*(*int32)(unsafe.Pointer(pp2 + uintptr(x)*4)) = *(*int32)(unsafe.Pointer(pp2 + uintptr(x)*4)) + *(*int32)(unsafe.Pointer(pp0 + uintptr(x)*4))
			}
		}
		break
	case 4:
		for y = 0; y < (*J40__plane)(unsafe.Pointer(bp)).Height; y++ {
			var pp0 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp)).Stride_bytes)*Size_t(y))
			}()
			var pp1 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp+1*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp+1*24)).Stride_bytes)*Size_t(y))
			}()
			var pp2 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp+2*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp+2*24)).Stride_bytes)*Size_t(y))
			}()
			for x = 0; x < (*J40__plane)(unsafe.Pointer(bp)).Width; x++ {
				*(*int32)(unsafe.Pointer(pp1 + uintptr(x)*4)) = *(*int32)(unsafe.Pointer(pp1 + uintptr(x)*4)) + J40__floor_avg32(tls, *(*int32)(unsafe.Pointer(pp0 + uintptr(x)*4)), *(*int32)(unsafe.Pointer(pp2 + uintptr(x)*4)))
			}
		}
		break
	case 5:
		for y = 0; y < (*J40__plane)(unsafe.Pointer(bp)).Height; y++ {
			var pp0 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp)).Stride_bytes)*Size_t(y))
			}()
			var pp1 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp+1*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp+1*24)).Stride_bytes)*Size_t(y))
			}()
			var pp2 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp+2*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp+2*24)).Stride_bytes)*Size_t(y))
			}()
			for x = 0; x < (*J40__plane)(unsafe.Pointer(bp)).Width; x++ {
				*(*int32)(unsafe.Pointer(pp1 + uintptr(x)*4)) = int32(int64(*(*int32)(unsafe.Pointer(pp1 + uintptr(x)*4))) + int64(*(*int32)(unsafe.Pointer(pp0 + uintptr(x)*4))) + int64(*(*int32)(unsafe.Pointer(pp2 + uintptr(x)*4))>>1))
				*(*int32)(unsafe.Pointer(pp2 + uintptr(x)*4)) = *(*int32)(unsafe.Pointer(pp2 + uintptr(x)*4)) + *(*int32)(unsafe.Pointer(pp0 + uintptr(x)*4))
			}
		}
		break
	case 6:
		for y = 0; y < (*J40__plane)(unsafe.Pointer(bp)).Height; y++ {
			var pp0 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp)).Stride_bytes)*Size_t(y))
			}()
			var pp1 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp+1*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp+1*24)).Stride_bytes)*Size_t(y))
			}()
			var pp2 uintptr = func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(bp+2*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp+2*24)).Stride_bytes)*Size_t(y))
			}()
			for x = 0; x < (*J40__plane)(unsafe.Pointer(bp)).Width; x++ {
				var tmp int64 = int64(*(*int32)(unsafe.Pointer(pp0 + uintptr(x)*4))) - int64(*(*int32)(unsafe.Pointer(pp2 + uintptr(x)*4)))>>1
				var p1 int64 = int64(*(*int32)(unsafe.Pointer(pp2 + uintptr(x)*4))) + tmp
				var p2 int64 = tmp - int64(*(*int32)(unsafe.Pointer(pp1 + uintptr(x)*4)))>>1
				*(*int32)(unsafe.Pointer(pp0 + uintptr(x)*4)) = int32(p2 + int64(*(*int32)(unsafe.Pointer(pp1 + uintptr(x)*4))))
				*(*int32)(unsafe.Pointer(pp1 + uintptr(x)*4)) = int32(p1)
				*(*int32)(unsafe.Pointer(pp2 + uintptr(x)*4)) = int32(p2)
			}
		}
		break
	default:
	}

	for i = 0; i < 3; i++ {
		*(*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(*(*Int32_t)(unsafe.Pointer(tr + 4))+Int32_t(*(*Uint8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&PERMUTATIONS1)) + uintptr(*(*Int32_t)(unsafe.Pointer(tr + 8))/7)*3 + uintptr(i)))))*24)) = *(*J40__plane)(unsafe.Pointer(bp + uintptr(i)*24))
	}
}

var PERMUTATIONS1 = [6][3]Uint8_t{{Uint8_t(0), Uint8_t(1), Uint8_t(2)}, {Uint8_t(1), Uint8_t(2), Uint8_t(0)}, {Uint8_t(2), Uint8_t(0), Uint8_t(1)}, {Uint8_t(0), Uint8_t(2), Uint8_t(1)}, {Uint8_t(1), Uint8_t(0), Uint8_t(2)}, {Uint8_t(2), Uint8_t(1), Uint8_t(0)}}

func j40__inverse_palette32(tls *libc.TLS, st uintptr, m uintptr, tr uintptr) J40_err {
	bp := tls.Alloc(128)
	defer tls.Free(128)

	var first Int32_t
	var last Int32_t
	var bpp Int32_t
	var i Int32_t
	var j Int32_t
	var y Int32_t
	var x Int32_t
	var idxc uintptr
	var width Int32_t
	var height Int32_t
	var use_pred int32
	var use_wp int32

	var idx int32
	var val int32
	var is_delta int32

	var idxline uintptr
	var line uintptr
	var palp uintptr
	var c uintptr
	first = *(*Int32_t)(unsafe.Pointer(tr + 4)) + 1
	last = *(*Int32_t)(unsafe.Pointer(tr + 4)) + *(*Int32_t)(unsafe.Pointer(tr + 8))
	bpp = (*J40__image_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Image)).Bpp
	idxc = (*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(last)*24
	width = (*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(first)*24)).Width
	height = (*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(first)*24)).Height
	use_pred = libc.Bool32(*(*Int32_t)(unsafe.Pointer(tr + 16)) > 0)
	use_wp = libc.Bool32(use_pred != 0 && *(*Int32_t)(unsafe.Pointer(tr + 20)) == 6)
	*(*J40__wp64)(unsafe.Pointer(bp)) = J40__wp64{}

	libc.Xmemmove(tls, (*J40__modular)(unsafe.Pointer(m)).Channel+uintptr(last)*24, (*J40__modular)(unsafe.Pointer(m)).Channel+uintptr(first)*24, uint64(unsafe.Sizeof(J40__plane{}))*Size_t((*J40__modular)(unsafe.Pointer(m)).Num_channels-first))
	*(*Int32_t)(unsafe.Pointer(m + 136)) += last - first

	i = first
__1:
	if !(i < last) {
		goto __3
	}
	(*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(i)*24)).Type = Uint8_t(0)
	goto __2
__2:
	i++
	goto __1
	goto __3
__3:
	;
	i = first
__4:
	if !(i < last) {
		goto __6
	}
__7:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_plane(tls, st, J40__PLANE_I32, width, height, uint32(0), (*J40__modular)(unsafe.Pointer(m)).Channel+uintptr(i)*24) != 0)), int64(0)) != 0) {
		goto __10
	}
	goto J40__ON_ERROR
__10:
	;
	goto __8
__8:
	if 0 != 0 {
		goto __7
	}
	goto __9
__9:
	;
	goto __5
__5:
	i++
	goto __4
	goto __6
__6:
	;
	if !(use_wp != 0) {
		goto __11
	}
__12:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_wp64(tls, st, (*J40__modular)(unsafe.Pointer(m)).Wp, width, bp) != 0)), int64(0)) != 0) {
		goto __15
	}
	goto J40__ON_ERROR
__15:
	;
	goto __13
__13:
	if 0 != 0 {
		goto __12
	}
	goto __14
__14:
	;
__11:
	;
	i = 0
__16:
	if !(i < *(*Int32_t)(unsafe.Pointer(tr + 8))) {
		goto __18
	}
	palp = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel)).Stride_bytes)*Size_t(i))
	}()
	c = (*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(first+i)*24
	y = 0
__19:
	if !(y < height) {
		goto __21
	}

	idxline = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(idxc)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(idxc)).Stride_bytes)*Size_t(y))
	}()
	line = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(c)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(c)).Stride_bytes)*Size_t(y))
	}()
	x = 0
__22:
	if !(x < width) {
		goto __24
	}
	idx = *(*int32)(unsafe.Pointer(idxline + uintptr(x)*4))
	is_delta = libc.Bool32(idx < *(*Int32_t)(unsafe.Pointer(tr + 16)))
	if !(idx < 0) {
		goto __25
	}
	if !(i < 3) {
		goto __27
	}
	idx = ^idx % 143
	val = int32(*(*Int16_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&sJ40__PALETTE_DELTAS)) + uintptr(idx+1)*6 + uintptr(i)*2)))
	if !(bpp > 8) {
		goto __29
	}
	val = val << (J40__min32(tls, bpp, 24) - 8)
__29:
	;
	goto __28
__27:
	val = 0
__28:
	;
	goto __26
__25:
	if !(idx < *(*Int32_t)(unsafe.Pointer(tr + 12))) {
		goto __30
	}
	val = *(*int32)(unsafe.Pointer(palp + uintptr(idx)*4))
	goto __31
__30:
	idx = idx - *(*Int32_t)(unsafe.Pointer(tr + 12))
	if !(idx < 64) {
		goto __32
	}
	val = int32(func() int64 {
		if i < 3 {
			return int64(idx >> (2 * i))
		}
		return int64(0)
	}()*(int64(int64(1))<<bpp-int64(1))/int64(4) + int64(int32(1)<<J40__max32(tls, 0, bpp-3)))
	goto __33
__32:
	val = idx - 64
	j = 0
__34:
	if !(j < i) {
		goto __36
	}
	val = val / 5
	goto __35
__35:
	j++
	goto __34
	goto __36
__36:
	;
	val = val % 5 * (int32(1)<<bpp - 1) / 4
__33:
	;
__31:
	;
__26:
	;
	if !(use_pred != 0) {
		goto __37
	}
	*(*J40__neighbors32)(unsafe.Pointer(bp + 96)) = J40__init_neighbors32(tls, c, x, y)
	j40__wp_before_predict64(tls, bp, x, y, bp+96)

	if !(is_delta != 0) {
		goto __38
	}
	val = int32(Int64_t(val) + j40__predict64(tls, st, *(*Int32_t)(unsafe.Pointer(tr + 20)), bp, bp+96))
__38:
	;
	j40__wp_after_predict64(tls, bp, x, y, int64(val))
__37:
	;
	*(*int32)(unsafe.Pointer(line + uintptr(x)*4)) = val
	goto __23
__23:
	x++
	goto __22
	goto __24
__24:
	;
	goto __20
__20:
	y++
	goto __19
	goto __21
__21:
	;
	j40__reset_wp64(tls, bp)
	goto __17
__17:
	i++
	goto __16
	goto __18
__18:
	;
	j40__free_wp64(tls, bp)
	j40__free_plane(tls, (*J40__modular)(unsafe.Pointer(m)).Channel)
	libc.Xmemmove(tls, (*J40__modular)(unsafe.Pointer(m)).Channel, (*J40__modular)(unsafe.Pointer(m)).Channel+uintptr(1)*24, uint64(unsafe.Sizeof(J40__plane{}))*Size_t(libc.PreDecInt32(&(*J40__modular)(unsafe.Pointer(m)).Num_channels, 1)))
	return J40_err(0)

J40__ON_ERROR:
	j40__free_wp64(tls, bp)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__inverse_transform(tls *libc.TLS, st uintptr, m uintptr) J40_err {
	var i Int32_t
	var tr uintptr
	var tr1 uintptr

	if !((*J40__modular)(unsafe.Pointer(m)).Num_channels == 0) {
		goto __1
	}
	return J40_err(0)
__1:
	;
	switch int32(j40__plane_all_equal_typed(tls, (*J40__modular)(unsafe.Pointer(m)).Channel, (*J40__modular)(unsafe.Pointer(m)).Channel+uintptr((*J40__modular)(unsafe.Pointer(m)).Num_channels)*24)) {
	case J40__PLANE_I16:
		goto __3

	case J40__PLANE_I32:
		goto __4

	default:
		goto __5
	}
	goto __2
__3:
	i = (*J40__modular)(unsafe.Pointer(m)).Nb_transforms - 1
__6:
	if !(i >= 0) {
		goto __8
	}
	tr = (*J40__modular)(unsafe.Pointer(m)).Transform + uintptr(i)*24
	switch *(*uint32)(unsafe.Pointer(tr)) {
	case J40__TR_RCT:
		goto __10
	case J40__TR_PALETTE:
		goto __11
	case J40__TR_SQUEEZE:
		goto __12
	default:
		goto __13
	}
	goto __9
__10:
	j40__inverse_rct16(tls, m, tr)
	goto __9
__11:
__14:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__inverse_palette16(tls, st, m, tr) != 0)), int64(0)) != 0) {
		goto __17
	}
	goto J40__ON_ERROR
__17:
	;
	goto __15
__15:
	if 0 != 0 {
		goto __14
	}
	goto __16
__16:
	;
	goto __9
__12:
__18:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 457))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 457 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 457 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 457 + 3))))
	goto J40__ON_ERROR
	goto __19
__19:
	if 0 != 0 {
		goto __18
	}
	goto __20
__20:
	;
	goto __9
__13:
	;
__9:
	;
	goto __7
__7:
	i--
	goto __6
	goto __8
__8:
	;
	goto __2

__4:
	i = (*J40__modular)(unsafe.Pointer(m)).Nb_transforms - 1
__21:
	if !(i >= 0) {
		goto __23
	}
	tr1 = (*J40__modular)(unsafe.Pointer(m)).Transform + uintptr(i)*24
	switch *(*uint32)(unsafe.Pointer(tr1)) {
	case J40__TR_RCT:
		goto __25
	case J40__TR_PALETTE:
		goto __26
	case J40__TR_SQUEEZE:
		goto __27
	default:
		goto __28
	}
	goto __24
__25:
	j40__inverse_rct32(tls, m, tr1)
	goto __24
__26:
__29:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__inverse_palette32(tls, st, m, tr1) != 0)), int64(0)) != 0) {
		goto __32
	}
	goto J40__ON_ERROR
__32:
	;
	goto __30
__30:
	if 0 != 0 {
		goto __29
	}
	goto __31
__31:
	;
	goto __24
__27:
__33:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 457))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 457 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 457 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 457 + 3))))
	goto J40__ON_ERROR
	goto __34
__34:
	if 0 != 0 {
		goto __33
	}
	goto __35
__35:
	;
	goto __24
__28:
	;
__24:
	;
	goto __22
__22:
	i--
	goto __21
	goto __23
__23:
	;
	goto __2

__5:
	;
__2:
	;
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

const (
	J40__DQ_ENC_LIBRARY = 0
	J40__DQ_ENC_HORNUSS = 1
	J40__DQ_ENC_DCT2    = 2
	J40__DQ_ENC_DCT4    = 3

	J40__DQ_ENC_DCT4X8 = 4
	J40__DQ_ENC_AFV    = 5
	J40__DQ_ENC_DCT    = 6

	J40__DQ_ENC_RAW = 7
)

type J40__dq_matrix = struct {
	Mode   uint32
	N      Int16_t
	M      Int16_t
	Params uintptr
}

type J40__dct_select = struct {
	Log_rows    Int8_t
	Log_columns Int8_t
	Param_idx   Int8_t
	Order_idx   Int8_t
}

var sJ40__DCT_SELECT = [27]J40__dct_select{
	{Log_rows: int8(3), Log_columns: int8(3)}, {Log_rows: int8(3), Log_columns: int8(3), Param_idx: int8(1), Order_idx: int8(1)}, {Log_rows: int8(3), Log_columns: int8(3), Param_idx: int8(2), Order_idx: int8(1)}, {Log_rows: int8(3), Log_columns: int8(3), Param_idx: int8(3), Order_idx: int8(1)},
	{Log_rows: int8(4), Log_columns: int8(4), Param_idx: int8(4), Order_idx: int8(2)}, {Log_rows: int8(5), Log_columns: int8(5), Param_idx: int8(5), Order_idx: int8(3)}, {Log_rows: int8(4), Log_columns: int8(3), Param_idx: int8(6), Order_idx: int8(4)}, {Log_rows: int8(3), Log_columns: int8(4), Param_idx: int8(6), Order_idx: int8(4)},
	{Log_rows: int8(5), Log_columns: int8(3), Param_idx: int8(7), Order_idx: int8(5)}, {Log_rows: int8(3), Log_columns: int8(5), Param_idx: int8(7), Order_idx: int8(5)}, {Log_rows: int8(5), Log_columns: int8(4), Param_idx: int8(8), Order_idx: int8(6)}, {Log_rows: int8(4), Log_columns: int8(5), Param_idx: int8(8), Order_idx: int8(6)},
	{Log_rows: int8(3), Log_columns: int8(3), Param_idx: int8(9), Order_idx: int8(1)}, {Log_rows: int8(3), Log_columns: int8(3), Param_idx: int8(9), Order_idx: int8(1)}, {Log_rows: int8(3), Log_columns: int8(3), Param_idx: int8(10), Order_idx: int8(1)}, {Log_rows: int8(3), Log_columns: int8(3), Param_idx: int8(10), Order_idx: int8(1)},
	{Log_rows: int8(3), Log_columns: int8(3), Param_idx: int8(10), Order_idx: int8(1)}, {Log_rows: int8(3), Log_columns: int8(3), Param_idx: int8(10), Order_idx: int8(1)}, {Log_rows: int8(6), Log_columns: int8(6), Param_idx: int8(11), Order_idx: int8(7)}, {Log_rows: int8(6), Log_columns: int8(5), Param_idx: int8(12), Order_idx: int8(8)},
	{Log_rows: int8(5), Log_columns: int8(6), Param_idx: int8(12), Order_idx: int8(8)}, {Log_rows: int8(7), Log_columns: int8(7), Param_idx: int8(13), Order_idx: int8(9)}, {Log_rows: int8(7), Log_columns: int8(6), Param_idx: int8(14), Order_idx: int8(10)}, {Log_rows: int8(6), Log_columns: int8(7), Param_idx: int8(14), Order_idx: int8(10)},
	{Log_rows: int8(8), Log_columns: int8(8), Param_idx: int8(15), Order_idx: int8(11)}, {Log_rows: int8(8), Log_columns: int8(7), Param_idx: int8(16), Order_idx: int8(12)}, {Log_rows: int8(7), Log_columns: int8(8), Param_idx: int8(16), Order_idx: int8(12)},
}

type J40__dct_params = struct {
	Log_rows    Int8_t
	Log_columns Int8_t
	Def_offset  Int8_t
	Def_mode    Int8_t
	Def_n       Int8_t
	Def_m       Int8_t
}

var sJ40__DCT_PARAMS = [17]J40__dct_params{
	{Log_rows: int8(3), Log_columns: int8(3), Def_mode: J40__DQ_ENC_DCT, Def_n: int8(6)}, {Log_rows: int8(3), Log_columns: int8(3), Def_offset: int8(6), Def_mode: J40__DQ_ENC_HORNUSS},
	{Log_rows: int8(3), Log_columns: int8(3), Def_offset: int8(9), Def_mode: J40__DQ_ENC_DCT2}, {Log_rows: int8(3), Log_columns: int8(3), Def_offset: int8(15), Def_mode: J40__DQ_ENC_DCT4, Def_n: int8(4)},
	{Log_rows: int8(4), Log_columns: int8(4), Def_offset: int8(21), Def_mode: J40__DQ_ENC_DCT, Def_n: int8(7)}, {Log_rows: int8(5), Log_columns: int8(5), Def_offset: int8(28), Def_mode: J40__DQ_ENC_DCT, Def_n: int8(8)},
	{Log_rows: int8(3), Log_columns: int8(4), Def_offset: int8(36), Def_mode: J40__DQ_ENC_DCT, Def_n: int8(7)}, {Log_rows: int8(3), Log_columns: int8(5), Def_offset: int8(43), Def_mode: J40__DQ_ENC_DCT, Def_n: int8(8)},
	{Log_rows: int8(4), Log_columns: int8(5), Def_offset: int8(51), Def_mode: J40__DQ_ENC_DCT, Def_n: int8(8)}, {Log_rows: int8(3), Log_columns: int8(3), Def_offset: int8(59), Def_mode: J40__DQ_ENC_DCT4X8, Def_n: int8(4)},
	{Log_rows: int8(3), Log_columns: int8(3), Def_offset: int8(64), Def_mode: J40__DQ_ENC_AFV, Def_n: int8(4), Def_m: int8(4)}, {Log_rows: int8(6), Log_columns: int8(6), Def_offset: int8(81), Def_mode: J40__DQ_ENC_DCT, Def_n: int8(8)},
	{Log_rows: int8(5), Log_columns: int8(6), Def_offset: int8(89), Def_mode: J40__DQ_ENC_DCT, Def_n: int8(8)}, {Log_rows: int8(7), Log_columns: int8(7), Def_offset: int8(97), Def_mode: J40__DQ_ENC_DCT, Def_n: int8(8)},
	{Log_rows: int8(6), Log_columns: int8(7), Def_offset: int8(105), Def_mode: J40__DQ_ENC_DCT, Def_n: int8(8)}, {Log_rows: int8(8), Log_columns: int8(8), Def_offset: int8(113), Def_mode: J40__DQ_ENC_DCT, Def_n: int8(8)},
	{Log_rows: int8(7), Log_columns: int8(8), Def_offset: int8(121), Def_mode: J40__DQ_ENC_DCT, Def_n: int8(8)},
}

var sJ40__LIBRARY_DCT_PARAMS = [129][4]float32{
	{0: 3150.0, 1: 560.0, 2: 512.0}, {0: 0.0, 1: 0.0, 2: -2.0}, {0: -0.4, 1: -0.3, 2: -1.0},
	{0: -0.4, 1: -0.3, 2: 0.0}, {0: -0.4, 1: -0.3, 2: -1.0}, {0: -2.0, 1: -0.3, 2: -2.0},
	{0: 280.0, 1: 60.0, 2: 18.0}, {0: 3160.0, 1: 864.0, 2: 200.0}, {0: 3160.0, 1: 864.0, 2: 200.0},
	{0: 3840.0, 1: 960.0, 2: 640.0}, {0: 2560.0, 1: 640.0, 2: 320.0}, {0: 1280.0, 1: 320.0, 2: 128.0},
	{0: 640.0, 1: 180.0, 2: 64.0}, {0: 480.0, 1: 140.0, 2: 32.0}, {0: 300.0, 1: 120.0, 2: 16.0},
	{0: 1.0, 1: 1.0, 2: 1.0}, {0: 1.0, 1: 1.0, 2: 1.0}, {0: 2200.0, 1: 392.0, 2: 112.0}, {0: 0.0, 1: 0.0, 2: -0.25}, {0: 0.0, 1: 0.0, 2: -0.25}, {0: 0.0, 1: 0.0, 2: -0.5},
	{0: 8996.8725711814115328, 1: 3191.48366296844234752, 2: 1157.50408145487200256},
	{0: -1.3000777393353804, 1: -0.67424582104194355, 2: -2.0531423165804414},
	{0: -0.49424529824571225, 1: -0.80745813428471001, 2: -1.4},
	{0: -0.439093774457103443, 1: -0.44925837484843441, 2: -0.50687130033378396},
	{0: -0.6350101832695744, 1: -0.35865440981033403, 2: -0.42708730624733904},
	{0: -0.90177264050827612, 1: -0.31322389111877305, 2: -1.4856834539296244},
	{0: -1.6162099239887414, 1: -0.37615025315725483, 2: -4.9209142884401604},
	{0: 15718.40830982518931456, 1: 7305.7636810695983104, 2: 3803.53173721215041536},
	{0: -1.025, 1: -0.8041958212306401, 2: -3.060733579805728},
	{0: -0.98, 1: -0.7633036457487539, 2: -2.0413270132490346},
	{0: -0.9012, 1: -0.55660379990111464, 2: -2.0235650159727417},
	{0: -0.4, 1: -0.49785304658857626, 2: -0.5495389509954993},
	{0: -0.48819395464, 1: -0.43699592683512467, 2: -0.4},
	{0: -0.421064, 1: -0.40180866526242109, 2: -0.4},
	{0: -0.27, 1: -0.27321683125358037, 2: -0.3},
	{0: 7240.7734393502, 1: 1448.15468787004, 2: 506.854140754517},
	{0: -0.7, 1: -0.5, 2: -1.4}, {0: -0.7, 1: -0.5, 2: -0.2}, {0: -0.2, 1: -0.5, 2: -0.5},
	{0: -0.2, 1: -0.2, 2: -0.5}, {0: -0.2, 1: -0.2, 2: -1.5}, {0: -0.5, 1: -0.2, 2: -3.6},
	{0: 16283.2494710648897, 1: 5089.15750884921511936, 2: 3397.77603275308720128},
	{0: -1.7812845336559429, 1: -0.320049391452786891, 2: -0.321327362693153371},
	{0: -1.6309059012653515, 1: -0.35362849922161446, 2: -0.34507619223117997},
	{0: -1.0382179034313539, 1: -0.30340000000000003, 2: -0.70340000000000003},
	{0: -0.85, 1: -0.61, 2: -0.9}, {0: -0.7, 1: -0.5, 2: -1.0}, {0: -0.9, 1: -0.5, 2: -1.0},
	{0: -1.2360638576849587, 1: -0.6, 2: -1.1754605576265209},
	{0: 13844.97076442300573, 1: 4798.964084220744293, 2: 1807.236946760964614},
	{0: -0.97113799999999995, 1: -0.61125308982767057, 2: -1.2},
	{0: -0.658, 1: -0.83770786552491361, 2: -1.2}, {0: -0.42026, 1: -0.79014862079498627, 2: -0.7},
	{0: -0.22712, 1: -0.2692727459704829, 2: -0.7}, {0: -0.2206, 1: -0.38272769465388551, 2: -0.7},
	{0: -0.226, 1: -0.22924222653091453, 2: -0.4}, {0: -0.6, 1: -0.20719098826199578, 2: -0.5},
	{0: 1.0, 1: 1.0, 2: 1.0}, {0: 2198.050556016380522, 1: 764.3655248643528689, 2: 527.107573587542228}, {0: -0.96269623020744692, 1: -0.92630200888366945, 2: -1.4594385811273854}, {0: -0.76194253026666783, 1: -0.9675229603596517, 2: -1.450082094097871593}, {0: -0.6551140670773547, 1: -0.27845290869168118, 2: -1.5843722511996204},
	{0: 3072.0, 1: 1024.0, 2: 384.0}, {0: 3072.0, 1: 1024.0, 2: 384.0}, {0: 256.0, 1: 50.0, 2: 12.0},
	{0: 256.0, 1: 50.0, 2: 12.0}, {0: 256.0, 1: 50.0, 2: 12.0}, {0: 414.0, 1: 58.0, 2: 22.0},
	{0: 0.0, 1: 0.0, 2: -0.25}, {0: 0.0, 1: 0.0, 2: -0.25}, {0: 0.0, 1: 0.0, 2: -0.25},
	{0: 2198.050556016380522, 1: 764.3655248643528689, 2: 527.107573587542228}, {0: -0.96269623020744692, 1: -0.92630200888366945, 2: -1.4594385811273854}, {0: -0.76194253026666783, 1: -0.9675229603596517, 2: -1.450082094097871593}, {0: -0.6551140670773547, 1: -0.27845290869168118, 2: -1.5843722511996204}, {0: 2200.0, 1: 392.0, 2: 112.0}, {0: 0.0, 1: 0.0, 2: -0.25}, {0: 0.0, 1: 0.0, 2: -0.25}, {0: 0.0, 1: 0.0, 2: -0.5},
	{0: float32(0.9) * 23629.073922049845, 1: float32(0.9) * 8611.3238710010046, 2: float32(0.9) * 4492.2486445538634}, {0: -1.025, 1: -0.3041958212306401, 2: -1.2}, {0: -0.78, 1: 0.3633036457487539, 2: -1.2}, {0: -0.65012, 1: -0.35660379990111464, 2: -0.8}, {0: -0.19041574084286472, 1: -0.3443074455424403, 2: -0.7}, {0: -0.20819395464, 1: -0.33699592683512467, 2: -0.7}, {0: -0.421064, 1: -0.30180866526242109, 2: -0.4}, {0: -0.32733845535848671, 1: -0.27321683125358037, 2: -0.5},
	{0: float32(0.65) * 23629.073922049845, 1: float32(0.65) * 8611.3238710010046, 2: float32(0.65) * 4492.2486445538634}, {0: -1.025, 1: -0.3041958212306401, 2: -1.2}, {0: -0.78, 1: 0.3633036457487539, 2: -1.2}, {0: -0.65012, 1: -0.35660379990111464, 2: -0.8}, {0: -0.19041574084286472, 1: -0.3443074455424403, 2: -0.7}, {0: -0.20819395464, 1: -0.33699592683512467, 2: -0.7}, {0: -0.421064, 1: -0.30180866526242109, 2: -0.4}, {0: -0.32733845535848671, 1: -0.27321683125358037, 2: -0.5},
	{0: float32(1.8) * 23629.073922049845, 1: float32(1.8) * 8611.3238710010046, 2: float32(1.8) * 4492.2486445538634}, {0: -1.025, 1: -0.3041958212306401, 2: -1.2}, {0: -0.78, 1: 0.3633036457487539, 2: -1.2}, {0: -0.65012, 1: -0.35660379990111464, 2: -0.8}, {0: -0.19041574084286472, 1: -0.3443074455424403, 2: -0.7}, {0: -0.20819395464, 1: -0.33699592683512467, 2: -0.7}, {0: -0.421064, 1: -0.30180866526242109, 2: -0.4}, {0: -0.32733845535848671, 1: -0.27321683125358037, 2: -0.5},
	{0: float32(1.3) * 23629.073922049845, 1: float32(1.3) * 8611.3238710010046, 2: float32(1.3) * 4492.2486445538634}, {0: -1.025, 1: -0.3041958212306401, 2: -1.2}, {0: -0.78, 1: 0.3633036457487539, 2: -1.2}, {0: -0.65012, 1: -0.35660379990111464, 2: -0.8}, {0: -0.19041574084286472, 1: -0.3443074455424403, 2: -0.7}, {0: -0.20819395464, 1: -0.33699592683512467, 2: -0.7}, {0: -0.421064, 1: -0.30180866526242109, 2: -0.4}, {0: -0.32733845535848671, 1: -0.27321683125358037, 2: -0.5},
	{0: float32(3.6) * 23629.073922049845, 1: float32(3.6) * 8611.3238710010046, 2: float32(3.6) * 4492.2486445538634}, {0: -1.025, 1: -0.3041958212306401, 2: -1.2}, {0: -0.78, 1: 0.3633036457487539, 2: -1.2}, {0: -0.65012, 1: -0.35660379990111464, 2: -0.8}, {0: -0.19041574084286472, 1: -0.3443074455424403, 2: -0.7}, {0: -0.20819395464, 1: -0.33699592683512467, 2: -0.7}, {0: -0.421064, 1: -0.30180866526242109, 2: -0.4}, {0: -0.32733845535848671, 1: -0.27321683125358037, 2: -0.5},
	{0: float32(2.6) * 23629.073922049845, 1: float32(2.6) * 8611.3238710010046, 2: float32(2.6) * 4492.2486445538634}, {0: -1.025, 1: -0.3041958212306401, 2: -1.2}, {0: -0.78, 1: 0.3633036457487539, 2: -1.2}, {0: -0.65012, 1: -0.35660379990111464, 2: -0.8}, {0: -0.19041574084286472, 1: -0.3443074455424403, 2: -0.7}, {0: -0.20819395464, 1: -0.33699592683512467, 2: -0.7}, {0: -0.421064, 1: -0.30180866526242109, 2: -0.4}, {0: -0.32733845535848671, 1: -0.27321683125358037, 2: -0.5},
}

var sJ40__LOG_ORDER_SIZE = [13][2]Int8_t{
	{int8(3), int8(3)}, {int8(3), int8(3)}, {int8(4), int8(4)}, {int8(5), int8(5)}, {int8(3), int8(4)}, {int8(3), int8(5)}, {int8(4), int8(5)}, {int8(6), int8(6)}, {int8(5), int8(6)}, {int8(7), int8(7)}, {int8(6), int8(7)}, {int8(8), int8(8)}, {int8(7), int8(8)},
}

func j40__read_dq_matrix(tls *libc.TLS, st uintptr, rows Int32_t, columns Int32_t, raw_sidx Int64_t, global_tree uintptr, global_codespec uintptr, dqmat uintptr) J40_err {
	bp := tls.Alloc(184)
	defer tls.Free(184)

	var c Int32_t
	var i Int32_t
	var j Int32_t
	var pixels uintptr
	var pixels1 uintptr
	var denom float32
	var inv_denom float32

	var x Int32_t
	var y Int32_t
	var n Int32_t
	var how How
	var paramsize Int32_t
	var paramidx Int32_t
	*(*J40__modular)(unsafe.Pointer(bp + 24)) = J40__modular{}

	(*J40__dq_matrix)(unsafe.Pointer(dqmat)).Mode = uint32(uint32(j40__u(tls, st, 3)))
	(*J40__dq_matrix)(unsafe.Pointer(dqmat)).Params = uintptr(0)
	if !((*J40__dq_matrix)(unsafe.Pointer(dqmat)).Mode == J40__DQ_ENC_RAW) {
		goto __1
	}

	denom = j40__f16(tls, st)

__3:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __6
	}
	goto J40__ON_ERROR
__6:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(J40__surely_nonzero(tls, denom) != 0)), int64(0)) != 0) {
		goto __7
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 494))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 494 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 494 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 494 + 3))))
	goto J40__ON_ERROR
__7:
	;
	goto __4
__4:
	if 0 != 0 {
		goto __3
	}
	goto __5
__5:
	;
	inv_denom = 1.0 / denom

	*(*Int32_t)(unsafe.Pointer(bp)) = libc.AssignPtrInt32(bp+1*4, libc.AssignPtrInt32(bp+2*4, columns))
	*(*Int32_t)(unsafe.Pointer(bp + 12)) = libc.AssignPtrInt32(bp+12+1*4, libc.AssignPtrInt32(bp+12+2*4, rows))
__8:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_modular(tls, st, 3, bp, bp+12, bp+24) != 0)), int64(0)) != 0) {
		goto __11
	}
	goto J40__ON_ERROR
__11:
	;
	goto __9
__9:
	if 0 != 0 {
		goto __8
	}
	goto __10
__10:
	;
__12:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__modular_header(tls, st, global_tree, global_codespec, bp+24) != 0)), int64(0)) != 0) {
		goto __15
	}
	goto J40__ON_ERROR
__15:
	;
	goto __13
__13:
	if 0 != 0 {
		goto __12
	}
	goto __14
__14:
	;
__16:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__allocate_modular(tls, st, bp+24) != 0)), int64(0)) != 0) {
		goto __19
	}
	goto J40__ON_ERROR
__19:
	;
	goto __17
__17:
	if 0 != 0 {
		goto __16
	}
	goto __18
__18:
	;
	c = 0
__20:
	if !(c < 3) {
		goto __22
	}
__23:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__modular_channel(tls, st, bp+24, c, raw_sidx) != 0)), int64(0)) != 0) {
		goto __26
	}
	goto J40__ON_ERROR
__26:
	;
	goto __24
__24:
	if 0 != 0 {
		goto __23
	}
	goto __25
__25:
	;
	goto __21
__21:
	c++
	goto __20
	goto __22
__22:
	;
__27:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__finish_and_free_code(tls, st, bp+24+96) != 0)), int64(0)) != 0) {
		goto __30
	}
	goto J40__ON_ERROR
__30:
	;
	goto __28
__28:
	if 0 != 0 {
		goto __27
	}
	goto __29
__29:
	;
__31:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__inverse_transform(tls, st, bp+24) != 0)), int64(0)) != 0) {
		goto __34
	}
	goto J40__ON_ERROR
__34:
	;
	goto __32
__32:
	if 0 != 0 {
		goto __31
	}
	goto __33
__33:
	;
__35:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __38
	}
	goto J40__ON_ERROR
__38:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(dqmat+8, j40__malloc(tls, uint64(16)*Size_t(rows*columns)))) != 0)), int64(0)) != 0) {
		goto __39
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__39:
	;
	goto __36
__36:
	if 0 != 0 {
		goto __35
	}
	goto __37
__37:
	;
	c = 0
__40:
	if !(c < 3) {
		goto __42
	}
	if !(int32((*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(bp+24)).Channel+uintptr(c)*24)).Type) == J40__PLANE_I16) {
		goto __43
	}
	y = 0
__45:
	if !(y < rows) {
		goto __47
	}
	pixels = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(bp+24)).Channel+uintptr(c)*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(bp+24)).Channel+uintptr(c)*24)).Stride_bytes)*Size_t(y))
	}()
	x = 0
__48:
	if !(x < columns) {
		goto __50
	}
	*(*float32)(unsafe.Pointer((*J40__dq_matrix)(unsafe.Pointer(dqmat)).Params + uintptr(y*columns+x)*16 + uintptr(c)*4)) = float32(*(*Int16_t)(unsafe.Pointer(pixels + uintptr(x)*2))) * inv_denom
	goto __49
__49:
	x++
	goto __48
	goto __50
__50:
	;
	goto __46
__46:
	y++
	goto __45
	goto __47
__47:
	;
	goto __44
__43:
	y = 0
__51:
	if !(y < rows) {
		goto __53
	}
	pixels1 = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(bp+24)).Channel+uintptr(c)*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(bp+24)).Channel+uintptr(c)*24)).Stride_bytes)*Size_t(y))
	}()
	x = 0
__54:
	if !(x < columns) {
		goto __56
	}
	*(*float32)(unsafe.Pointer((*J40__dq_matrix)(unsafe.Pointer(dqmat)).Params + uintptr(y*columns+x)*16 + uintptr(c)*4)) = float32(*(*Int32_t)(unsafe.Pointer(pixels1 + uintptr(x)*4))) * inv_denom
	goto __55
__55:
	x++
	goto __54
	goto __56
__56:
	;
	goto __52
__52:
	y++
	goto __51
	goto __53
__53:
	;
__44:
	;
	goto __41
__41:
	c++
	goto __40
	goto __42
__42:
	;
	j40__free_modular(tls, bp+24)
	(*J40__dq_matrix)(unsafe.Pointer(dqmat)).N = Int16_t(rows)
	(*J40__dq_matrix)(unsafe.Pointer(dqmat)).M = Int16_t(columns)
	goto __2
__1:
	how = HOW[(*J40__dq_matrix)(unsafe.Pointer(dqmat)).Mode]
	paramsize = int32(how.Nparams) + int32(how.Ndctparams)*16
	paramidx = Int32_t(how.Nparams)
	if !(how.Requires8x8 != 0) {
		goto __57
	}
__58:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __61
	}
	goto J40__ON_ERROR
__61:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(rows == 8 && columns == 8)), int64(0)) != 0) {
		goto __62
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 499))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 499 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 499 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 499 + 3))))
	goto J40__ON_ERROR
__62:
	;
	goto __59
__59:
	if 0 != 0 {
		goto __58
	}
	goto __60
__60:
	;
__57:
	;
	if !(paramsize != 0) {
		goto __63
	}
__64:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __67
	}
	goto J40__ON_ERROR
__67:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(dqmat+8, j40__malloc(tls, uint64(16)*Size_t(paramsize)))) != 0)), int64(0)) != 0) {
		goto __68
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__68:
	;
	goto __65
__65:
	if 0 != 0 {
		goto __64
	}
	goto __66
__66:
	;
	c = 0
__69:
	if !(c < 3) {
		goto __71
	}
	j = 0
__72:
	if !(j < Int32_t(how.Nparams)) {
		goto __74
	}
	*(*float32)(unsafe.Pointer((*J40__dq_matrix)(unsafe.Pointer(dqmat)).Params + uintptr(j)*16 + uintptr(c)*4)) = j40__f16(tls, st) * func() float32 {
		if j < Int32_t(how.Nscaled) {
			return 64.0
		}
		return 1.0
	}()
	goto __73
__73:
	j++
	goto __72
	goto __74
__74:
	;
	goto __70
__70:
	c++
	goto __69
	goto __71
__71:
	;
	i = 0
__75:
	if !(i < Int32_t(how.Ndctparams)) {
		goto __77
	}
	n = Int32_t(libc.AssignPtrInt16(func() uintptr {
		if i == 0 {
			return dqmat + 4
		}
		return dqmat + 6
	}(), Int16_t(j40__u(tls, st, 4)+1)))
	c = 0
__78:
	if !(c < 3) {
		goto __80
	}
	j = 0
__81:
	if !(j < n) {
		goto __83
	}
	*(*float32)(unsafe.Pointer((*J40__dq_matrix)(unsafe.Pointer(dqmat)).Params + uintptr(paramidx+j)*16 + uintptr(c)*4)) = j40__f16(tls, st) * func() float32 {
		if j == 0 {
			return 64.0
		}
		return 1.0
	}()
	goto __82
__82:
	j++
	goto __81
	goto __83
__83:
	;
	goto __79
__79:
	c++
	goto __78
	goto __80
__80:
	;
	paramidx = paramidx + n
	goto __76
__76:
	i++
	goto __75
	goto __77
__77:
	;
__63:
	;
__84:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __87
	}
	goto J40__ON_ERROR
__87:
	;
	goto __85
__85:
	if 0 != 0 {
		goto __84
	}
	goto __86
__86:
	;
__2:
	;
	return J40_err(0)

J40__ON_ERROR:
	j40__free(tls, (*J40__dq_matrix)(unsafe.Pointer(dqmat)).Params)
	(*J40__dq_matrix)(unsafe.Pointer(dqmat)).Params = uintptr(0)
	j40__free_modular(tls, bp+24)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

type How = struct {
	Requires8x8 Int8_t
	Nparams     Int8_t
	Nscaled     Int8_t
	Ndctparams  Int8_t
}

var HOW = [7]How{{}, {Requires8x8: int8(1), Nparams: int8(3), Nscaled: int8(3)}, {Requires8x8: int8(1), Nparams: int8(6), Nscaled: int8(6)}, {Requires8x8: int8(1), Nparams: int8(2), Nscaled: int8(2), Ndctparams: int8(1)}, {Requires8x8: int8(1), Nparams: int8(1), Ndctparams: int8(1)}, {Requires8x8: int8(1), Nparams: int8(9), Nscaled: int8(6), Ndctparams: int8(2)}, {Requires8x8: int8(1), Ndctparams: int8(1)}}

// piecewise exponential interpolation where pos is in [0,1], mapping pos = k/(len-1) to bands[k]
func j40__interpolate(tls *libc.TLS, pos float32, c Int32_t, bands uintptr, len Int32_t) float32 {
	var scaled_pos float32
	var frac_idx float32
	var a float32
	var b float32
	var scaled_idx Int32_t
	if len == 1 {
		return *(*float32)(unsafe.Pointer(bands + uintptr(c)*4))
	}
	scaled_pos = pos * float32(len-1)
	scaled_idx = Int32_t(scaled_pos)
	frac_idx = scaled_pos - float32(scaled_idx)
	a = *(*float32)(unsafe.Pointer(bands + uintptr(scaled_idx)*16 + uintptr(c)*4))
	b = *(*float32)(unsafe.Pointer(bands + uintptr(scaled_idx+1)*16 + uintptr(c)*4))
	return a * powf(tls, b/a, frac_idx)
}

func j40__interpolation_bands(tls *libc.TLS, st uintptr, params uintptr, nparams Int32_t, out uintptr) J40_err {
	var i Int32_t
	var c Int32_t
	var v float32
	c = 0
__1:
	if !(c < 3) {
		goto __3
	}

	*(*float32)(unsafe.Pointer(out + uintptr(c)*4)) = *(*float32)(unsafe.Pointer(params + uintptr(c)*4))
__4:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __7
	}
	goto J40__ON_ERROR
__7:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(*(*float32)(unsafe.Pointer(out + uintptr(c)*4)) > float32(0))), int64(0)) != 0) {
		goto __8
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 504))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 504 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 504 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 504 + 3))))
	goto J40__ON_ERROR
__8:
	;
	goto __5
__5:
	if 0 != 0 {
		goto __4
	}
	goto __6
__6:
	;
	i = 1
__9:
	if !(i < nparams) {
		goto __11
	}
	v = *(*float32)(unsafe.Pointer(params + uintptr(i)*16 + uintptr(c)*4))
	*(*float32)(unsafe.Pointer(out + uintptr(i)*16 + uintptr(c)*4)) = func() float32 {
		if v > float32(0) {
			return *(*float32)(unsafe.Pointer(out + uintptr(i-1)*16 + uintptr(c)*4)) * (1.0 + v)
		}
		return *(*float32)(unsafe.Pointer(out + uintptr(i-1)*16 + uintptr(c)*4)) / (1.0 - v)
	}()
__12:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __15
	}
	goto J40__ON_ERROR
__15:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(*(*float32)(unsafe.Pointer(out + uintptr(i)*16 + uintptr(c)*4)) > float32(0))), int64(0)) != 0) {
		goto __16
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 504))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 504 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 504 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 504 + 3))))
	goto J40__ON_ERROR
__16:
	;
	goto __13
__13:
	if 0 != 0 {
		goto __12
	}
	goto __14
__14:
	;
	goto __10
__10:
	i++
	goto __9
	goto __11
__11:
	;
	goto __2
__2:
	c++
	goto __1
	goto __3
__3:
	;
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__dct_quant_weights(tls *libc.TLS, rows Int32_t, columns Int32_t, bands uintptr, len Int32_t, out uintptr) {
	var inv_rows_m1 float32 = 1.0 / float32(rows-1)
	var inv_columns_m1 float32 = 1.0 / float32(columns-1)
	var x Int32_t
	var y Int32_t
	var c Int32_t
	for c = 0; c < 3; c++ {
		for y = 0; y < rows; y++ {
			for x = 0; x < columns; x++ {
				var d float32 = hypotf(tls, float32(x)*inv_columns_m1, float32(y)*inv_rows_m1)

				*(*float32)(unsafe.Pointer(out + uintptr(y*columns+x)*16 + uintptr(c)*4)) = j40__interpolate(tls, d*INV_SQRT2, c, bands, len)
			}
		}
	}
}

var INV_SQRT2 float32 = float32(1.0) / 1.414214562373095

// TODO spec issue: VarDCT uses the (row, column) notation, not the (x, y) notation; explicitly note this
// TODO spec improvement: spec can provide computed matrices for default parameters to aid verification
func j40__load_dq_matrix(tls *libc.TLS, st uintptr, idx Int32_t, dqmat uintptr) J40_err {
	bp := tls.Alloc(1264)
	defer tls.Free(1264)

	var dct J40__dct_params
	var mode uint32
	var rows Int32_t
	var columns Int32_t
	var n Int32_t
	var m Int32_t
	var params uintptr
	var raw uintptr

	var x Int32_t
	var y Int32_t
	var i Int32_t
	var c Int32_t
	dct = sJ40__DCT_PARAMS[idx]
	raw = uintptr(0)

	mode = uint32((*J40__dq_matrix)(unsafe.Pointer(dqmat)).Mode)
	if !(int32(mode) == J40__DQ_ENC_RAW) {
		goto __1
	}
	return J40_err(0)
	goto __2
__1:
	if !(int32(mode) == J40__DQ_ENC_LIBRARY) {
		goto __3
	}
	mode = uint32(dct.Def_mode)
	n = Int32_t(dct.Def_n)
	m = Int32_t(dct.Def_m)
	params = uintptr(unsafe.Pointer(&sJ40__LIBRARY_DCT_PARAMS)) + uintptr(dct.Def_offset)*16
	goto __4
__3:
	n = Int32_t((*J40__dq_matrix)(unsafe.Pointer(dqmat)).N)
	m = Int32_t((*J40__dq_matrix)(unsafe.Pointer(dqmat)).M)
	params = (*J40__dq_matrix)(unsafe.Pointer(dqmat)).Params
__4:
	;
__2:
	;
	rows = int32(1) << int32(dct.Log_rows)
	columns = int32(1) << int32(dct.Log_columns)
__5:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __8
	}
	goto J40__ON_ERROR
__8:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignUintptr(&raw, j40__malloc(tls, uint64(16)*Size_t(rows*columns)))) != 0)), int64(0)) != 0) {
		goto __9
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__9:
	;
	goto __6
__6:
	if 0 != 0 {
		goto __5
	}
	goto __7
__7:
	;
	switch mode {
	case J40__DQ_ENC_DCT:
		goto __11

	case J40__DQ_ENC_DCT4:
		goto __12

	case J40__DQ_ENC_DCT2:
		goto __13

	case J40__DQ_ENC_HORNUSS:
		goto __14

	case J40__DQ_ENC_DCT4X8:
		goto __15

	case J40__DQ_ENC_AFV:
		goto __16

	default:
		goto __17
	}
	goto __10
__11:
__18:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__interpolation_bands(tls, st, params, n, bp) != 0)), int64(0)) != 0) {
		goto __21
	}
	goto J40__ON_ERROR
__21:
	;
	goto __19
__19:
	if 0 != 0 {
		goto __18
	}
	goto __20
__20:
	;
	j40__dct_quant_weights(tls, rows, columns, bp, n, raw)
	goto __10

__12:
	;
__22:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__interpolation_bands(tls, st, params+uintptr(2)*16, n, bp) != 0)), int64(0)) != 0) {
		goto __25
	}
	goto J40__ON_ERROR
__25:
	;
	goto __23
__23:
	if 0 != 0 {
		goto __22
	}
	goto __24
__24:
	;
	j40__dct_quant_weights(tls, 4, 4, bp, n, bp+240)
	c = 0
__26:
	if !(c < 3) {
		goto __28
	}
	y = 0
__29:
	if !(y < 8) {
		goto __31
	}
	x = 0
__32:
	if !(x < 8) {
		goto __34
	}
	*(*float32)(unsafe.Pointer(raw + uintptr(y*8+x)*16 + uintptr(c)*4)) = *(*float32)(unsafe.Pointer(bp + 240 + uintptr(y/2*4+x/2)*16 + uintptr(c)*4))
	goto __33
__33:
	x++
	goto __32
	goto __34
__34:
	;
	goto __30
__30:
	y++
	goto __29
	goto __31
__31:
	;
	*(*float32)(unsafe.Pointer(raw + 1*16 + uintptr(c)*4)) /= *(*float32)(unsafe.Pointer(params + uintptr(c)*4))
	*(*float32)(unsafe.Pointer(raw + 8*16 + uintptr(c)*4)) /= *(*float32)(unsafe.Pointer(params + uintptr(c)*4))
	*(*float32)(unsafe.Pointer(raw + 9*16 + uintptr(c)*4)) /= *(*float32)(unsafe.Pointer(params + 1*16 + uintptr(c)*4))
	goto __27
__27:
	c++
	goto __26
	goto __28
__28:
	;
	goto __10

__13:
	;
	c = 0
__35:
	if !(c < 3) {
		goto __37
	}
	i = 0
__38:
	if !(i < 64) {
		goto __40
	}
	*(*float32)(unsafe.Pointer(raw + uintptr(i)*16 + uintptr(c)*4)) = *(*float32)(unsafe.Pointer(params + uintptr(MAP[i])*16 + uintptr(c)*4))
	goto __39
__39:
	i++
	goto __38
	goto __40
__40:
	;
	*(*float32)(unsafe.Pointer(raw + uintptr(c)*4)) = -1.0
	goto __36
__36:
	c++
	goto __35
	goto __37
__37:
	;
	goto __10

__14:
	;
	c = 0
__41:
	if !(c < 3) {
		goto __43
	}
	i = 0
__44:
	if !(i < 64) {
		goto __46
	}
	*(*float32)(unsafe.Pointer(raw + uintptr(i)*16 + uintptr(c)*4)) = *(*float32)(unsafe.Pointer(params + uintptr(c)*4))
	goto __45
__45:
	i++
	goto __44
	goto __46
__46:
	;
	*(*float32)(unsafe.Pointer(raw + uintptr(c)*4)) = 1.0
	*(*float32)(unsafe.Pointer(raw + 1*16 + uintptr(c)*4)) = libc.AssignPtrFloat32(raw+8*16+uintptr(c)*4, *(*float32)(unsafe.Pointer(params + 1*16 + uintptr(c)*4)))
	*(*float32)(unsafe.Pointer(raw + 9*16 + uintptr(c)*4)) = *(*float32)(unsafe.Pointer(params + 2*16 + uintptr(c)*4))
	goto __42
__42:
	c++
	goto __41
	goto __43
__43:
	;
	goto __10

__15:
	;
__47:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__interpolation_bands(tls, st, params+uintptr(1)*16, n, bp) != 0)), int64(0)) != 0) {
		goto __50
	}
	goto J40__ON_ERROR
__50:
	;
	goto __48
__48:
	if 0 != 0 {
		goto __47
	}
	goto __49
__49:
	;
	j40__dct_quant_weights(tls, 4, 8, bp, n, bp+240)
	c = 0
__51:
	if !(c < 3) {
		goto __53
	}
	y = 0
__54:
	if !(y < 8) {
		goto __56
	}
	x = 0
__57:
	if !(x < 8) {
		goto __59
	}
	*(*float32)(unsafe.Pointer(raw + uintptr(y*8+x)*16 + uintptr(c)*4)) = *(*float32)(unsafe.Pointer(bp + 240 + uintptr(y/2*8+x)*16 + uintptr(c)*4))
	goto __58
__58:
	x++
	goto __57
	goto __59
__59:
	;
	goto __55
__55:
	y++
	goto __54
	goto __56
__56:
	;
	*(*float32)(unsafe.Pointer(raw + 1*16 + uintptr(c)*4)) /= *(*float32)(unsafe.Pointer(params + uintptr(c)*4))
	goto __52
__52:
	c++
	goto __51
	goto __53
__53:
	;
	goto __10

__16:
	;
__60:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__interpolation_bands(tls, st, params+uintptr(9)*16, n, bp) != 0)), int64(0)) != 0) {
		goto __63
	}
	goto J40__ON_ERROR
__63:
	;
	goto __61
__61:
	if 0 != 0 {
		goto __60
	}
	goto __62
__62:
	;
	j40__dct_quant_weights(tls, 4, 8, bp, n, bp+240)
__64:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__interpolation_bands(tls, st, params+uintptr(9)*16+uintptr(n)*16, m, bp) != 0)), int64(0)) != 0) {
		goto __67
	}
	goto J40__ON_ERROR
__67:
	;
	goto __65
__65:
	if 0 != 0 {
		goto __64
	}
	goto __66
__66:
	;
	j40__dct_quant_weights(tls, 4, 4, bp, m, bp+240+uintptr(32)*16)
__68:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__interpolation_bands(tls, st, params+uintptr(5)*16, 4, bp) != 0)), int64(0)) != 0) {
		goto __71
	}
	goto J40__ON_ERROR
__71:
	;
	goto __69
__69:
	if 0 != 0 {
		goto __68
	}
	goto __70
__70:
	;
	c = 0
__72:
	if !(c < 3) {
		goto __74
	}
	*(*float32)(unsafe.Pointer(bp + 240 + uintptr(c)*4)) = *(*float32)(unsafe.Pointer(params + uintptr(c)*4))
	*(*float32)(unsafe.Pointer(bp + 240 + 32*16 + uintptr(c)*4)) = *(*float32)(unsafe.Pointer(params + 1*16 + uintptr(c)*4))
	i = 0
__75:
	if !(i < 12) {
		goto __77
	}
	*(*float32)(unsafe.Pointer(bp + 240 + uintptr(i+48)*16 + uintptr(c)*4)) = j40__interpolate(tls, FREQS[i], c, bp, 4)
	goto __76
__76:
	i++
	goto __75
	goto __77
__77:
	;
	*(*float32)(unsafe.Pointer(bp + 240 + 60*16 + uintptr(c)*4)) = 1.0
	i = 0
__78:
	if !(i < 3) {
		goto __80
	}
	*(*float32)(unsafe.Pointer(bp + 240 + uintptr(i+61)*16 + uintptr(c)*4)) = *(*float32)(unsafe.Pointer(params + uintptr(i+2)*16 + uintptr(c)*4))
	goto __79
__79:
	i++
	goto __78
	goto __80
__80:
	;
	goto __73
__73:
	c++
	goto __72
	goto __74
__74:
	;
	c = 0
__81:
	if !(c < 3) {
		goto __83
	}
	i = 0
__84:
	if !(i < 64) {
		goto __86
	}
	*(*float32)(unsafe.Pointer(raw + uintptr(i)*16 + uintptr(c)*4)) = *(*float32)(unsafe.Pointer(bp + 240 + uintptr(MAP1[i])*16 + uintptr(c)*4))
	goto __85
__85:
	i++
	goto __84
	goto __86
__86:
	;
	goto __82
__82:
	c++
	goto __81
	goto __83
__83:
	;
	goto __10

__17:
	;
__10:
	;
	j40__free(tls, (*J40__dq_matrix)(unsafe.Pointer(dqmat)).Params)
	(*J40__dq_matrix)(unsafe.Pointer(dqmat)).Mode = J40__DQ_ENC_RAW
	(*J40__dq_matrix)(unsafe.Pointer(dqmat)).N = Int16_t(rows)
	(*J40__dq_matrix)(unsafe.Pointer(dqmat)).M = Int16_t(columns)
	(*J40__dq_matrix)(unsafe.Pointer(dqmat)).Params = raw
	return J40_err(0)

J40__ON_ERROR:
	j40__free(tls, raw)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

var MAP = [64]Int8_t{
	int8(0), int8(0), int8(2), int8(2), int8(4), int8(4), int8(4), int8(4),
	int8(0), int8(1), int8(2), int8(2), int8(4), int8(4), int8(4), int8(4),
	int8(2), int8(2), int8(3), int8(3), int8(4), int8(4), int8(4), int8(4),
	int8(2), int8(2), int8(3), int8(3), int8(4), int8(4), int8(4), int8(4),
	int8(4), int8(4), int8(4), int8(4), int8(5), int8(5), int8(5), int8(5),
	int8(4), int8(4), int8(4), int8(4), int8(5), int8(5), int8(5), int8(5),
	int8(4), int8(4), int8(4), int8(4), int8(5), int8(5), int8(5), int8(5),
	int8(4), int8(4), int8(4), int8(4), int8(5), int8(5), int8(5), int8(5),
}
var FREQS = [12]float32{
	0.000000000, 0.373436417, 0.320380100, 0.379332596, 0.066671353, 0.259756761,
	0.530035651, 0.789731061, 0.149436598, 0.559318823, 0.669198646, 0.999999917,
}
var MAP1 = [64]Int8_t{
	int8(60), int8(32), int8(62), int8(33), int8(48), int8(34), int8(49), int8(35),
	int8(0), int8(1), int8(2), int8(3), int8(4), int8(5), int8(6), int8(7),
	int8(61), int8(36), int8(63), int8(37), int8(50), int8(38), int8(51), int8(39),
	int8(8), int8(9), int8(10), int8(11), int8(12), int8(13), int8(14), int8(15),
	int8(52), int8(40), int8(53), int8(41), int8(54), int8(42), int8(55), int8(43),
	int8(16), int8(17), int8(18), int8(19), int8(20), int8(21), int8(22), int8(23),
	int8(56), int8(44), int8(57), int8(45), int8(58), int8(46), int8(59), int8(47),
	int8(24), int8(25), int8(26), int8(27), int8(28), int8(29), int8(30), int8(31),
}

func j40__free_dq_matrix(tls *libc.TLS, dqmat uintptr) {
	if (*J40__dq_matrix)(unsafe.Pointer(dqmat)).Mode != J40__DQ_ENC_LIBRARY {
		j40__free(tls, (*J40__dq_matrix)(unsafe.Pointer(dqmat)).Params)
	}
	(*J40__dq_matrix)(unsafe.Pointer(dqmat)).Mode = J40__DQ_ENC_LIBRARY
	(*J40__dq_matrix)(unsafe.Pointer(dqmat)).Params = uintptr(0)
}

func j40__natural_order(tls *libc.TLS, st uintptr, log_rows Int32_t, log_columns Int32_t, out uintptr) J40_err {
	var size Int32_t
	var log_slope Int32_t
	var rows8 Int32_t
	var columns8 Int32_t
	var order uintptr
	var y Int32_t
	var x Int32_t
	var key1 Int32_t
	var o Int32_t
	var excess Int32_t
	var excess1 Int32_t

	var x0 Int32_t
	var y0 Int32_t
	var x1 Int32_t
	var y1 Int32_t
	size = int32(1) << (log_rows + log_columns)
	log_slope = log_columns - log_rows
	rows8 = int32(1) << (log_rows - 3)
	columns8 = int32(1) << (log_columns - 3)
	order = uintptr(0)

__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignUintptr(&order, j40__malloc(tls, uint64(unsafe.Sizeof(Int32_t(0)))*Size_t(size)))) != 0)), int64(0)) != 0) {
		goto __5
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__5:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
	o = 0
	y = 0
__6:
	if !(y < rows8) {
		goto __8
	}
	x = 0
__9:
	if !(x < columns8) {
		goto __11
	}
	*(*Int32_t)(unsafe.Pointer(order + uintptr(libc.PostIncInt32(&o, 1))*4)) = y<<log_columns | x
	goto __10
__10:
	x++
	goto __9
	goto __11
__11:
	;
	goto __7
__7:
	y++
	goto __6
	goto __8
__8:
	;
	key1 = int32(1) << (log_columns - 3)
__12:
	if !(o < size) {
		goto __14
	}

	x0 = key1 & (int32(1)<<log_slope - 1)
	y0 = key1 >> log_slope
	x1 = key1
	y1 = 0
	if !(x1 >= int32(1)<<log_columns) {
		goto __15
	}
	excess = J40__ceil_div32(tls, x1-(int32(1)<<log_columns-1), int32(1)<<log_slope)
	x1 = x1 - excess<<log_slope
	y1 = y1 + excess

__15:
	;
	if !(y0 >= int32(1)<<log_rows) {
		goto __16
	}
	excess1 = y0 - (int32(1)<<log_rows - 1)
	x0 = x0 + excess1<<log_slope
	y0 = y0 - excess1

__16:
	;
	if !(key1&1 != 0) {
		goto __17
	}
	x = x1
	y = y1
__19:
	if !(x >= x0) {
		goto __21
	}

	if !(y >= rows8 || x >= columns8) {
		goto __22
	}
	*(*Int32_t)(unsafe.Pointer(order + uintptr(libc.PostIncInt32(&o, 1))*4)) = y<<log_columns | x
__22:
	;
	goto __20
__20:
	x = x - int32(1)<<log_slope
	y++
	goto __19
	goto __21
__21:
	;
	goto __18
__17:
	x = x0
	y = y0
__23:
	if !(x <= x1) {
		goto __25
	}
	if !(y >= rows8 || x >= columns8) {
		goto __26
	}
	*(*Int32_t)(unsafe.Pointer(order + uintptr(libc.PostIncInt32(&o, 1))*4)) = y<<log_columns | x
__26:
	;
	goto __24
__24:
	x = x + int32(1)<<log_slope
	y--
	goto __23
	goto __25
__25:
	;
__18:
	;
	goto __13
__13:
	key1++
	goto __12
	goto __14
__14:
	;
	*(*uintptr)(unsafe.Pointer(out)) = order
	return J40_err(0)

J40__ON_ERROR:
	j40__free(tls, order)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

type J40__blend_info = struct {
	Mode          Int8_t
	Alpha_chan    Int8_t
	Clamp         Int8_t
	Src_ref_frame Int8_t
}

const (
	J40__FRAME_REGULAR          = 0
	J40__FRAME_LF               = 1
	J40__FRAME_REFONLY          = 2
	J40__FRAME_REGULAR_SKIPPROG = 3
)

type J40__frame_st = J40__frame_st1

func j40__free_frame_state(tls *libc.TLS, f uintptr) {
	var i Int32_t
	var j Int32_t
	var k Int32_t
	j40__free(tls, (*J40__frame_st)(unsafe.Pointer(f)).Ec_log_upsampling)
	j40__free(tls, (*J40__frame_st)(unsafe.Pointer(f)).Ec_blend_info)
	j40__free(tls, (*J40__frame_st)(unsafe.Pointer(f)).Name)
	j40__free(tls, (*J40__frame_st)(unsafe.Pointer(f)).Global_tree)
	j40__free_code_spec(tls, f+328)
	j40__free_modular(tls, f+384)
	j40__free(tls, (*J40__frame_st)(unsafe.Pointer(f)).Block_ctx_map)
	for i = 0; i < J40__NUM_DCT_PARAMS; i++ {
		j40__free_dq_matrix(tls, f+872+uintptr(i)*16)
	}
	for i = 0; i < J40__MAX_PASSES; i++ {
		for j = 0; j < J40__NUM_ORDERS; j++ {
			for k = 0; k < 3; k++ {
				j40__free(tls, *(*uintptr)(unsafe.Pointer(f + 1152 + uintptr(i)*312 + uintptr(j)*24 + uintptr(k)*8)))
				*(*uintptr)(unsafe.Pointer(f + 1152 + uintptr(i)*312 + uintptr(j)*24 + uintptr(k)*8)) = uintptr(0)
			}
		}
		j40__free_code_spec(tls, f+4584+uintptr(i)*56)
	}
	(*J40__frame_st)(unsafe.Pointer(f)).Ec_log_upsampling = uintptr(0)
	(*J40__frame_st)(unsafe.Pointer(f)).Ec_blend_info = uintptr(0)
	(*J40__frame_st)(unsafe.Pointer(f)).Name = uintptr(0)
	(*J40__frame_st)(unsafe.Pointer(f)).Global_tree = uintptr(0)
	(*J40__frame_st)(unsafe.Pointer(f)).Block_ctx_map = uintptr(0)
}

func j40__frame_header(tls *libc.TLS, st uintptr) J40_err {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var im uintptr
	var f uintptr
	var i Int32_t
	var j Int32_t
	var pass Int32_t

	var ppass Int32_t
	var num_ds Int32_t
	var blend uintptr
	var restoration_all_default int32
	var full_frame int32
	var flags Uint64_t
	im = (*J40__st)(unsafe.Pointer(st)).Image
	f = (*J40__st)(unsafe.Pointer(st)).Frame

	(*J40__frame_st)(unsafe.Pointer(f)).Is_last = 1
	(*J40__frame_st)(unsafe.Pointer(f)).Type = J40__FRAME_REGULAR
	(*J40__frame_st)(unsafe.Pointer(f)).Is_modular = 0
	(*J40__frame_st)(unsafe.Pointer(f)).Has_noise = libc.AssignPtrInt32(f+16, libc.AssignPtrInt32(f+20, libc.AssignPtrInt32(f+24, libc.AssignPtrInt32(f+28, 0))))
	(*J40__frame_st)(unsafe.Pointer(f)).Do_ycbcr = 0
	(*J40__frame_st)(unsafe.Pointer(f)).Jpeg_upsampling = 0
	(*J40__frame_st)(unsafe.Pointer(f)).Log_upsampling = 0
	(*J40__frame_st)(unsafe.Pointer(f)).Ec_log_upsampling = uintptr(0)
	(*J40__frame_st)(unsafe.Pointer(f)).Group_size_shift = 8
	(*J40__frame_st)(unsafe.Pointer(f)).X_qm_scale = 3
	(*J40__frame_st)(unsafe.Pointer(f)).B_qm_scale = 2
	(*J40__frame_st)(unsafe.Pointer(f)).Num_passes = 1
	*(*Int8_t)(unsafe.Pointer(f + 72)) = int8(0)
	*(*Int8_t)(unsafe.Pointer(f + 83)) = int8(3)
	*(*Int8_t)(unsafe.Pointer(f + 83 + 1)) = int8(0)
	(*J40__frame_st)(unsafe.Pointer(f)).Lf_level = 0
	(*J40__frame_st)(unsafe.Pointer(f)).X0 = libc.AssignPtrInt32(f+104, 0)
	(*J40__frame_st)(unsafe.Pointer(f)).Width = (*J40__image_st)(unsafe.Pointer(im)).Width
	(*J40__frame_st)(unsafe.Pointer(f)).Height = (*J40__image_st)(unsafe.Pointer(im)).Height
	(*J40__frame_st)(unsafe.Pointer(f)).Duration = libc.AssignPtrInt64(f+160, int64(0))
	(*J40__frame_st)(unsafe.Pointer(f)).Blend_info.Mode = J40__BLEND_REPLACE
	(*J40__frame_st)(unsafe.Pointer(f)).Blend_info.Alpha_chan = int8(0)
	(*J40__frame_st)(unsafe.Pointer(f)).Blend_info.Clamp = int8(0)
	(*J40__frame_st)(unsafe.Pointer(f)).Blend_info.Src_ref_frame = int8(0)
	(*J40__frame_st)(unsafe.Pointer(f)).Ec_blend_info = uintptr(0)
	(*J40__frame_st)(unsafe.Pointer(f)).Save_as_ref = 0
	(*J40__frame_st)(unsafe.Pointer(f)).Save_before_ct = 1
	(*J40__frame_st)(unsafe.Pointer(f)).Name_len = 0
	(*J40__frame_st)(unsafe.Pointer(f)).Name = uintptr(0)
	(*J40__frame_st)(unsafe.Pointer(f)).Gab.Enabled = 1
	*(*float32)(unsafe.Pointer(f + 208 + 4)) = libc.AssignPtrFloat32(f+208+4+1*8, libc.AssignPtrFloat32(f+208+4+2*8, 0.115169525))
	*(*float32)(unsafe.Pointer(f + 208 + 4 + 1*4)) = libc.AssignPtrFloat32(f+208+4+1*8+1*4, libc.AssignPtrFloat32(f+208+4+2*8+1*4, 0.061248592))
	(*J40__frame_st)(unsafe.Pointer(f)).Epf.Iters = 2
	i = 0
__1:
	if !(i < 8) {
		goto __3
	}
	*(*float32)(unsafe.Pointer(f + 236 + 4 + uintptr(i)*4)) = float32(i) / 7.0
	goto __2
__2:
	i++
	goto __1
	goto __3
__3:
	;
	*(*float32)(unsafe.Pointer(f + 236 + 36)) = 40.0
	*(*float32)(unsafe.Pointer(f + 236 + 36 + 1*4)) = 5.0
	*(*float32)(unsafe.Pointer(f + 236 + 36 + 2*4)) = 3.5
	(*J40__frame_st)(unsafe.Pointer(f)).Epf.Quant_mul = 0.46
	(*J40__frame_st)(unsafe.Pointer(f)).Epf.Pass0_sigma_scale = 0.9
	(*J40__frame_st)(unsafe.Pointer(f)).Epf.Pass2_sigma_scale = 6.5
	(*J40__frame_st)(unsafe.Pointer(f)).Epf.Border_sad_mul = float32(2.0) / 3.0
	(*J40__frame_st)(unsafe.Pointer(f)).Epf.Sigma_for_modular = 1.0

	*(*float32)(unsafe.Pointer(f + 304)) = float32(1.0) / 4096.0
	*(*float32)(unsafe.Pointer(f + 304 + 1*4)) = float32(1.0) / 512.0
	*(*float32)(unsafe.Pointer(f + 304 + 2*4)) = float32(1.0) / 256.0
	(*J40__frame_st)(unsafe.Pointer(f)).Global_tree = uintptr(0)
	libc.Xmemset(tls, f+328, 0, uint64(unsafe.Sizeof(J40__code_spec{})))
	libc.Xmemset(tls, f+384, 0, uint64(unsafe.Sizeof(J40__modular{})))
	(*J40__frame_st)(unsafe.Pointer(f)).Block_ctx_map = uintptr(0)
	(*J40__frame_st)(unsafe.Pointer(f)).Inv_colour_factor = float32(float32(1)) / 84.0
	(*J40__frame_st)(unsafe.Pointer(f)).X_factor_lf = 0
	(*J40__frame_st)(unsafe.Pointer(f)).B_factor_lf = 0
	(*J40__frame_st)(unsafe.Pointer(f)).Base_corr_x = 0.0
	(*J40__frame_st)(unsafe.Pointer(f)).Base_corr_b = 1.0
	(*J40__frame_st)(unsafe.Pointer(f)).Dct_select_used = libc.AssignPtrInt32(f+856, 0)
	(*J40__frame_st)(unsafe.Pointer(f)).Order_used = libc.AssignPtrInt32(f+864, 0)
	libc.Xmemset(tls, f+872, 0, uint64(unsafe.Sizeof([17]J40__dq_matrix{})))
	libc.Xmemset(tls, f+1152, 0, uint64(unsafe.Sizeof([11][13][3]uintptr{})))
	libc.Xmemset(tls, f+4584, 0, uint64(unsafe.Sizeof([11]J40__code_spec{})))

__4:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__zero_pad_to_byte(tls, st) != 0)), int64(0)) != 0) {
		goto __7
	}
	goto J40__ON_ERROR
__7:
	;
	goto __5
__5:
	if 0 != 0 {
		goto __4
	}
	goto __6
__6:
	;
	if !!(j40__u(tls, st, 1) != 0) {
		goto __8
	}
	full_frame = 1
	(*J40__frame_st)(unsafe.Pointer(f)).Type = uint32(uint32(j40__u(tls, st, 2)))
	(*J40__frame_st)(unsafe.Pointer(f)).Is_modular = j40__u(tls, st, 1)
	flags = j40__u64(tls, st)
	(*J40__frame_st)(unsafe.Pointer(f)).Has_noise = int32(flags & uint64(1))
	(*J40__frame_st)(unsafe.Pointer(f)).Has_patches = int32(flags >> 1 & uint64(1))
	(*J40__frame_st)(unsafe.Pointer(f)).Has_splines = int32(flags >> 4 & uint64(1))
	(*J40__frame_st)(unsafe.Pointer(f)).Use_lf_frame = int32(flags >> 5 & uint64(1))
	(*J40__frame_st)(unsafe.Pointer(f)).Skip_adapt_lf_smooth = int32(flags >> 7 & uint64(1))
	if !!((*J40__image_st)(unsafe.Pointer(im)).Xyb_encoded != 0) {
		goto __9
	}
	(*J40__frame_st)(unsafe.Pointer(f)).Do_ycbcr = j40__u(tls, st, 1)
__9:
	;
	if !!((*J40__frame_st)(unsafe.Pointer(f)).Use_lf_frame != 0) {
		goto __10
	}
	if !((*J40__frame_st)(unsafe.Pointer(f)).Do_ycbcr != 0) {
		goto __11
	}
	(*J40__frame_st)(unsafe.Pointer(f)).Jpeg_upsampling = j40__u(tls, st, 6)
__11:
	;
	(*J40__frame_st)(unsafe.Pointer(f)).Log_upsampling = j40__u(tls, st, 2)
__12:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __15
	}
	goto J40__ON_ERROR
__15:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__frame_st)(unsafe.Pointer(f)).Log_upsampling == 0)), int64(0)) != 0) {
		goto __16
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 509))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 509 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 509 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 509 + 3))))
	goto J40__ON_ERROR
__16:
	;
	goto __13
__13:
	if 0 != 0 {
		goto __12
	}
	goto __14
__14:
	;
__17:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __20
	}
	goto J40__ON_ERROR
__20:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(f+48, j40__malloc(tls, uint64(unsafe.Sizeof(Int32_t(0)))*Size_t((*J40__image_st)(unsafe.Pointer(im)).Num_extra_channels)))) != 0)), int64(0)) != 0) {
		goto __21
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__21:
	;
	goto __18
__18:
	if 0 != 0 {
		goto __17
	}
	goto __19
__19:
	;
	i = 0
__22:
	if !(i < (*J40__image_st)(unsafe.Pointer(im)).Num_extra_channels) {
		goto __24
	}
	*(*Int32_t)(unsafe.Pointer((*J40__frame_st)(unsafe.Pointer(f)).Ec_log_upsampling + uintptr(i)*4)) = j40__u(tls, st, 2)
__25:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __28
	}
	goto J40__ON_ERROR
__28:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(*(*Int32_t)(unsafe.Pointer((*J40__frame_st)(unsafe.Pointer(f)).Ec_log_upsampling + uintptr(i)*4)) == 0)), int64(0)) != 0) {
		goto __29
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 509))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 509 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 509 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 509 + 3))))
	goto J40__ON_ERROR
__29:
	;
	goto __26
__26:
	if 0 != 0 {
		goto __25
	}
	goto __27
__27:
	;
	goto __23
__23:
	i++
	goto __22
	goto __24
__24:
	;
__10:
	;
	if !((*J40__frame_st)(unsafe.Pointer(f)).Is_modular != 0) {
		goto __30
	}
	(*J40__frame_st)(unsafe.Pointer(f)).Group_size_shift = 7 + j40__u(tls, st, 2)
	goto __31
__30:
	if !((*J40__image_st)(unsafe.Pointer(im)).Xyb_encoded != 0) {
		goto __32
	}
	(*J40__frame_st)(unsafe.Pointer(f)).X_qm_scale = j40__u(tls, st, 3)
	(*J40__frame_st)(unsafe.Pointer(f)).B_qm_scale = j40__u(tls, st, 3)
__32:
	;
__31:
	;
	if !((*J40__frame_st)(unsafe.Pointer(f)).Type != J40__FRAME_REFONLY) {
		goto __33
	}
	(*J40__frame_st)(unsafe.Pointer(f)).Num_passes = j40__u32(tls, st, 1, 0, 2, 0, 3, 0, 4, 3)
	if !((*J40__frame_st)(unsafe.Pointer(f)).Num_passes > 1) {
		goto __34
	}
	ppass = 0
	num_ds = j40__u32(tls, st, 0, 0, 1, 0, 2, 0, 3, 1)
__35:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __38
	}
	goto J40__ON_ERROR
__38:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(num_ds < (*J40__frame_st)(unsafe.Pointer(f)).Num_passes)), int64(0)) != 0) {
		goto __39
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 549))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 549 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 549 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 549 + 3))))
	goto J40__ON_ERROR
__39:
	;
	goto __36
__36:
	if 0 != 0 {
		goto __35
	}
	goto __37
__37:
	;
	i = 0
__40:
	if !(i < (*J40__frame_st)(unsafe.Pointer(f)).Num_passes-1) {
		goto __42
	}
	*(*Int8_t)(unsafe.Pointer(f + 72 + uintptr(i))) = Int8_t(j40__u(tls, st, 2))
	goto __41
__41:
	i++
	goto __40
	goto __42
__42:
	;
	*(*Int8_t)(unsafe.Pointer(f + 72 + uintptr((*J40__frame_st)(unsafe.Pointer(f)).Num_passes-1))) = int8(0)
	i = 0
__43:
	if !(i < num_ds) {
		goto __45
	}
	*(*Int8_t)(unsafe.Pointer(bp + uintptr(i))) = Int8_t(j40__u(tls, st, 2))
	if !(i > 0) {
		goto __46
	}
__47:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __50
	}
	goto J40__ON_ERROR
__50:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(*(*Int8_t)(unsafe.Pointer(bp + uintptr(i-1)))) >= int32(*(*Int8_t)(unsafe.Pointer(bp + uintptr(i)))))), int64(0)) != 0) {
		goto __51
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 549))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 549 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 549 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 549 + 3))))
	goto J40__ON_ERROR
__51:
	;
	goto __48
__48:
	if 0 != 0 {
		goto __47
	}
	goto __49
__49:
	;
__46:
	;
	goto __44
__44:
	i++
	goto __43
	goto __45
__45:
	;
	i = 0
__52:
	if !(i < num_ds) {
		goto __54
	}
	pass = j40__u32(tls, st, 0, 0, 1, 0, 2, 0, 0, 3)
__55:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __58
	}
	goto J40__ON_ERROR
__58:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(func() int32 {
		if i > 0 {
			return libc.Bool32(ppass < pass && pass < (*J40__frame_st)(unsafe.Pointer(f)).Num_passes)
		}
		return libc.Bool32(pass == 0)
	}() != 0)), int64(0)) != 0) {
		goto __59
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 549))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 549 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 549 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 549 + 3))))
	goto J40__ON_ERROR
__59:
	;
	goto __56
__56:
	if 0 != 0 {
		goto __55
	}
	goto __57
__57:
	;
__60:
	if !(ppass < pass) {
		goto __61
	}
	*(*Int8_t)(unsafe.Pointer(f + 83 + uintptr(libc.PreIncInt32(&ppass, 1)))) = func() int8 {
		if i > 0 {
			return *(*Int8_t)(unsafe.Pointer(bp + uintptr(i-1)))
		}
		return int8(3)
	}()
	goto __60
__61:
	;
	goto __53
__53:
	i++
	goto __52
	goto __54
__54:
	;
__62:
	if !(ppass < (*J40__frame_st)(unsafe.Pointer(f)).Num_passes) {
		goto __63
	}
	*(*Int8_t)(unsafe.Pointer(f + 83 + uintptr(libc.PreIncInt32(&ppass, 1)))) = func() int8 {
		if i > 0 {
			return *(*Int8_t)(unsafe.Pointer(bp + uintptr(num_ds-1)))
		}
		return int8(3)
	}()
	goto __62
__63:
	;
__34:
	;
__33:
	;
	if !((*J40__frame_st)(unsafe.Pointer(f)).Type == J40__FRAME_LF) {
		goto __64
	}
	(*J40__frame_st)(unsafe.Pointer(f)).Lf_level = j40__u(tls, st, 2) + 1
	goto __65
__64:
	if !(j40__u(tls, st, 1) != 0) {
		goto __66
	}
	if !((*J40__frame_st)(unsafe.Pointer(f)).Type != J40__FRAME_REFONLY) {
		goto __67
	}
	(*J40__frame_st)(unsafe.Pointer(f)).X0 = J40__unpack_signed(tls, j40__u32(tls, st, 0, 8, 256, 11, 2304, 14, 18688, 30))
	(*J40__frame_st)(unsafe.Pointer(f)).Y0 = J40__unpack_signed(tls, j40__u32(tls, st, 0, 8, 256, 11, 2304, 14, 18688, 30))
__67:
	;
	(*J40__frame_st)(unsafe.Pointer(f)).Width = j40__u32(tls, st, 0, 8, 256, 11, 2304, 14, 18688, 30)
	(*J40__frame_st)(unsafe.Pointer(f)).Height = j40__u32(tls, st, 0, 8, 256, 11, 2304, 14, 18688, 30)
__68:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __71
	}
	goto J40__ON_ERROR
__71:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__frame_st)(unsafe.Pointer(f)).Width <= (*J40__limits1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Limits)).Width && (*J40__frame_st)(unsafe.Pointer(f)).Height <= (*J40__limits1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Limits)).Height)), int64(0)) != 0) {
		goto __72
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 184))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 184 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 184 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 184 + 3))))
	goto J40__ON_ERROR
__72:
	;
	goto __69
__69:
	if 0 != 0 {
		goto __68
	}
	goto __70
__70:
	;
__73:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __76
	}
	goto J40__ON_ERROR
__76:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Int64_t((*J40__frame_st)(unsafe.Pointer(f)).Width)*Int64_t((*J40__frame_st)(unsafe.Pointer(f)).Height) <= (*J40__limits1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Limits)).Pixels)), int64(0)) != 0) {
		goto __77
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 184))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 184 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 184 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 184 + 3))))
	goto J40__ON_ERROR
__77:
	;
	goto __74
__74:
	if 0 != 0 {
		goto __73
	}
	goto __75
__75:
	;
	full_frame = libc.Bool32((*J40__frame_st)(unsafe.Pointer(f)).X0 <= 0 && (*J40__frame_st)(unsafe.Pointer(f)).Y0 <= 0 && (*J40__frame_st)(unsafe.Pointer(f)).Width+(*J40__frame_st)(unsafe.Pointer(f)).X0 >= (*J40__image_st)(unsafe.Pointer(im)).Width && (*J40__frame_st)(unsafe.Pointer(f)).Height+(*J40__frame_st)(unsafe.Pointer(f)).Y0 >= (*J40__image_st)(unsafe.Pointer(im)).Height)
__66:
	;
__65:
	;
	if !((*J40__frame_st)(unsafe.Pointer(f)).Type == J40__FRAME_REGULAR || (*J40__frame_st)(unsafe.Pointer(f)).Type == J40__FRAME_REGULAR_SKIPPROG) {
		goto __78
	}
__80:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __83
	}
	goto J40__ON_ERROR
__83:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(f+176, j40__malloc(tls, uint64(unsafe.Sizeof(J40__blend_info{}))*Size_t((*J40__image_st)(unsafe.Pointer(im)).Num_extra_channels)))) != 0)), int64(0)) != 0) {
		goto __84
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__84:
	;
	goto __81
__81:
	if 0 != 0 {
		goto __80
	}
	goto __82
__82:
	;
	i = -1
__85:
	if !(i < (*J40__image_st)(unsafe.Pointer(im)).Num_extra_channels) {
		goto __87
	}
	if i < 0 {
		blend = f + 168
	} else {
		blend = (*J40__frame_st)(unsafe.Pointer(f)).Ec_blend_info + uintptr(i)*4
	}
	(*J40__blend_info)(unsafe.Pointer(blend)).Mode = Int8_t(j40__u32(tls, st, 0, 0, 1, 0, 2, 0, 3, 2))
	if !((*J40__image_st)(unsafe.Pointer(im)).Num_extra_channels > 0) {
		goto __88
	}
	if !(int32((*J40__blend_info)(unsafe.Pointer(blend)).Mode) == J40__BLEND_BLEND || int32((*J40__blend_info)(unsafe.Pointer(blend)).Mode) == J40__BLEND_MUL_ADD) {
		goto __89
	}
	(*J40__blend_info)(unsafe.Pointer(blend)).Alpha_chan = Int8_t(j40__u32(tls, st, 0, 0, 1, 0, 2, 0, 3, 3))
	(*J40__blend_info)(unsafe.Pointer(blend)).Clamp = Int8_t(j40__u(tls, st, 1))
	goto __90
__89:
	if !(int32((*J40__blend_info)(unsafe.Pointer(blend)).Mode) == J40__BLEND_MUL) {
		goto __91
	}
	(*J40__blend_info)(unsafe.Pointer(blend)).Clamp = Int8_t(j40__u(tls, st, 1))
__91:
	;
__90:
	;
__88:
	;
	if !(!(full_frame != 0) || int32((*J40__blend_info)(unsafe.Pointer(blend)).Mode) != J40__BLEND_REPLACE) {
		goto __92
	}
	(*J40__blend_info)(unsafe.Pointer(blend)).Src_ref_frame = Int8_t(j40__u(tls, st, 2))
__92:
	;
	goto __86
__86:
	i++
	goto __85
	goto __87
__87:
	;
	if !((*J40__image_st)(unsafe.Pointer(im)).Anim_tps_denom != 0) {
		goto __93
	}
	(*J40__frame_st)(unsafe.Pointer(f)).Duration = j40__64u32(tls, st, 0, 0, 1, 0, 0, 8, 0, 32)
	if !((*J40__image_st)(unsafe.Pointer(im)).Anim_have_timecodes != 0) {
		goto __94
	}
	(*J40__frame_st)(unsafe.Pointer(f)).Timecode = j40__64u(tls, st, 32)
__94:
	;
__93:
	;
	(*J40__frame_st)(unsafe.Pointer(f)).Is_last = j40__u(tls, st, 1)
	goto __79
__78:
	(*J40__frame_st)(unsafe.Pointer(f)).Is_last = 0
__79:
	;
	if !((*J40__frame_st)(unsafe.Pointer(f)).Type != J40__FRAME_LF && !((*J40__frame_st)(unsafe.Pointer(f)).Is_last != 0)) {
		goto __95
	}
	(*J40__frame_st)(unsafe.Pointer(f)).Save_as_ref = j40__u(tls, st, 2)
__95:
	;
	if !((*J40__frame_st)(unsafe.Pointer(f)).Type == J40__FRAME_REFONLY || full_frame != 0 && ((*J40__frame_st)(unsafe.Pointer(f)).Type == J40__FRAME_REGULAR || (*J40__frame_st)(unsafe.Pointer(f)).Type == J40__FRAME_REGULAR_SKIPPROG) && int32((*J40__frame_st)(unsafe.Pointer(f)).Blend_info.Mode) == J40__BLEND_REPLACE && ((*J40__frame_st)(unsafe.Pointer(f)).Duration == int64(0) || (*J40__frame_st)(unsafe.Pointer(f)).Save_as_ref != 0) && !((*J40__frame_st)(unsafe.Pointer(f)).Is_last != 0)) {
		goto __96
	}
	(*J40__frame_st)(unsafe.Pointer(f)).Save_before_ct = j40__u(tls, st, 1)
	goto __97
__96:
	(*J40__frame_st)(unsafe.Pointer(f)).Save_before_ct = libc.Bool32((*J40__frame_st)(unsafe.Pointer(f)).Type == J40__FRAME_LF)
__97:
	;
__98:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__name(tls, st, f+192, f+200) != 0)), int64(0)) != 0) {
		goto __101
	}
	goto J40__ON_ERROR
__101:
	;
	goto __99
__99:
	if 0 != 0 {
		goto __98
	}
	goto __100
__100:
	;
	restoration_all_default = j40__u(tls, st, 1)
	(*J40__frame_st)(unsafe.Pointer(f)).Gab.Enabled = func() int32 {
		if restoration_all_default != 0 {
			return 1
		}
		return j40__u(tls, st, 1)
	}()
	if !((*J40__frame_st)(unsafe.Pointer(f)).Gab.Enabled != 0) {
		goto __102
	}
	if !(j40__u(tls, st, 1) != 0) {
		goto __103
	}
	i = 0
__104:
	if !(i < 3) {
		goto __106
	}
	j = 0
__107:
	if !(j < 2) {
		goto __109
	}
	*(*float32)(unsafe.Pointer(f + 208 + 4 + uintptr(i)*8 + uintptr(j)*4)) = j40__f16(tls, st)
	goto __108
__108:
	j++
	goto __107
	goto __109
__109:
	;
	goto __105
__105:
	i++
	goto __104
	goto __106
__106:
	;
__103:
	;
__102:
	;
	(*J40__frame_st)(unsafe.Pointer(f)).Epf.Iters = func() int32 {
		if restoration_all_default != 0 {
			return 2
		}
		return j40__u(tls, st, 2)
	}()
	if !((*J40__frame_st)(unsafe.Pointer(f)).Epf.Iters != 0) {
		goto __110
	}
	if !(!((*J40__frame_st)(unsafe.Pointer(f)).Is_modular != 0) && j40__u(tls, st, 1) != 0) {
		goto __111
	}
	i = 0
__112:
	if !(i < 8) {
		goto __114
	}
	*(*float32)(unsafe.Pointer(f + 236 + 4 + uintptr(i)*4)) = j40__f16(tls, st)
	goto __113
__113:
	i++
	goto __112
	goto __114
__114:
	;
__111:
	;
	if !(j40__u(tls, st, 1) != 0) {
		goto __115
	}
	i = 0
__116:
	if !(i < 3) {
		goto __118
	}
	*(*float32)(unsafe.Pointer(f + 236 + 36 + uintptr(i)*4)) = j40__f16(tls, st)
	goto __117
__117:
	i++
	goto __116
	goto __118
__118:
	;
__119:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__skip(tls, st, int64(32)) != 0)), int64(0)) != 0) {
		goto __122
	}
	goto J40__ON_ERROR
__122:
	;
	goto __120
__120:
	if 0 != 0 {
		goto __119
	}
	goto __121
__121:
	;
__115:
	;
	if !(j40__u(tls, st, 1) != 0) {
		goto __123
	}
	if !!((*J40__frame_st)(unsafe.Pointer(f)).Is_modular != 0) {
		goto __124
	}
	(*J40__frame_st)(unsafe.Pointer(f)).Epf.Quant_mul = j40__f16(tls, st)
__124:
	;
	(*J40__frame_st)(unsafe.Pointer(f)).Epf.Pass0_sigma_scale = j40__f16(tls, st)
	(*J40__frame_st)(unsafe.Pointer(f)).Epf.Pass2_sigma_scale = j40__f16(tls, st)
	(*J40__frame_st)(unsafe.Pointer(f)).Epf.Border_sad_mul = j40__f16(tls, st)
__123:
	;
	if !((*J40__frame_st)(unsafe.Pointer(f)).Epf.Iters != 0 && (*J40__frame_st)(unsafe.Pointer(f)).Is_modular != 0) {
		goto __125
	}
	(*J40__frame_st)(unsafe.Pointer(f)).Epf.Sigma_for_modular = j40__f16(tls, st)
__125:
	;
__110:
	;
	if !!(restoration_all_default != 0) {
		goto __126
	}
__127:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__extensions(tls, st) != 0)), int64(0)) != 0) {
		goto __130
	}
	goto J40__ON_ERROR
__130:
	;
	goto __128
__128:
	if 0 != 0 {
		goto __127
	}
	goto __129
__129:
	;
__126:
	;
__131:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__extensions(tls, st) != 0)), int64(0)) != 0) {
		goto __134
	}
	goto J40__ON_ERROR
__134:
	;
	goto __132
__132:
	if 0 != 0 {
		goto __131
	}
	goto __133
__133:
	;
__8:
	;
__135:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __138
	}
	goto J40__ON_ERROR
__138:
	;
	goto __136
__136:
	if 0 != 0 {
		goto __135
	}
	goto __137
__137:
	;
	if !((*J40__image_st)(unsafe.Pointer(im)).Xyb_encoded != 0 && (*J40__image_st)(unsafe.Pointer(im)).Want_icc != 0) {
		goto __139
	}
	(*J40__frame_st)(unsafe.Pointer(f)).Save_before_ct = 1
__139:
	;
	(*J40__frame_st)(unsafe.Pointer(f)).Num_groups_per_row = Int64_t(J40__ceil_div32(tls, (*J40__frame_st)(unsafe.Pointer(f)).Width, int32(1)<<(*J40__frame_st)(unsafe.Pointer(f)).Group_size_shift))
	(*J40__frame_st)(unsafe.Pointer(f)).Num_groups = (*J40__frame_st)(unsafe.Pointer(f)).Num_groups_per_row * Int64_t(J40__ceil_div32(tls, (*J40__frame_st)(unsafe.Pointer(f)).Height, int32(1)<<(*J40__frame_st)(unsafe.Pointer(f)).Group_size_shift))
	(*J40__frame_st)(unsafe.Pointer(f)).Num_lf_groups_per_row = Int64_t(J40__ceil_div32(tls, (*J40__frame_st)(unsafe.Pointer(f)).Width, int32(8)<<(*J40__frame_st)(unsafe.Pointer(f)).Group_size_shift))
	(*J40__frame_st)(unsafe.Pointer(f)).Num_lf_groups = (*J40__frame_st)(unsafe.Pointer(f)).Num_lf_groups_per_row * Int64_t(J40__ceil_div32(tls, (*J40__frame_st)(unsafe.Pointer(f)).Height, int32(8)<<(*J40__frame_st)(unsafe.Pointer(f)).Group_size_shift))
	return J40_err(0)

J40__ON_ERROR:
	j40__free(tls, (*J40__frame_st)(unsafe.Pointer(f)).Ec_log_upsampling)
	j40__free(tls, (*J40__frame_st)(unsafe.Pointer(f)).Ec_blend_info)
	j40__free(tls, (*J40__frame_st)(unsafe.Pointer(f)).Name)
	(*J40__frame_st)(unsafe.Pointer(f)).Ec_log_upsampling = uintptr(0)
	(*J40__frame_st)(unsafe.Pointer(f)).Ec_blend_info = uintptr(0)
	(*J40__frame_st)(unsafe.Pointer(f)).Name = uintptr(0)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

type J40__section = struct {
	Idx     Int64_t
	Codeoff Int64_t
	Size    Int32_t
	Pass    Int32_t
}

type J40__toc = struct {
	Single_size       Int32_t
	__ccgo_pad1       [4]byte
	Lf_global_codeoff Int64_t
	Hf_global_codeoff Int64_t
	Lf_global_size    Int32_t
	Hf_global_size    Int32_t
	Nsections         Int64_t
	Nsections_read    Int64_t
	Sections          uintptr
	End_codeoff       Int64_t
}

// also used in j40__hf_global; out is terminated by a sentinel (-1) or NULL if empty
// TODO permutation may have to handle more than 2^31 entries
func j40__permutation(tls *libc.TLS, st uintptr, code uintptr, size Int32_t, skip Int32_t, out uintptr) J40_err {
	var arr uintptr
	var i Int32_t
	var prev Int32_t
	var end Int32_t
	arr = uintptr(0)

	end = j40__code(tls, st, J40__min32(tls, 7, J40__ceil_lg32(tls, Uint32_t(size)+Uint32_t(1))), 0, code)
__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(end <= size-skip)), int64(0)) != 0) {
		goto __5
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 554))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 554 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 554 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 554 + 3))))
	goto J40__ON_ERROR
__5:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
	if !(end == 0) {
		goto __6
	}
	*(*uintptr)(unsafe.Pointer(out)) = uintptr(0)
	return J40_err(0)
__6:
	;
__7:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __10
	}
	goto J40__ON_ERROR
__10:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignUintptr(&arr, j40__malloc(tls, uint64(unsafe.Sizeof(Int32_t(0)))*Size_t(end+1)))) != 0)), int64(0)) != 0) {
		goto __11
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__11:
	;
	goto __8
__8:
	if 0 != 0 {
		goto __7
	}
	goto __9
__9:
	;
	prev = 0
	i = 0
__12:
	if !(i < end) {
		goto __14
	}
	prev = libc.AssignPtrInt32(arr+uintptr(i)*4, j40__code(tls, st, J40__min32(tls, 7, J40__ceil_lg32(tls, Uint32_t(prev)+Uint32_t(1))), 0, code))
__15:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __18
	}
	goto J40__ON_ERROR
__18:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(prev < size-(skip+i))), int64(0)) != 0) {
		goto __19
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 554))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 554 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 554 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 554 + 3))))
	goto J40__ON_ERROR
__19:
	;
	goto __16
__16:
	if 0 != 0 {
		goto __15
	}
	goto __17
__17:
	;
	goto __13
__13:
	i++
	goto __12
	goto __14
__14:
	;
	*(*Int32_t)(unsafe.Pointer(arr + uintptr(end)*4)) = -1
	*(*uintptr)(unsafe.Pointer(out)) = arr
	return J40_err(0)

J40__ON_ERROR:
	libc.Xfree(tls, arr)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

// target is pre-shifted by skip
func j40__apply_permutation(tls *libc.TLS, targetbuf uintptr, temp uintptr, elemsize Size_t, lehmer uintptr) {
	var target uintptr = targetbuf
	if !(lehmer != 0) {
		return
	}
	for *(*Int32_t)(unsafe.Pointer(lehmer)) >= 0 {
		var x Size_t = Size_t(*(*Int32_t)(unsafe.Pointer(libc.PostIncUintptr(&lehmer, 4))))
		libc.Xmemcpy(tls, temp, target+uintptr(elemsize*x), elemsize)
		libc.Xmemmove(tls, target+uintptr(elemsize), target, elemsize*x)
		libc.Xmemcpy(tls, target, temp, elemsize)
		target += uintptr(elemsize)
	}
}

func j40__compare_section(tls *libc.TLS, a uintptr, b uintptr) int32 {
	var aa uintptr = a
	var bb uintptr = b
	if (*J40__section)(unsafe.Pointer(aa)).Codeoff < (*J40__section)(unsafe.Pointer(bb)).Codeoff {
		return -1
	}
	if (*J40__section)(unsafe.Pointer(aa)).Codeoff > (*J40__section)(unsafe.Pointer(bb)).Codeoff {
		return 1
	}
	return 0
}

func j40__read_toc(tls *libc.TLS, st uintptr, toc uintptr) J40_err {
	bp := tls.Alloc(144)
	defer tls.Free(144)

	var f uintptr
	var nsections Int64_t
	var nsections2 Int64_t
	var sections uintptr
	var sections2 uintptr

	var nrelocs Int64_t

	var i Int64_t
	var nremoved Int64_t
	var pass Int32_t
	var sectionid Int64_t
	var newptr uintptr
	var gsection Int64_t
	var ggidx Int64_t
	var ggsection Int64_t
	var ggcodeoff Int64_t
	var gsection_base Int64_t
	var grows_in_gg Int32_t
	var gcolumns_in_gg Int32_t
	var grow_in_gg Int32_t
	var gcolumn_in_gg Int32_t
	var ggrows Int32_t
	var grows Int32_t
	var ggcolumns Int32_t
	var gcolumns Int32_t
	var ggrow Int32_t
	var ggcolumn Int32_t
	var j Int64_t
	var first_reloc_off Int64_t
	f = (*J40__st)(unsafe.Pointer(st)).Frame
	if (*J40__frame_st)(unsafe.Pointer(f)).Num_passes == 1 && (*J40__frame_st)(unsafe.Pointer(f)).Num_groups == int64(1) {
		nsections = int64(1)
	} else {
		nsections = int64(1) + (*J40__frame_st)(unsafe.Pointer(f)).Num_lf_groups + int64(1) + Int64_t((*J40__frame_st)(unsafe.Pointer(f)).Num_passes)*(*J40__frame_st)(unsafe.Pointer(f)).Num_groups
	}
	sections = uintptr(0)
	sections2 = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 128)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 96)) = uintptr(0)
	*(*J40__code_spec)(unsafe.Pointer(bp)) = J40__code_spec{}
	*(*J40__code_st)(unsafe.Pointer(bp + 56)) = J40__code_st{Spec: bp}

__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Uint64_t(nsections) <= libc.Uint64(18446744073709551615) && nsections <= int64(2147483647))), int64(0)) != 0) {
		goto __5
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 3))))
	goto J40__ON_ERROR
__5:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
	if !(j40__u(tls, st, 1) != 0) {
		goto __6
	}
__7:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__read_code_spec(tls, st, 8, bp) != 0)), int64(0)) != 0) {
		goto __10
	}
	goto J40__ON_ERROR
__10:
	;
	goto __8
__8:
	if 0 != 0 {
		goto __7
	}
	goto __9
__9:
	;
__11:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__permutation(tls, st, bp+56, Int32_t(nsections), 0, bp+96) != 0)), int64(0)) != 0) {
		goto __14
	}
	goto J40__ON_ERROR
__14:
	;
	goto __12
__12:
	if 0 != 0 {
		goto __11
	}
	goto __13
__13:
	;
__15:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__finish_and_free_code(tls, st, bp+56) != 0)), int64(0)) != 0) {
		goto __18
	}
	goto J40__ON_ERROR
__18:
	;
	goto __16
__16:
	if 0 != 0 {
		goto __15
	}
	goto __17
__17:
	;
	j40__free_code_spec(tls, bp)
__6:
	;
__19:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__zero_pad_to_byte(tls, st) != 0)), int64(0)) != 0) {
		goto __22
	}
	goto J40__ON_ERROR
__22:
	;
	goto __20
__20:
	if 0 != 0 {
		goto __19
	}
	goto __21
__21:
	;
	if !(nsections == int64(1)) {
		goto __23
	}
	(*J40__toc)(unsafe.Pointer(toc)).Single_size = j40__u32(tls, st, 0, 10, 1024, 14, 17408, 22, 4211712, 30)
__24:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__zero_pad_to_byte(tls, st) != 0)), int64(0)) != 0) {
		goto __27
	}
	goto J40__ON_ERROR
__27:
	;
	goto __25
__25:
	if 0 != 0 {
		goto __24
	}
	goto __26
__26:
	;
	(*J40__toc)(unsafe.Pointer(toc)).Lf_global_codeoff = libc.AssignPtrInt64(toc+16, int64(0))
	(*J40__toc)(unsafe.Pointer(toc)).Lf_global_size = libc.AssignPtrInt32(toc+28, 0)
	(*J40__toc)(unsafe.Pointer(toc)).Nsections = libc.AssignPtrInt64(toc+40, int64(0))
	(*J40__toc)(unsafe.Pointer(toc)).Sections = uintptr(0)
__28:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __31
	}
	goto J40__ON_ERROR
__31:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(J40__add64(tls, j40__codestream_offset(tls, st), int64((*J40__toc)(unsafe.Pointer(toc)).Single_size), toc+56) != 0)), int64(0)) != 0) {
		goto __32
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 3))))
	goto J40__ON_ERROR
__32:
	;
	goto __29
__29:
	if 0 != 0 {
		goto __28
	}
	goto __30
__30:
	;
	j40__free(tls, *(*uintptr)(unsafe.Pointer(bp + 96)))
	return J40_err(0)
__23:
	;
__33:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __36
	}
	goto J40__ON_ERROR
__36:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignUintptr(&sections, j40__malloc(tls, uint64(unsafe.Sizeof(J40__section{}))*Size_t(nsections)))) != 0)), int64(0)) != 0) {
		goto __37
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__37:
	;
	goto __34
__34:
	if 0 != 0 {
		goto __33
	}
	goto __35
__35:
	;
	i = int64(0)
__38:
	if !(i < nsections) {
		goto __40
	}
	(*J40__section)(unsafe.Pointer(sections + uintptr(i)*24)).Size = j40__u32(tls, st, 0, 10, 1024, 14, 17408, 22, 4211712, 30)
	goto __39
__39:
	i++
	goto __38
	goto __40
__40:
	;
__41:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__zero_pad_to_byte(tls, st) != 0)), int64(0)) != 0) {
		goto __44
	}
	goto J40__ON_ERROR
__44:
	;
	goto __42
__42:
	if 0 != 0 {
		goto __41
	}
	goto __43
__43:
	;
	(*J40__section)(unsafe.Pointer(sections)).Codeoff = j40__codestream_offset(tls, st)
	i = int64(1)
__45:
	if !(i < nsections) {
		goto __47
	}
__48:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __51
	}
	goto J40__ON_ERROR
__51:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(J40__add64(tls, (*J40__section)(unsafe.Pointer(sections+uintptr(i-int64(1))*24)).Codeoff, int64((*J40__section)(unsafe.Pointer(sections+uintptr(i-int64(1))*24)).Size), sections+uintptr(i)*24+8) != 0)), int64(0)) != 0) {
		goto __52
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 3))))
	goto J40__ON_ERROR
__52:
	;
	goto __49
__49:
	if 0 != 0 {
		goto __48
	}
	goto __50
__50:
	;
	goto __46
__46:
	i++
	goto __45
	goto __47
__47:
	;
__53:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __56
	}
	goto J40__ON_ERROR
__56:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(J40__add64(tls, (*J40__section)(unsafe.Pointer(sections+uintptr(i-int64(1))*24)).Codeoff, int64((*J40__section)(unsafe.Pointer(sections+uintptr(i-int64(1))*24)).Size), toc+56) != 0)), int64(0)) != 0) {
		goto __57
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 3))))
	goto J40__ON_ERROR
__57:
	;
	goto __54
__54:
	if 0 != 0 {
		goto __53
	}
	goto __55
__55:
	;
	if !(*(*uintptr)(unsafe.Pointer(bp + 96)) != 0) {
		goto __58
	}
	j40__apply_permutation(tls, sections, bp+104, uint64(unsafe.Sizeof(J40__section{})), *(*uintptr)(unsafe.Pointer(bp + 96)))
	j40__free(tls, *(*uintptr)(unsafe.Pointer(bp + 96)))
	*(*uintptr)(unsafe.Pointer(bp + 96)) = uintptr(0)
__58:
	;
	(*J40__toc)(unsafe.Pointer(toc)).Lf_global_codeoff = (*J40__section)(unsafe.Pointer(sections)).Codeoff
	(*J40__toc)(unsafe.Pointer(toc)).Lf_global_size = (*J40__section)(unsafe.Pointer(sections)).Size
	(*J40__section)(unsafe.Pointer(sections)).Codeoff = int64(-1)
	i = int64(0)
__59:
	if !(i < (*J40__frame_st)(unsafe.Pointer(f)).Num_lf_groups) {
		goto __61
	}
	(*J40__section)(unsafe.Pointer(sections + uintptr(i+int64(1))*24)).Pass = -1
	(*J40__section)(unsafe.Pointer(sections + uintptr(i+int64(1))*24)).Idx = i
	goto __60
__60:
	i++
	goto __59
	goto __61
__61:
	;
	(*J40__toc)(unsafe.Pointer(toc)).Hf_global_codeoff = (*J40__section)(unsafe.Pointer(sections + uintptr((*J40__frame_st)(unsafe.Pointer(f)).Num_lf_groups+int64(1))*24)).Codeoff
	(*J40__toc)(unsafe.Pointer(toc)).Hf_global_size = (*J40__section)(unsafe.Pointer(sections + uintptr((*J40__frame_st)(unsafe.Pointer(f)).Num_lf_groups+int64(1))*24)).Size
	(*J40__section)(unsafe.Pointer(sections + uintptr((*J40__frame_st)(unsafe.Pointer(f)).Num_lf_groups+int64(1))*24)).Codeoff = int64(-1)
	pass = 0
__62:
	if !(pass < (*J40__frame_st)(unsafe.Pointer(f)).Num_passes) {
		goto __64
	}
	sectionid = int64(1) + (*J40__frame_st)(unsafe.Pointer(f)).Num_lf_groups + int64(1) + Int64_t(pass)*(*J40__frame_st)(unsafe.Pointer(f)).Num_groups
	i = int64(0)
__65:
	if !(i < (*J40__frame_st)(unsafe.Pointer(f)).Num_groups) {
		goto __67
	}
	(*J40__section)(unsafe.Pointer(sections + uintptr(sectionid+i)*24)).Pass = pass
	(*J40__section)(unsafe.Pointer(sections + uintptr(sectionid+i)*24)).Idx = i
	goto __66
__66:
	i++
	goto __65
	goto __67
__67:
	;
	goto __63
__63:
	pass++
	goto __62
	goto __64
__64:
	;
	ggrows = J40__ceil_div32(tls, (*J40__frame_st)(unsafe.Pointer(f)).Height, int32(8)<<(*J40__frame_st)(unsafe.Pointer(f)).Group_size_shift)
	grows = J40__ceil_div32(tls, (*J40__frame_st)(unsafe.Pointer(f)).Height, int32(1)<<(*J40__frame_st)(unsafe.Pointer(f)).Group_size_shift)
	ggcolumns = J40__ceil_div32(tls, (*J40__frame_st)(unsafe.Pointer(f)).Width, int32(8)<<(*J40__frame_st)(unsafe.Pointer(f)).Group_size_shift)
	gcolumns = J40__ceil_div32(tls, (*J40__frame_st)(unsafe.Pointer(f)).Width, int32(1)<<(*J40__frame_st)(unsafe.Pointer(f)).Group_size_shift)

__68:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __71
	}
	goto J40__ON_ERROR
__71:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(bp+128, j40__calloc(tls, Size_t((*J40__frame_st)(unsafe.Pointer(f)).Num_lf_groups), uint64(unsafe.Sizeof(Reloc{}))))) != 0)), int64(0)) != 0) {
		goto __72
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__72:
	;
	goto __69
__69:
	if 0 != 0 {
		goto __68
	}
	goto __70
__70:
	;
	nrelocs = libc.AssignPtrInt64(bp+136, (*J40__frame_st)(unsafe.Pointer(f)).Num_lf_groups)

	ggrow = 0
__73:
	if !(ggrow < ggcolumns) {
		goto __75
	}
	ggcolumn = 0
__76:
	if !(ggcolumn < ggrows) {
		goto __78
	}
	ggidx = Int64_t(ggrow)*Int64_t(ggcolumns) + Int64_t(ggcolumn)
	ggsection = int64(1) + ggidx
	ggcodeoff = (*J40__section)(unsafe.Pointer(sections + uintptr(ggsection)*24)).Codeoff
	gsection_base = int64(1) + (*J40__frame_st)(unsafe.Pointer(f)).Num_lf_groups + int64(1) + Int64_t(ggrow*8)*Int64_t(gcolumns) + Int64_t(ggcolumn*8)
	grows_in_gg = J40__min32(tls, (ggrow+1)*8, grows) - ggrow*8
	gcolumns_in_gg = J40__min32(tls, (ggcolumn+1)*8, gcolumns) - ggcolumn*8

	pass = 0
__79:
	if !(pass < (*J40__frame_st)(unsafe.Pointer(f)).Num_passes) {
		goto __81
	}
	grow_in_gg = 0
__82:
	if !(grow_in_gg < grows_in_gg) {
		goto __84
	}
	gcolumn_in_gg = 0
__85:
	if !(gcolumn_in_gg < gcolumns_in_gg) {
		goto __87
	}
	gsection = gsection_base + Int64_t(pass)*(*J40__frame_st)(unsafe.Pointer(f)).Num_groups + Int64_t(grow_in_gg*gcolumns+gcolumn_in_gg)
	if !((*J40__section)(unsafe.Pointer(sections+uintptr(gsection)*24)).Codeoff > ggcodeoff) {
		goto __88
	}
	goto __86
__88:
	;
	if !((*Reloc)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128))+uintptr(ggidx)*32)).Next != 0) {
		goto __89
	}
__91:
	newptr = j40__realloc64(tls, st, *(*uintptr)(unsafe.Pointer(bp + 128)), uint64(unsafe.Sizeof(Reloc{})), nrelocs+int64(1), bp+136)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(newptr != 0)), int64(1)) != 0) {
		goto __94
	}
	*(*uintptr)(unsafe.Pointer(bp + 128)) = newptr
	goto __95
__94:
	goto J40__ON_ERROR
__95:
	;
	goto __92
__92:
	if 0 != 0 {
		goto __91
	}
	goto __93
__93:
	;
	*(*Reloc)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128)) + uintptr(nrelocs)*32)) = *(*Reloc)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128)) + uintptr(ggidx)*32))
	(*Reloc)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128)) + uintptr(ggidx)*32)).Next = libc.PostIncInt64(&nrelocs, 1)
	goto __90
__89:
	(*Reloc)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128)) + uintptr(ggidx)*32)).Next = int64(-1)
__90:
	;
	(*Reloc)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128)) + uintptr(ggidx)*32)).Section = *(*J40__section)(unsafe.Pointer(sections + uintptr(gsection)*24))
	(*J40__section)(unsafe.Pointer(sections + uintptr(gsection)*24)).Codeoff = int64(-1)
	goto __86
__86:
	gcolumn_in_gg++
	goto __85
	goto __87
__87:
	;
	goto __83
__83:
	grow_in_gg++
	goto __82
	goto __84
__84:
	;
	goto __80
__80:
	pass++
	goto __79
	goto __81
__81:
	;
	goto __77
__77:
	ggcolumn++
	goto __76
	goto __78
__78:
	;
	goto __74
__74:
	ggrow++
	goto __73
	goto __75
__75:
	;
	i = libc.AssignInt64(&nremoved, int64(0))
__96:
	if !(i < nsections) {
		goto __98
	}
	if !((*J40__section)(unsafe.Pointer(sections+uintptr(i)*24)).Codeoff < int64(0)) {
		goto __99
	}
	nremoved++
	goto __100
__99:
	*(*J40__section)(unsafe.Pointer(sections + uintptr(i-nremoved)*24)) = *(*J40__section)(unsafe.Pointer(sections + uintptr(i)*24))
__100:
	;
	goto __97
__97:
	i++
	goto __96
	goto __98
__98:
	;
	libc.Xqsort(tls, sections, Size_t(nsections-nremoved), uint64(unsafe.Sizeof(J40__section{})), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{j40__compare_section})))

__101:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __104
	}
	goto J40__ON_ERROR
__104:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignUintptr(&sections2, j40__malloc(tls, uint64(unsafe.Sizeof(J40__section{}))*Size_t(nsections)))) != 0)), int64(0)) != 0) {
		goto __105
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__105:
	;
	goto __102
__102:
	if 0 != 0 {
		goto __101
	}
	goto __103
__103:
	;
	nsections2 = int64(0)
	i = int64(0)
__106:
	if !(i < nsections-nremoved) {
		goto __108
	}
	*(*J40__section)(unsafe.Pointer(sections2 + uintptr(libc.PostIncInt64(&nsections2, 1))*24)) = *(*J40__section)(unsafe.Pointer(sections + uintptr(i)*24))
	if !((*J40__section)(unsafe.Pointer(sections+uintptr(i)*24)).Pass >= 0) {
		goto __109
	}
	goto __107
__109:
	;
	j = (*J40__section)(unsafe.Pointer(sections + uintptr(i)*24)).Idx
	if !!(int32((*Reloc)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128))+uintptr(j)*32)).Next) != 0) {
		goto __110
	}
	goto __107
__110:
	;
	first_reloc_off = nsections2
__111:
	if !(j >= int64(0)) {
		goto __112
	}
	*(*J40__section)(unsafe.Pointer(sections2 + uintptr(libc.PostIncInt64(&nsections2, 1))*24)) = (*Reloc)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128)) + uintptr(j)*32)).Section
	j = (*Reloc)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128)) + uintptr(j)*32)).Next
	goto __111
__112:
	;
	libc.Xqsort(tls, sections2+uintptr(first_reloc_off)*24, Size_t(nsections2-first_reloc_off),
		uint64(unsafe.Sizeof(J40__section{})), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		}{j40__compare_section})))
	goto __107
__107:
	i++
	goto __106
	goto __108
__108:
	;
	(*J40__toc)(unsafe.Pointer(toc)).Sections = sections2
	(*J40__toc)(unsafe.Pointer(toc)).Nsections = nsections2
	(*J40__toc)(unsafe.Pointer(toc)).Nsections_read = int64(0)

	j40__free(tls, sections)
	j40__free(tls, *(*uintptr)(unsafe.Pointer(bp + 128)))
	j40__free(tls, *(*uintptr)(unsafe.Pointer(bp + 96)))
	j40__free_code(tls, bp+56)
	j40__free_code_spec(tls, bp)
	return J40_err(0)

J40__ON_ERROR:
	j40__free(tls, sections)
	j40__free(tls, sections2)
	j40__free(tls, *(*uintptr)(unsafe.Pointer(bp + 128)))
	j40__free(tls, *(*uintptr)(unsafe.Pointer(bp + 96)))
	j40__free_code(tls, bp+56)
	j40__free_code_spec(tls, bp)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

// interleaved linked lists for each LF group; for each LF group `gg` there are three cases:
//   - no relocated section if `relocs[gg].next == 0` (initial state).
//   - a single relocated section `relocs[gg].section` if `relocs[gg].next < 0`.
//   - 2+ relocated sections `relocs[i].section`, where `k` starts at `gg` and
//     continues through `next` until it's negative.
type Reloc = struct {
	Next    Int64_t
	Section J40__section
}

func j40__free_toc(tls *libc.TLS, toc uintptr) {
	j40__free(tls, (*J40__toc)(unsafe.Pointer(toc)).Sections)
	(*J40__toc)(unsafe.Pointer(toc)).Sections = uintptr(0)
}

// [(1<<n) + k] = 1/(2 cos((k+0.5)/2^(n+1) pi)) for n >= 1 and 0 <= k < 2^n
var sJ40__HALF_SECANTS = [256]float32{
	float32(0), float32(0),
	0.54119610, 1.30656296,
	0.50979558, 0.60134489, 0.89997622, 2.56291545,
	0.50241929, 0.52249861, 0.56694403, 0.64682178, 0.78815462, 1.06067769, 1.72244710, 5.10114862,
	0.50060300, 0.50547096, 0.51544731, 0.53104259, 0.55310390, 0.58293497, 0.62250412, 0.67480834,
	0.74453627, 0.83934965, 0.97256824, 1.16943993, 1.48416462, 2.05778101, 3.40760842, 10.1900081,
	0.50015064, 0.50135845, 0.50378873, 0.50747117, 0.51245148, 0.51879271, 0.52657732, 0.53590982,
	0.54692044, 0.55976981, 0.57465518, 0.59181854, 0.61155735, 0.63423894, 0.66031981, 0.69037213,
	0.72512052, 0.76549416, 0.81270209, 0.86834472, 0.93458360, 1.01440826, 1.11207162, 1.23383274,
	1.38929396, 1.59397228, 1.87467598, 2.28205007, 2.92462843, 4.08461108, 6.79675071, 20.3738782,
	0.50003765, 0.50033904, 0.50094272, 0.50185052, 0.50306519, 0.50459044, 0.50643095, 0.50859242,
	0.51108159, 0.51390633, 0.51707566, 0.52059987, 0.52449054, 0.52876071, 0.53342493, 0.53849944,
	0.54400225, 0.54995337, 0.55637499, 0.56329167, 0.57073059, 0.57872189, 0.58729894, 0.59649876,
	0.60636246, 0.61693573, 0.62826943, 0.64042034, 0.65345190, 0.66743520, 0.68245013, 0.69858665,
	0.71594645, 0.73464482, 0.75481294, 0.77660066, 0.80017990, 0.82574877, 0.85353675, 0.88381100,
	0.91688445, 0.95312587, 0.99297296, 1.03694904, 1.08568506, 1.13994868, 1.20068326, 1.26906117,
	1.34655763, 1.43505509, 1.53699410, 1.65559652, 1.79520522, 1.96181785, 2.16395782, 2.41416000,
	2.73164503, 3.14746219, 3.71524274, 4.53629094, 5.82768838, 8.15384860, 13.5842903, 40.7446881,
	0.50000941, 0.50008472, 0.50023540, 0.50046156, 0.50076337, 0.50114106, 0.50159492, 0.50212529,
	0.50273257, 0.50341722, 0.50417977, 0.50502081, 0.50594098, 0.50694099, 0.50802161, 0.50918370,
	0.51042817, 0.51175599, 0.51316821, 0.51466598, 0.51625048, 0.51792302, 0.51968494, 0.52153769,
	0.52348283, 0.52552196, 0.52765682, 0.52988922, 0.53222108, 0.53465442, 0.53719139, 0.53983424,
	0.54258533, 0.54544717, 0.54842239, 0.55151375, 0.55472418, 0.55805673, 0.56151465, 0.56510131,
	0.56882030, 0.57267538, 0.57667051, 0.58080985, 0.58509780, 0.58953898, 0.59413825, 0.59890075,
	0.60383188, 0.60893736, 0.61422320, 0.61969575, 0.62536172, 0.63122819, 0.63730265, 0.64359303,
	0.65010770, 0.65685553, 0.66384594, 0.67108889, 0.67859495, 0.68637535, 0.69444203, 0.70280766,
	0.71148577, 0.72049072, 0.72983786, 0.73954355, 0.74962527, 0.76010172, 0.77099290, 0.78232026,
	0.79410679, 0.80637720, 0.81915807, 0.83247799, 0.84636782, 0.86086085, 0.87599311, 0.89180358,
	0.90833456, 0.92563200, 0.94374590, 0.96273078, 0.98264619, 1.00355728, 1.02553551, 1.04865941,
	1.07301549, 1.09869926, 1.12581641, 1.15448427, 1.18483336, 1.21700940, 1.25117548, 1.28751481,
	1.32623388, 1.36756626, 1.41177723, 1.45916930, 1.51008903, 1.56493528, 1.62416951, 1.68832855,
	1.75804061, 1.83404561, 1.91722116, 2.00861611, 2.10949453, 2.22139378, 2.34620266, 2.48626791,
	2.64454188, 2.82479140, 3.03189945, 3.27231159, 3.55471533, 3.89110779, 4.29853753, 4.80207601,
	5.44016622, 6.27490841, 7.41356676, 9.05875145, 11.6446273, 16.3000231, 27.1639777, 81.4878422,
}

// TODO spec bug: ScaleF doesn't match with the current libjxl! it turns out that this is actually
// a set of factors for the Arai, Agui, Nakajima DCT & IDCT algorithm, which was only used in
// older versions of libjxl (both the current libjxl and J40 currently uses Perera-Liu) and
// not even a resampling algorithm to begin with.
//
// [(1<<N) + k] = 1 / (cos(k/2^(4+N) pi) * cos(k/2^(3+N) pi) * cos(k/2^(2+N) pi) * 2^N)
//
//	for N >= 1 and 0 <= k < 2^N
var sJ40__LF2LLF_SCALES = [64]float32{
	float32(0),
	1.00000000,
	0.50000000, 0.55446868,
	0.25000000, 0.25644002, 0.27723434, 0.31763984,
	0.12500000, 0.12579419, 0.12822001, 0.13241272, 0.13861717, 0.14722207, 0.15881992, 0.17431123,
	0.06250000, 0.06259894, 0.06289709, 0.06339849, 0.06411001, 0.06504154, 0.06620636, 0.06762155,
	0.06930858, 0.07129412, 0.07361103, 0.07629973, 0.07940996, 0.08300316, 0.08715562, 0.09196277,
	0.03125000, 0.03126236, 0.03129947, 0.03136146, 0.03144855, 0.03156101, 0.03169925, 0.03186372,
	0.03205500, 0.03227376, 0.03252077, 0.03279691, 0.03310318, 0.03344071, 0.03381077, 0.03421478,
	0.03465429, 0.03513107, 0.03564706, 0.03620441, 0.03680552, 0.03745302, 0.03814986, 0.03889931,
	0.03970498, 0.04057091, 0.04150158, 0.04250201, 0.04357781, 0.04473525, 0.04598138, 0.04732417,
}

func J40__forward_dct_core(tls *libc.TLS, out uintptr, in uintptr, t Int32_t, rep1 Int32_t, rep2 Int32_t, half_forward_dct uintptr) {
	var r1 Int32_t
	var r2 Int32_t
	var i Int32_t
	var N Int32_t = int32(1) << t
	var stride Int32_t = rep1 * rep2

	for r1 = 0; r1 < rep1*rep2; r1 = r1 + rep2 {
		for i = 0; i < N/2; i++ {
			var mult float32 = sJ40__HALF_SECANTS[N/2+i]
			for r2 = 0; r2 < rep2; r2++ {
				var x float32 = *(*float32)(unsafe.Pointer(in + uintptr(i*stride+r1+r2)*4))
				var y float32 = *(*float32)(unsafe.Pointer(in + uintptr((N-i-1)*stride+r1+r2)*4))
				*(*float32)(unsafe.Pointer(out + uintptr(i*stride+r1+r2)*4)) = x + y
				*(*float32)(unsafe.Pointer(out + uintptr((N/2+i)*stride+r1+r2)*4)) = (x - y) * mult
			}
		}
	}

	(*struct {
		f func(*libc.TLS, uintptr, uintptr, Int32_t, Int32_t, Int32_t)
	})(unsafe.Pointer(&struct{ uintptr }{half_forward_dct})).f(tls, in, out, t-1, rep1, rep2)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, Int32_t, Int32_t, Int32_t)
	})(unsafe.Pointer(&struct{ uintptr }{half_forward_dct})).f(tls, in+uintptr(N/2*stride)*4, out+uintptr(N/2*stride)*4, t-1, rep1, rep2)

	for r1 = 0; r1 < rep1*rep2; r1 = r1 + rep2 {
		for i = 0; i < N/2; i++ {
			for r2 = 0; r2 < rep2; r2++ {
				*(*float32)(unsafe.Pointer(out + uintptr(i*2*stride+r1+r2)*4)) = *(*float32)(unsafe.Pointer(in + uintptr(i*stride+r1+r2)*4))
			}
		}
	}

	for r1 = 0; r1 < rep1*rep2; r1 = r1 + rep2 {
		for r2 = 0; r2 < rep2; r2++ {
			*(*float32)(unsafe.Pointer(out + uintptr(1*stride+r1+r2)*4)) = 1.4142135623730951**(*float32)(unsafe.Pointer(in + uintptr(N/2*stride+r1+r2)*4)) + *(*float32)(unsafe.Pointer(in + uintptr((N/2+1)*stride+r1+r2)*4))
		}
		for i = 1; i < N/2-1; i++ {
			for r2 = 0; r2 < rep2; r2++ {
				*(*float32)(unsafe.Pointer(out + uintptr((i*2+1)*stride+r1+r2)*4)) = *(*float32)(unsafe.Pointer(in + uintptr((N/2+i)*stride+r1+r2)*4)) + *(*float32)(unsafe.Pointer(in + uintptr((N/2+i+1)*stride+r1+r2)*4))
			}
		}
		for r2 = 0; r2 < rep2; r2++ {
			*(*float32)(unsafe.Pointer(out + uintptr((N-1)*stride+r1+r2)*4)) = *(*float32)(unsafe.Pointer(in + uintptr((N-1)*stride+r1+r2)*4))
		}
	}
}

func J40__inverse_dct_core(tls *libc.TLS, out uintptr, in uintptr, t Int32_t, rep1 Int32_t, rep2 Int32_t, half_inverse_dct uintptr) {
	var r1 Int32_t
	var r2 Int32_t
	var i Int32_t
	var N Int32_t = int32(1) << t
	var stride Int32_t = rep1 * rep2

	for r1 = 0; r1 < rep1*rep2; r1 = r1 + rep2 {
		for i = 0; i < N/2; i++ {
			for r2 = 0; r2 < rep2; r2++ {
				*(*float32)(unsafe.Pointer(out + uintptr(i*stride+r1+r2)*4)) = *(*float32)(unsafe.Pointer(in + uintptr(i*2*stride+r1+r2)*4))
			}
		}
	}

	for r1 = 0; r1 < rep1*rep2; r1 = r1 + rep2 {
		for r2 = 0; r2 < rep2; r2++ {
			*(*float32)(unsafe.Pointer(out + uintptr(N/2*stride+r1+r2)*4)) = 1.4142135623730951 * *(*float32)(unsafe.Pointer(in + uintptr(1*stride+r1+r2)*4))
		}
		for i = 1; i < N/2; i++ {
			for r2 = 0; r2 < rep2; r2++ {
				*(*float32)(unsafe.Pointer(out + uintptr((N/2+i)*stride+r1+r2)*4)) = *(*float32)(unsafe.Pointer(in + uintptr((i*2-1)*stride+r1+r2)*4)) + *(*float32)(unsafe.Pointer(in + uintptr((i*2+1)*stride+r1+r2)*4))
			}
		}
	}

	(*struct {
		f func(*libc.TLS, uintptr, uintptr, Int32_t, Int32_t, Int32_t)
	})(unsafe.Pointer(&struct{ uintptr }{half_inverse_dct})).f(tls, in, out, t-1, rep1, rep2)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, Int32_t, Int32_t, Int32_t)
	})(unsafe.Pointer(&struct{ uintptr }{half_inverse_dct})).f(tls, in+uintptr(N/2*stride)*4, out+uintptr(N/2*stride)*4, t-1, rep1, rep2)

	for r1 = 0; r1 < rep1*rep2; r1 = r1 + rep2 {
		for i = 0; i < N/2; i++ {
			var mult float32 = sJ40__HALF_SECANTS[N/2+i]
			for r2 = 0; r2 < rep2; r2++ {
				var x float32 = *(*float32)(unsafe.Pointer(in + uintptr(i*stride+r1+r2)*4))
				var y float32 = *(*float32)(unsafe.Pointer(in + uintptr((N/2+i)*stride+r1+r2)*4))

				*(*float32)(unsafe.Pointer(out + uintptr(i*stride+r1+r2)*4)) = x + y*mult
				*(*float32)(unsafe.Pointer(out + uintptr((N-i-1)*stride+r1+r2)*4)) = x - y*mult
			}
		}
	}
}

func J40__dct2(tls *libc.TLS, out uintptr, in uintptr, t Int32_t, rep1 Int32_t, rep2 Int32_t) {
	var r1 Int32_t
	var r2 Int32_t
	var stride Int32_t = rep1 * rep2
	_ = t
	for r1 = 0; r1 < rep1*rep2; r1 = r1 + rep2 {
		for r2 = 0; r2 < rep2; r2++ {
			var x float32 = *(*float32)(unsafe.Pointer(in + uintptr(0*stride+r1+r2)*4))
			var y float32 = *(*float32)(unsafe.Pointer(in + uintptr(1*stride+r1+r2)*4))
			*(*float32)(unsafe.Pointer(out + uintptr(0*stride+r1+r2)*4)) = x + y
			*(*float32)(unsafe.Pointer(out + uintptr(1*stride+r1+r2)*4)) = x - y
		}
	}
}

func J40__forward_dct4(tls *libc.TLS, out uintptr, in uintptr, t Int32_t, rep1 Int32_t, rep2 Int32_t) {
	_ = t
	J40__forward_dct_core(tls, out, in, 2, rep1, rep2, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, Int32_t, Int32_t, Int32_t)
	}{J40__dct2})))
}

func j40__forward_dct_recur(tls *libc.TLS, out uintptr, in uintptr, t Int32_t, rep1 Int32_t, rep2 Int32_t) {
	if t < 4 {
		J40__forward_dct_core(tls, out, in, 3, rep1, rep2, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, Int32_t, Int32_t, Int32_t)
		}{J40__forward_dct4})))
	} else {
		J40__forward_dct_core(tls, out, in, t, rep1, rep2, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, Int32_t, Int32_t, Int32_t)
		}{j40__forward_dct_recur})))
	}
}

func j40__forward_dct_recur_x8(tls *libc.TLS, out uintptr, in uintptr, t Int32_t, rep1 Int32_t, rep2 Int32_t) {
	_ = rep2
	if t < 4 {
		J40__forward_dct_core(tls, out, in, 3, rep1, 8, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, Int32_t, Int32_t, Int32_t)
		}{J40__forward_dct4})))
	} else {
		J40__forward_dct_core(tls, out, in, t, rep1, 8, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, Int32_t, Int32_t, Int32_t)
		}{j40__forward_dct_recur_x8})))
	}
}

// this omits the final division by (1 << t)!
func j40__forward_dct_unscaled(tls *libc.TLS, out uintptr, in uintptr, t Int32_t, rep Int32_t) {
	if t <= 0 {
		libc.Xmemcpy(tls, out, in, uint64(unsafe.Sizeof(float32(0)))*Size_t(rep))
	} else if rep%8 == 0 {
		if t == 1 {
			J40__dct2(tls, out, in, 1, rep/8, 8)
			return
		}
		if t == 2 {
			J40__forward_dct4(tls, out, in, 2, rep/8, 8)
			return
		}
		j40__forward_dct_recur_x8(tls, out, in, t, rep/8, 8)
	} else {
		if t == 1 {
			J40__dct2(tls, out, in, 1, rep, 1)
			return
		}
		if t == 2 {
			J40__forward_dct4(tls, out, in, 2, rep, 1)
			return
		}
		j40__forward_dct_recur(tls, out, in, t, rep, 1)
	}
}

func J40__forward_dct_unscaled_view(tls *libc.TLS, outv uintptr, inv uintptr) {
	J40__adapt_view_f32(tls, outv, (*J40__view_f32)(unsafe.Pointer(inv)).Logw, (*J40__view_f32)(unsafe.Pointer(inv)).Logh)
	j40__forward_dct_unscaled(tls, (*J40__view_f32)(unsafe.Pointer(outv)).Ptr, (*J40__view_f32)(unsafe.Pointer(inv)).Ptr, (*J40__view_f32)(unsafe.Pointer(inv)).Logh, int32(1)<<(*J40__view_f32)(unsafe.Pointer(inv)).Logw)
}

func J40__inverse_dct4(tls *libc.TLS, out uintptr, in uintptr, t Int32_t, rep1 Int32_t, rep2 Int32_t) {
	_ = t
	J40__inverse_dct_core(tls, out, in, 2, rep1, rep2, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, Int32_t, Int32_t, Int32_t)
	}{J40__dct2})))
}

func j40__inverse_dct_recur(tls *libc.TLS, out uintptr, in uintptr, t Int32_t, rep1 Int32_t, rep2 Int32_t) {
	if t < 4 {
		J40__inverse_dct_core(tls, out, in, 3, rep1, rep2, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, Int32_t, Int32_t, Int32_t)
		}{J40__inverse_dct4})))
	} else {
		J40__inverse_dct_core(tls, out, in, t, rep1, rep2, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, Int32_t, Int32_t, Int32_t)
		}{j40__inverse_dct_recur})))
	}
}

func j40__inverse_dct_recur_x8(tls *libc.TLS, out uintptr, in uintptr, t Int32_t, rep1 Int32_t, rep2 Int32_t) {
	_ = rep2
	if t < 4 {
		J40__inverse_dct_core(tls, out, in, 3, rep1, 8, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, Int32_t, Int32_t, Int32_t)
		}{J40__inverse_dct4})))
	} else {
		J40__inverse_dct_core(tls, out, in, t, rep1, 8, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, Int32_t, Int32_t, Int32_t)
		}{j40__inverse_dct_recur_x8})))
	}
}

func j40__inverse_dct(tls *libc.TLS, out uintptr, in uintptr, t Int32_t, rep Int32_t) {
	if t <= 0 {
		libc.Xmemcpy(tls, out, in, uint64(unsafe.Sizeof(float32(0)))*Size_t(rep))
	} else if rep%8 == 0 {
		if t == 1 {
			J40__dct2(tls, out, in, 1, rep/8, 8)
			return
		}
		if t == 2 {
			J40__inverse_dct4(tls, out, in, 2, rep/8, 8)
			return
		}
		j40__inverse_dct_recur_x8(tls, out, in, t, rep/8, 8)
		return
	} else {
		if t == 1 {
			J40__dct2(tls, out, in, 1, rep, 1)
			return
		}
		if t == 2 {
			J40__inverse_dct4(tls, out, in, 2, rep, 1)
			return
		}
		j40__inverse_dct_recur(tls, out, in, t, rep, 1)
		return
	}
}

func J40__inverse_dct_view(tls *libc.TLS, outv uintptr, inv uintptr) {
	J40__adapt_view_f32(tls, outv, (*J40__view_f32)(unsafe.Pointer(inv)).Logw, (*J40__view_f32)(unsafe.Pointer(inv)).Logh)
	j40__inverse_dct(tls, (*J40__view_f32)(unsafe.Pointer(outv)).Ptr, (*J40__view_f32)(unsafe.Pointer(inv)).Ptr, (*J40__view_f32)(unsafe.Pointer(inv)).Logh, int32(1)<<(*J40__view_f32)(unsafe.Pointer(inv)).Logw)
}

func j40__forward_dct2d_scaled_for_llf(tls *libc.TLS, buf uintptr, scratch uintptr, log_rows Int32_t, log_columns Int32_t) {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	*(*J40__view_f32)(unsafe.Pointer(bp + 16)) = J40__make_view_f32(tls, log_columns, log_rows, buf)
	*(*J40__view_f32)(unsafe.Pointer(bp)) = J40__make_view_f32(tls, log_columns, log_rows, scratch)
	var p uintptr
	var x Int32_t
	var y Int32_t

	J40__forward_dct_unscaled_view(tls, bp, bp+16)
	J40__transpose_view_f32(tls, bp+16, *(*J40__view_f32)(unsafe.Pointer(bp)))
	J40__forward_dct_unscaled_view(tls, bp, bp+16)

	for y = 0; y < int32(1)<<(*J40__view_f32)(unsafe.Pointer(bp)).Logh; y++ {
		for x = 0; x < int32(1)<<(*J40__view_f32)(unsafe.Pointer(bp)).Logw && func() bool {
			p = (*J40__view_f32)(unsafe.Pointer(bp)).Ptr + uintptr(y<<(*J40__view_f32)(unsafe.Pointer(bp)).Logw|x)*4
			return 1 != 0
		}(); x++ {
			*(*float32)(unsafe.Pointer(p)) *= sJ40__LF2LLF_SCALES[int32(1)<<(*J40__view_f32)(unsafe.Pointer(bp)).Logw+x] * sJ40__LF2LLF_SCALES[int32(1)<<(*J40__view_f32)(unsafe.Pointer(bp)).Logh+y]
		}
	}

	if log_columns > log_rows {
		J40__transpose_view_f32(tls, bp+16, *(*J40__view_f32)(unsafe.Pointer(bp)))
	} else {
		J40__copy_view_f32(tls, bp+16, *(*J40__view_f32)(unsafe.Pointer(bp)))
	}

}

func j40__inverse_dct2d(tls *libc.TLS, buf uintptr, scratch uintptr, log_rows Int32_t, log_columns Int32_t) {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	*(*J40__view_f32)(unsafe.Pointer(bp)) = J40__make_view_f32(tls, log_columns, log_rows, scratch)

	if log_columns > log_rows {
		*(*J40__view_f32)(unsafe.Pointer(bp + 16)) = J40__make_view_f32(tls, log_columns, log_rows, buf)
		J40__transpose_view_f32(tls, bp, *(*J40__view_f32)(unsafe.Pointer(bp + 16)))
	} else {
		*(*J40__view_f32)(unsafe.Pointer(bp + 16)) = J40__make_view_f32(tls, log_rows, log_columns, buf)
		J40__copy_view_f32(tls, bp, *(*J40__view_f32)(unsafe.Pointer(bp + 16)))
	}
	J40__inverse_dct_view(tls, bp+16, bp)
	J40__transpose_view_f32(tls, bp, *(*J40__view_f32)(unsafe.Pointer(bp + 16)))
	J40__inverse_dct_view(tls, bp+16, bp)

}

// a single iteration of AuxIDCT2x2
func J40__aux_inverse_dct11(tls *libc.TLS, out uintptr, in uintptr, x Int32_t, y Int32_t, S2 Int32_t) {
	var p Int32_t = y*8 + x
	var q Int32_t = y*2*8 + x*2
	var c00 float32 = *(*float32)(unsafe.Pointer(in + uintptr(p)*4))
	var c01 float32 = *(*float32)(unsafe.Pointer(in + uintptr(p+S2)*4))
	var c10 float32 = *(*float32)(unsafe.Pointer(in + uintptr(p+S2*8)*4))
	var c11 float32 = *(*float32)(unsafe.Pointer(in + uintptr(p+S2*9)*4))
	*(*float32)(unsafe.Pointer(out + uintptr(q+000)*4)) = c00 + c01 + c10 + c11
	*(*float32)(unsafe.Pointer(out + uintptr(q+001)*4)) = c00 + c01 - c10 - c11
	*(*float32)(unsafe.Pointer(out + uintptr(q+010)*4)) = c00 - c01 + c10 - c11
	*(*float32)(unsafe.Pointer(out + uintptr(q+011)*4)) = c00 - c01 - c10 + c11
}

func j40__inverse_dct11(tls *libc.TLS, buf uintptr) {
	bp := tls.Alloc(256)
	defer tls.Free(256)

	var x Int32_t
	var y Int32_t

	J40__aux_inverse_dct11(tls, buf, buf, 0, 0, 1)

	libc.Xmemcpy(tls, bp, buf, uint64(unsafe.Sizeof(float32(0)))*uint64(64))
	for y = 0; y < 2; y++ {
		for x = 0; x < 2; x++ {
			J40__aux_inverse_dct11(tls, bp, buf, x, y, 2)
		}
	}

	for y = 0; y < 4; y++ {
		for x = 0; x < 4; x++ {
			J40__aux_inverse_dct11(tls, buf, bp, x, y, 4)
		}
	}
}

func j40__inverse_dct22(tls *libc.TLS, buf uintptr) {
	bp := tls.Alloc(256)
	defer tls.Free(256)

	var x Int32_t
	var y Int32_t

	J40__aux_inverse_dct11(tls, buf, buf, 0, 0, 1)

	j40__inverse_dct(tls, bp, buf, 2, 16)
	for y = 0; y < 8; y++ {
		for x = 0; x < 8; x++ {
			*(*float32)(unsafe.Pointer(buf + uintptr(x*8+y)*4)) = *(*float32)(unsafe.Pointer(bp + uintptr(y*8+x)*4))
		}
	}
	j40__inverse_dct(tls, bp, buf, 2, 16)
	for y = 0; y < 4; y++ {
		for x = 0; x < 4; x++ {
			*(*float32)(unsafe.Pointer(buf + uintptr(y*8+x)*4)) = *(*float32)(unsafe.Pointer(bp + uintptr(y*2*8+x*2)*4))
			*(*float32)(unsafe.Pointer(buf + uintptr(y*8+(x+4))*4)) = *(*float32)(unsafe.Pointer(bp + uintptr((y*2+1)*8+x*2)*4))
			*(*float32)(unsafe.Pointer(buf + uintptr((y+4)*8+x)*4)) = *(*float32)(unsafe.Pointer(bp + uintptr(y*2*8+(x*2+1))*4))
			*(*float32)(unsafe.Pointer(buf + uintptr((y+4)*8+(x+4))*4)) = *(*float32)(unsafe.Pointer(bp + uintptr((y*2+1)*8+(x*2+1))*4))
		}
	}
}

func j40__inverse_hornuss(tls *libc.TLS, buf uintptr) {
	bp := tls.Alloc(272)
	defer tls.Free(272)

	var x Int32_t
	var y Int32_t
	var ix Int32_t
	var iy Int32_t
	libc.Xmemcpy(tls, bp, buf, uint64(unsafe.Sizeof(float32(0)))*uint64(64))
	J40__aux_inverse_dct11(tls, bp, buf, 0, 0, 1)
	for y = 0; y < 2; y++ {
		for x = 0; x < 2; x++ {
			var pos00 Int32_t = y*8 + x
			var pos11 Int32_t = (y+2)*8 + (x + 2)
			*(*[4]float32)(unsafe.Pointer(bp + 256)) = [4]float32{}
			var sample11 float32
			for iy = 0; iy < 4; iy++ {
				for ix = 0; ix < 4; ix++ {
					*(*float32)(unsafe.Pointer(bp + 256 + uintptr(ix)*4)) += *(*float32)(unsafe.Pointer(bp + uintptr((y+iy*2)*8+(x+ix*2))*4))
				}
			}

			sample11 = *(*float32)(unsafe.Pointer(bp + uintptr(pos00)*4)) - (*(*float32)(unsafe.Pointer(bp + 256))+*(*float32)(unsafe.Pointer(bp + 256 + 1*4))+*(*float32)(unsafe.Pointer(bp + 256 + 2*4))+*(*float32)(unsafe.Pointer(bp + 256 + 3*4))-*(*float32)(unsafe.Pointer(bp + uintptr(pos00)*4)))*0.0625
			*(*float32)(unsafe.Pointer(bp + uintptr(pos00)*4)) = *(*float32)(unsafe.Pointer(bp + uintptr(pos11)*4))
			*(*float32)(unsafe.Pointer(bp + uintptr(pos11)*4)) = 0.0
			for iy = 0; iy < 4; iy++ {
				for ix = 0; ix < 4; ix++ {
					*(*float32)(unsafe.Pointer(buf + uintptr((4*y+iy)*8+(4*x+ix))*4)) = *(*float32)(unsafe.Pointer(bp + uintptr((y+iy*2)*8+(x+ix*2))*4)) + sample11
				}
			}
		}
	}
}

func j40__inverse_dct32(tls *libc.TLS, buf uintptr) {
	bp := tls.Alloc(288)
	defer tls.Free(288)

	var tmp float32
	*(*J40__view_f32)(unsafe.Pointer(bp + 256)) = J40__make_view_f32(tls, 3, 3, buf)
	*(*J40__view_f32)(unsafe.Pointer(bp + 272)) = J40__make_view_f32(tls, 3, 3, bp)

	tmp = *(*float32)(unsafe.Pointer(func() uintptr {
		return (*J40__view_f32)(unsafe.Pointer(bp+256)).Ptr + uintptr(int32(0)<<(*J40__view_f32)(unsafe.Pointer(bp+256)).Logw|0)*4
	}())) + *(*float32)(unsafe.Pointer(func() uintptr {
		return (*J40__view_f32)(unsafe.Pointer(bp+256)).Ptr + uintptr(int32(1)<<(*J40__view_f32)(unsafe.Pointer(bp+256)).Logw|0)*4
	}()))
	*(*float32)(unsafe.Pointer(func() uintptr {
		return (*J40__view_f32)(unsafe.Pointer(bp+256)).Ptr + uintptr(int32(1)<<(*J40__view_f32)(unsafe.Pointer(bp+256)).Logw|0)*4
	}())) = *(*float32)(unsafe.Pointer(func() uintptr {
		return (*J40__view_f32)(unsafe.Pointer(bp+256)).Ptr + uintptr(int32(0)<<(*J40__view_f32)(unsafe.Pointer(bp+256)).Logw|0)*4
	}())) - *(*float32)(unsafe.Pointer(func() uintptr {
		return (*J40__view_f32)(unsafe.Pointer(bp+256)).Ptr + uintptr(int32(1)<<(*J40__view_f32)(unsafe.Pointer(bp+256)).Logw|0)*4
	}()))
	*(*float32)(unsafe.Pointer(func() uintptr {
		return (*J40__view_f32)(unsafe.Pointer(bp+256)).Ptr + uintptr(int32(0)<<(*J40__view_f32)(unsafe.Pointer(bp+256)).Logw|0)*4
	}())) = tmp
	J40__reshape_view_f32(tls, bp+256, 4, 2)
	J40__inverse_dct_view(tls, bp+272, bp+256)
	J40__reshape_view_f32(tls, bp+272, 3, 3)
	J40__transpose_view_f32(tls, bp+256, *(*J40__view_f32)(unsafe.Pointer(bp + 272)))
	J40__inverse_dct_view(tls, bp+272, bp+256)
	J40__oddeven_columns_to_halves_f32(tls, bp+256, *(*J40__view_f32)(unsafe.Pointer(bp + 272)))

}

func j40__inverse_dct23(tls *libc.TLS, buf uintptr) {
	bp := tls.Alloc(288)
	defer tls.Free(288)

	*(*J40__view_f32)(unsafe.Pointer(bp + 272)) = J40__make_view_f32(tls, 3, 3, buf)
	*(*J40__view_f32)(unsafe.Pointer(bp + 256)) = J40__make_view_f32(tls, 3, 3, bp)

	J40__copy_view_f32(tls, bp+256, *(*J40__view_f32)(unsafe.Pointer(bp + 272)))
	*(*float32)(unsafe.Pointer(func() uintptr {
		return (*J40__view_f32)(unsafe.Pointer(bp+256)).Ptr + uintptr(int32(0)<<(*J40__view_f32)(unsafe.Pointer(bp+256)).Logw|0)*4
	}())) = *(*float32)(unsafe.Pointer(func() uintptr {
		return (*J40__view_f32)(unsafe.Pointer(bp+272)).Ptr + uintptr(int32(0)<<(*J40__view_f32)(unsafe.Pointer(bp+272)).Logw|0)*4
	}())) + *(*float32)(unsafe.Pointer(func() uintptr {
		return (*J40__view_f32)(unsafe.Pointer(bp+272)).Ptr + uintptr(int32(1)<<(*J40__view_f32)(unsafe.Pointer(bp+272)).Logw|0)*4
	}()))
	*(*float32)(unsafe.Pointer(func() uintptr {
		return (*J40__view_f32)(unsafe.Pointer(bp+256)).Ptr + uintptr(int32(1)<<(*J40__view_f32)(unsafe.Pointer(bp+256)).Logw|0)*4
	}())) = *(*float32)(unsafe.Pointer(func() uintptr {
		return (*J40__view_f32)(unsafe.Pointer(bp+272)).Ptr + uintptr(int32(0)<<(*J40__view_f32)(unsafe.Pointer(bp+272)).Logw|0)*4
	}())) - *(*float32)(unsafe.Pointer(func() uintptr {
		return (*J40__view_f32)(unsafe.Pointer(bp+272)).Ptr + uintptr(int32(1)<<(*J40__view_f32)(unsafe.Pointer(bp+272)).Logw|0)*4
	}()))
	J40__transpose_view_f32(tls, bp+272, *(*J40__view_f32)(unsafe.Pointer(bp + 256)))
	J40__inverse_dct_view(tls, bp+256, bp+272)
	J40__transpose_view_f32(tls, bp+272, *(*J40__view_f32)(unsafe.Pointer(bp + 256)))
	J40__reshape_view_f32(tls, bp+272, 4, 2)
	J40__inverse_dct_view(tls, bp+256, bp+272)
	J40__reshape_view_f32(tls, bp+256, 3, 3)
	J40__oddeven_rows_to_halves_f32(tls, bp+272, *(*J40__view_f32)(unsafe.Pointer(bp + 256)))

}

// TODO spec issue: the input is a 4x4 matrix but indexed like a 1-dimensional array
func j40__inverse_afv22(tls *libc.TLS, out uintptr, in uintptr) {
	var i Int32_t
	var j Int32_t
	for i = 0; i < 16; i++ {
		var sum float32 = 0.0
		for j = 0; j < 16; j++ {
			sum = sum + *(*float32)(unsafe.Pointer(in + uintptr(j)*4))*AFV_BASIS[i*16+j]
		}
		*(*float32)(unsafe.Pointer(out + uintptr(i)*4)) = sum
	}
}

var AFV_BASIS = [256]float32{
	0.25000000, 0.87690293, 0.00000000, 0.00000000,
	0.00000000, -0.41053776, 0.00000000, 0.00000000,
	0.00000000, 0.00000000, 0.00000000, 0.00000000,
	0.00000000, 0.00000000, 0.00000000, 0.00000000,
	0.25000000, 0.22065181, 0.00000000, 0.00000000,
	-0.70710678, 0.62354854, 0.00000000, 0.00000000,
	0.00000000, 0.00000000, 0.00000000, 0.00000000,
	0.00000000, 0.00000000, 0.00000000, 0.00000000,
	0.25000000, -0.10140050, 0.40670076, -0.21255748,
	0.00000000, -0.06435072, -0.45175566, -0.30468475,
	0.30179295, 0.40824829, 0.17478670, -0.21105601,
	-0.14266085, -0.13813540, -0.17437603, 0.11354987,
	0.25000000, -0.10140050, 0.44444817, 0.30854971,
	0.00000000, -0.06435072, 0.15854504, 0.51126161,
	0.25792363, 0.00000000, 0.08126112, 0.18567181,
	-0.34164468, 0.33022826, 0.07027907, -0.07417505,
	0.25000000, 0.22065181, 0.00000000, 0.00000000,
	0.70710678, 0.62354854, 0.00000000, 0.00000000,
	0.00000000, 0.00000000, 0.00000000, 0.00000000,
	0.00000000, 0.00000000, 0.00000000, 0.00000000,
	0.25000000, -0.10140050, 0.00000000, 0.47067023,
	0.00000000, -0.06435072, -0.04038515, 0.00000000,
	0.16272340, 0.00000000, 0.00000000, 0.00000000,
	0.73674975, 0.08755115, -0.29210266, 0.19402893,
	0.25000000, -0.10140050, 0.19574399, -0.16212052,
	0.00000000, -0.06435072, 0.00741823, -0.29048013,
	0.09520023, 0.00000000, -0.36753980, 0.49215859,
	0.24627108, -0.07946707, 0.36238173, -0.43519050,
	0.25000000, -0.10140050, 0.29291001, 0.00000000,
	0.00000000, -0.06435072, 0.39351034, -0.06578702,
	0.00000000, -0.40824829, -0.30788221, -0.38525014,
	-0.08574019, -0.46133749, 0.00000000, 0.21918685,
	0.25000000, -0.10140050, -0.40670076, -0.21255748,
	0.00000000, -0.06435072, -0.45175566, 0.30468475,
	0.30179295, -0.40824829, -0.17478670, 0.21105601,
	-0.14266085, -0.13813540, -0.17437603, 0.11354987,
	0.25000000, -0.10140050, -0.19574399, -0.16212052,
	0.00000000, -0.06435072, 0.00741823, 0.29048013,
	0.09520023, 0.00000000, 0.36753980, -0.49215859,
	0.24627108, -0.07946707, 0.36238173, -0.43519050,
	0.25000000, -0.10140050, 0.00000000, -0.47067023,
	0.00000000, -0.06435072, 0.11074166, 0.00000000,
	-0.16272340, 0.00000000, 0.00000000, 0.00000000,
	0.14883399, 0.49724647, 0.29210266, 0.55504438,
	0.25000000, -0.10140050, 0.11379074, -0.14642919,
	0.00000000, -0.06435072, 0.08298163, -0.23889774,
	-0.35312385, -0.40824829, 0.48266891, 0.17419413,
	-0.04768680, 0.12538059, -0.43266080, -0.25468277,
	0.25000000, -0.10140050, -0.44444817, 0.30854971,
	0.00000000, -0.06435072, 0.15854504, -0.51126161,
	0.25792363, 0.00000000, -0.08126112, -0.18567181,
	-0.34164468, 0.33022826, 0.07027907, -0.07417505,
	0.25000000, -0.10140050, -0.29291001, 0.00000000,
	0.00000000, -0.06435072, 0.39351034, 0.06578702,
	0.00000000, 0.40824829, 0.30788221, 0.38525014,
	-0.08574019, -0.46133749, 0.00000000, 0.21918685,
	0.25000000, -0.10140050, -0.11379074, -0.14642919,
	0.00000000, -0.06435072, 0.08298163, 0.23889774,
	-0.35312385, 0.40824829, -0.48266891, -0.17419413,
	-0.04768680, 0.12538059, -0.43266080, -0.25468277,
	0.25000000, -0.10140050, 0.00000000, 0.42511496,
	0.00000000, -0.06435072, -0.45175566, 0.00000000,
	-0.60358590, 0.00000000, 0.00000000, 0.00000000,
	-0.14266085, -0.13813540, 0.34875205, 0.11354987,
}

func j40__inverse_afv(tls *libc.TLS, buf uintptr, flipx int32, flipy int32) {
	bp := tls.Alloc(256)
	defer tls.Free(256)

	var bufafv uintptr = buf
	var buf22 uintptr = buf + uintptr(16)*4
	var buf23 uintptr = buf + uintptr(32)*4
	var buf32 uintptr = buf23
	var scratchafv uintptr = bp
	var scratch22 uintptr = bp + uintptr(16)*4
	var scratch23 uintptr = bp + uintptr(32)*4
	var scratch32 uintptr = scratch23
	var x Int32_t
	var y Int32_t

	for y = 0; y < 8; y = y + 2 {
		for x = 0; x < 8; x++ {
			*(*float32)(unsafe.Pointer(bp + uintptr(x%2*16+y/2*4+x/2)*4)) = *(*float32)(unsafe.Pointer(buf + uintptr(y*8+x)*4))
		}
	}
	for y = 1; y < 8; y = y + 2 {
		for x = 0; x < 8; x++ {
			*(*float32)(unsafe.Pointer(scratch32 + uintptr(x*4+y/2)*4)) = *(*float32)(unsafe.Pointer(buf + uintptr(y*8+x)*4))
		}
	}
	*(*float32)(unsafe.Pointer(scratchafv)) = (*(*float32)(unsafe.Pointer(buf)) + *(*float32)(unsafe.Pointer(buf + 1*4)) + *(*float32)(unsafe.Pointer(buf + 8*4))) * 4.0
	*(*float32)(unsafe.Pointer(scratch22)) = *(*float32)(unsafe.Pointer(buf)) - *(*float32)(unsafe.Pointer(buf + 1*4)) + *(*float32)(unsafe.Pointer(buf + 8*4))
	*(*float32)(unsafe.Pointer(scratch32)) = *(*float32)(unsafe.Pointer(buf)) - *(*float32)(unsafe.Pointer(buf + 8*4))

	j40__inverse_afv22(tls, bufafv, scratchafv)
	j40__inverse_dct(tls, buf22, scratch22, 2, 4)
	j40__inverse_dct(tls, buf32, scratch32, 3, 4)

	for y = 0; y < 4; y++ {
		for x = 0; x < 4; x++ {
			*(*float32)(unsafe.Pointer(scratchafv + uintptr(y*4+x)*4)) = *(*float32)(unsafe.Pointer(bufafv + uintptr(y*4+x)*4))
		}
		for x = 0; x < 4; x++ {
			*(*float32)(unsafe.Pointer(scratch22 + uintptr(x*4+y)*4)) = *(*float32)(unsafe.Pointer(buf22 + uintptr(y*4+x)*4))
		}
	}
	for y = 0; y < 8; y++ {
		for x = 0; x < 4; x++ {
			*(*float32)(unsafe.Pointer(scratch23 + uintptr(x*8+y)*4)) = *(*float32)(unsafe.Pointer(buf32 + uintptr(y*4+x)*4))
		}
	}

	j40__inverse_dct(tls, buf22, scratch22, 2, 4)
	j40__inverse_dct(tls, buf23, scratch23, 2, 8)
	libc.Xmemcpy(tls, bp+uintptr(16)*4, buf+uintptr(16)*4, uint64(unsafe.Sizeof(float32(0)))*uint64(48))

	for y = 0; y < 4; y++ {
		var afv22pos Int32_t = int32(*(*Int8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&FLIP_FOR_AFV)) + uintptr(flipy)*4 + uintptr(y)))) * 8
		var dct22pos Int32_t = (flipy*4+y)*8 + libc.BoolInt32(!(flipx != 0))*4
		var dct23pos Int32_t = (libc.BoolInt32(!(flipy != 0))*4 + y) * 8
		for x = 0; x < 4; x++ {
			*(*float32)(unsafe.Pointer(buf + uintptr(afv22pos+Int32_t(*(*Int8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&FLIP_FOR_AFV)) + uintptr(flipx)*4 + uintptr(x)))))*4)) = *(*float32)(unsafe.Pointer(scratchafv + uintptr(y*4+x)*4))
		}
		for x = 0; x < 4; x++ {
			*(*float32)(unsafe.Pointer(buf + uintptr(dct22pos+x)*4)) = *(*float32)(unsafe.Pointer(scratch22 + uintptr(y*4+x)*4))
		}

		for x = 0; x < 8; x++ {
			*(*float32)(unsafe.Pointer(buf + uintptr(dct23pos+x)*4)) = *(*float32)(unsafe.Pointer(scratch23 + uintptr(y*8+x)*4))
		}
	}
}

var FLIP_FOR_AFV = [2][4]Int8_t{{int8(0), int8(1), int8(2), int8(3)}, {int8(7), int8(6), int8(5), int8(4)}}

func j40__lf_global(tls *libc.TLS, st uintptr) J40_err {
	var f uintptr
	var sidx Int32_t
	var i Int32_t
	var j Int32_t
	var max_tree_size Int32_t
	f = (*J40__st)(unsafe.Pointer(st)).Frame
	sidx = 0

	if !((*J40__frame_st)(unsafe.Pointer(f)).Has_patches != 0) {
		goto __1
	}
__2:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 559))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 559 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 559 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 559 + 3))))
	goto J40__ON_ERROR
	goto __3
__3:
	if 0 != 0 {
		goto __2
	}
	goto __4
__4:
	;
__1:
	;
	if !((*J40__frame_st)(unsafe.Pointer(f)).Has_splines != 0) {
		goto __5
	}
__6:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 573))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 573 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 573 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 573 + 3))))
	goto J40__ON_ERROR
	goto __7
__7:
	if 0 != 0 {
		goto __6
	}
	goto __8
__8:
	;
__5:
	;
	if !((*J40__frame_st)(unsafe.Pointer(f)).Has_noise != 0) {
		goto __9
	}
__10:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 587))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 587 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 587 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 587 + 3))))
	goto J40__ON_ERROR
	goto __11
__11:
	if 0 != 0 {
		goto __10
	}
	goto __12
__12:
	;
__9:
	;
	if !!(j40__u(tls, st, 1) != 0) {
		goto __13
	}

	i = 0
__14:
	if !(i < 3) {
		goto __16
	}
	*(*float32)(unsafe.Pointer(f + 304 + uintptr(i)*4)) = j40__f16(tls, st) / 128.0
	goto __15
__15:
	i++
	goto __14
	goto __16
__16:
	;
__13:
	;
	if !!((*J40__frame_st)(unsafe.Pointer(f)).Is_modular != 0) {
		goto __17
	}
	(*J40__frame_st)(unsafe.Pointer(f)).Global_scale = j40__u32(tls, st, 1, 11, 2049, 11, 4097, 12, 8193, 16)
	(*J40__frame_st)(unsafe.Pointer(f)).Quant_lf = j40__u32(tls, st, 16, 0, 1, 5, 1, 8, 1, 16)

	if !(j40__u(tls, st, 1) != 0) {
		goto __18
	}
	(*J40__frame_st)(unsafe.Pointer(f)).Block_ctx_size = int32(uint64(unsafe.Sizeof(DEFAULT_BLKCTX)) / uint64(unsafe.Sizeof(Uint8_t(0))))
__20:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __23
	}
	goto J40__ON_ERROR
__23:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(f+816, j40__malloc(tls, uint64(unsafe.Sizeof(DEFAULT_BLKCTX))))) != 0)), int64(0)) != 0) {
		goto __24
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__24:
	;
	goto __21
__21:
	if 0 != 0 {
		goto __20
	}
	goto __22
__22:
	;
	libc.Xmemcpy(tls, (*J40__frame_st)(unsafe.Pointer(f)).Block_ctx_map, uintptr(unsafe.Pointer(&DEFAULT_BLKCTX)), uint64(unsafe.Sizeof(DEFAULT_BLKCTX)))
	(*J40__frame_st)(unsafe.Pointer(f)).Nb_qf_thr = libc.AssignPtrInt32(f+796, libc.AssignPtrInt32(f+796+1*4, libc.AssignPtrInt32(f+796+2*4, 0)))
	(*J40__frame_st)(unsafe.Pointer(f)).Nb_block_ctx = 15
	goto __19
__18:
__25:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __28
	}
	goto J40__ON_ERROR
__28:
	;
	goto __26
__26:
	if 0 != 0 {
		goto __25
	}
	goto __27
__27:
	;
	(*J40__frame_st)(unsafe.Pointer(f)).Block_ctx_size = 39
	i = 0
__29:
	if !(i < 3) {
		goto __31
	}
	*(*Int32_t)(unsafe.Pointer(f + 796 + uintptr(i)*4)) = j40__u(tls, st, 4)

	j = 0
__32:
	if !(j < *(*Int32_t)(unsafe.Pointer(f + 796 + uintptr(i)*4))) {
		goto __34
	}
	*(*Int32_t)(unsafe.Pointer(f + 556 + uintptr(i)*60 + uintptr(j)*4)) = Int32_t(J40__unpack_signed64(tls, j40__64u32(tls, st, 0, 4, 16, 8, 272, 16, 65808, 32)))
	goto __33
__33:
	j++
	goto __32
	goto __34
__34:
	;
	*(*Int32_t)(unsafe.Pointer(f + 824)) *= *(*Int32_t)(unsafe.Pointer(f + 796 + uintptr(i)*4)) + 1
	goto __30
__30:
	i++
	goto __29
	goto __31
__31:
	;
	(*J40__frame_st)(unsafe.Pointer(f)).Nb_qf_thr = j40__u(tls, st, 4)

	i = 0
__35:
	if !(i < (*J40__frame_st)(unsafe.Pointer(f)).Nb_qf_thr) {
		goto __37
	}
	*(*Int32_t)(unsafe.Pointer(f + 736 + uintptr(i)*4)) = j40__u32(tls, st, 0, 2, 4, 3, 12, 5, 44, 8) + 1
	goto __36
__36:
	i++
	goto __35
	goto __37
__37:
	;
	*(*Int32_t)(unsafe.Pointer(f + 824)) *= (*J40__frame_st)(unsafe.Pointer(f)).Nb_qf_thr + 1

__38:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __41
	}
	goto J40__ON_ERROR
__41:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__frame_st)(unsafe.Pointer(f)).Block_ctx_size <= 39*64)), int64(0)) != 0) {
		goto __42
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 599))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 599 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 599 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 599 + 3))))
	goto J40__ON_ERROR
__42:
	;
	goto __39
__39:
	if 0 != 0 {
		goto __38
	}
	goto __40
__40:
	;
__43:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __46
	}
	goto J40__ON_ERROR
__46:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(f+816, j40__malloc(tls, uint64(unsafe.Sizeof(Uint8_t(0)))*Size_t((*J40__frame_st)(unsafe.Pointer(f)).Block_ctx_size)))) != 0)), int64(0)) != 0) {
		goto __47
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__47:
	;
	goto __44
__44:
	if 0 != 0 {
		goto __43
	}
	goto __45
__45:
	;
__48:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__cluster_map(tls, st, (*J40__frame_st)(unsafe.Pointer(f)).Block_ctx_size, 16, f+828, (*J40__frame_st)(unsafe.Pointer(f)).Block_ctx_map) != 0)), int64(0)) != 0) {
		goto __51
	}
	goto J40__ON_ERROR
__51:
	;
	goto __49
__49:
	if 0 != 0 {
		goto __48
	}
	goto __50
__50:
	;
__19:
	;
	if !!(j40__u(tls, st, 1) != 0) {
		goto __52
	}
	(*J40__frame_st)(unsafe.Pointer(f)).Inv_colour_factor = 1.0 / float32(j40__u32(tls, st, 84, 0, 256, 0, 2, 8, 258, 16))
	(*J40__frame_st)(unsafe.Pointer(f)).Base_corr_x = j40__f16(tls, st)
	(*J40__frame_st)(unsafe.Pointer(f)).Base_corr_b = j40__f16(tls, st)
	(*J40__frame_st)(unsafe.Pointer(f)).X_factor_lf = j40__u(tls, st, 8) - 127
	(*J40__frame_st)(unsafe.Pointer(f)).B_factor_lf = j40__u(tls, st, 8) - 127
__52:
	;
__17:
	;
__53:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_modular_for_global(tls, st, (*J40__frame_st)(unsafe.Pointer(f)).Is_modular, (*J40__frame_st)(unsafe.Pointer(f)).Do_ycbcr, (*J40__frame_st)(unsafe.Pointer(f)).Log_upsampling, (*J40__frame_st)(unsafe.Pointer(f)).Ec_log_upsampling, (*J40__frame_st)(unsafe.Pointer(f)).Width, (*J40__frame_st)(unsafe.Pointer(f)).Height, f+384) != 0)), int64(0)) != 0) {
		goto __56
	}
	goto J40__ON_ERROR
__56:
	;
	goto __54
__54:
	if 0 != 0 {
		goto __53
	}
	goto __55
__55:
	;
	if !(j40__u(tls, st, 1) != 0) {
		goto __57
	}
	max_tree_size = J40__min32(tls, int32(1)<<22,
		1024+J40__clamp_mul32(tls, J40__clamp_mul32(tls, (*J40__frame_st)(unsafe.Pointer(f)).Width, (*J40__frame_st)(unsafe.Pointer(f)).Height), (*J40__frame_st)(unsafe.Pointer(f)).Gmodular.Num_channels)/16)
__58:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__tree(tls, st, max_tree_size, f+320, f+328) != 0)), int64(0)) != 0) {
		goto __61
	}
	goto J40__ON_ERROR
__61:
	;
	goto __59
__59:
	if 0 != 0 {
		goto __58
	}
	goto __60
__60:
	;
__57:
	;
	if !((*J40__frame_st)(unsafe.Pointer(f)).Gmodular.Num_channels > 0) {
		goto __62
	}
__64:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__modular_header(tls, st, (*J40__frame_st)(unsafe.Pointer(f)).Global_tree, f+328, f+384) != 0)), int64(0)) != 0) {
		goto __67
	}
	goto J40__ON_ERROR
__67:
	;
	goto __65
__65:
	if 0 != 0 {
		goto __64
	}
	goto __66
__66:
	;
__68:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__allocate_modular(tls, st, f+384) != 0)), int64(0)) != 0) {
		goto __71
	}
	goto J40__ON_ERROR
__71:
	;
	goto __69
__69:
	if 0 != 0 {
		goto __68
	}
	goto __70
__70:
	;
	if !((*J40__frame_st)(unsafe.Pointer(f)).Width <= int32(1)<<(*J40__frame_st)(unsafe.Pointer(f)).Group_size_shift && (*J40__frame_st)(unsafe.Pointer(f)).Height <= int32(1)<<(*J40__frame_st)(unsafe.Pointer(f)).Group_size_shift) {
		goto __72
	}
	(*J40__frame_st)(unsafe.Pointer(f)).Num_gm_channels = (*J40__frame_st)(unsafe.Pointer(f)).Gmodular.Num_channels
	goto __73
__72:
	(*J40__frame_st)(unsafe.Pointer(f)).Num_gm_channels = (*J40__frame_st)(unsafe.Pointer(f)).Gmodular.Nb_meta_channels
__73:
	;
	i = 0
__74:
	if !(i < (*J40__frame_st)(unsafe.Pointer(f)).Num_gm_channels) {
		goto __76
	}
__77:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__modular_channel(tls, st, f+384, i, int64(sidx)) != 0)), int64(0)) != 0) {
		goto __80
	}
	goto J40__ON_ERROR
__80:
	;
	goto __78
__78:
	if 0 != 0 {
		goto __77
	}
	goto __79
__79:
	;
	goto __75
__75:
	i++
	goto __74
	goto __76
__76:
	;
__81:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__finish_and_free_code(tls, st, f+384+96) != 0)), int64(0)) != 0) {
		goto __84
	}
	goto J40__ON_ERROR
__84:
	;
	goto __82
__82:
	if 0 != 0 {
		goto __81
	}
	goto __83
__83:
	;
	goto __63
__62:
	(*J40__frame_st)(unsafe.Pointer(f)).Num_gm_channels = 0
__63:
	;
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

var DEFAULT_BLKCTX = [39]Uint8_t{
	Uint8_t(0), Uint8_t(1), Uint8_t(2), Uint8_t(2), Uint8_t(3), Uint8_t(3), Uint8_t(4), Uint8_t(5), Uint8_t(6), Uint8_t(6), Uint8_t(6), Uint8_t(6), Uint8_t(6),
	Uint8_t(7), Uint8_t(8), Uint8_t(9), Uint8_t(9), Uint8_t(10), Uint8_t(11), Uint8_t(12), Uint8_t(13), Uint8_t(14), Uint8_t(14), Uint8_t(14), Uint8_t(14), Uint8_t(14),
	Uint8_t(7), Uint8_t(8), Uint8_t(9), Uint8_t(9), Uint8_t(10), Uint8_t(11), Uint8_t(12), Uint8_t(13), Uint8_t(14), Uint8_t(14), Uint8_t(14), Uint8_t(14), Uint8_t(14),
}

type J40__varblock = struct {
	Coeffoff_qfidx Int32_t
	Hfmul          struct{ M1 Int32_t }
}

type J40__lf_group_st = J40__lf_group_st1

// out(x, y) = in(x, y) * mult (after type conversion)
func j40__dequant_lf16(tls *libc.TLS, in uintptr, mult float32, out uintptr) {
	var x Int32_t
	var y Int32_t

	for y = 0; y < (*J40__plane)(unsafe.Pointer(in)).Height; y++ {
		var inpixels uintptr = func() uintptr {
			return uintptr((*J40__plane)(unsafe.Pointer(in)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(in)).Stride_bytes)*Size_t(y))
		}()
		var outpixels uintptr = func() uintptr {
			return uintptr((*J40__plane)(unsafe.Pointer(out)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(out)).Stride_bytes)*Size_t(y))
		}()
		for x = 0; x < (*J40__plane)(unsafe.Pointer(in)).Width; x++ {
			*(*float32)(unsafe.Pointer(outpixels + uintptr(x)*4)) = float32(*(*Int16_t)(unsafe.Pointer(inpixels + uintptr(x)*2))) * mult
		}
	}
}

// plane(x, y) += # of lf_thr[i] s.t. in(x, y) > lf_thr[i]
func j40__add_thresholds16(tls *libc.TLS, plane uintptr, in uintptr, lf_thr uintptr, nb_lf_thr Int32_t) {
	var x Int32_t
	var y Int32_t
	var i Int32_t

	for y = 0; y < (*J40__plane)(unsafe.Pointer(plane)).Height; y++ {
		var inpixels uintptr = func() uintptr {
			return uintptr((*J40__plane)(unsafe.Pointer(in)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(in)).Stride_bytes)*Size_t(y))
		}()
		var pixels uintptr = func() uintptr {
			return uintptr((*J40__plane)(unsafe.Pointer(plane)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(plane)).Stride_bytes)*Size_t(y))
		}()
		for i = 0; i < nb_lf_thr; i++ {
			var threshold Int32_t = *(*Int32_t)(unsafe.Pointer(lf_thr + uintptr(i)*4))
			for x = 0; x < (*J40__plane)(unsafe.Pointer(in)).Width; x++ {
				*(*Uint8_t)(unsafe.Pointer(pixels + uintptr(x))) = Uint8_t(int32(*(*Uint8_t)(unsafe.Pointer(pixels + uintptr(x)))) + libc.Bool32(int32(*(*Int16_t)(unsafe.Pointer(inpixels + uintptr(x)*2))) > threshold))
			}
		}
	}
}

// out(x, y) = in(x, y) * mult (after type conversion)
func j40__dequant_lf32(tls *libc.TLS, in uintptr, mult float32, out uintptr) {
	var x Int32_t
	var y Int32_t

	for y = 0; y < (*J40__plane)(unsafe.Pointer(in)).Height; y++ {
		var inpixels uintptr = func() uintptr {
			return uintptr((*J40__plane)(unsafe.Pointer(in)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(in)).Stride_bytes)*Size_t(y))
		}()
		var outpixels uintptr = func() uintptr {
			return uintptr((*J40__plane)(unsafe.Pointer(out)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(out)).Stride_bytes)*Size_t(y))
		}()
		for x = 0; x < (*J40__plane)(unsafe.Pointer(in)).Width; x++ {
			*(*float32)(unsafe.Pointer(outpixels + uintptr(x)*4)) = float32(*(*Int32_t)(unsafe.Pointer(inpixels + uintptr(x)*4))) * mult
		}
	}
}

// plane(x, y) += # of lf_thr[i] s.t. in(x, y) > lf_thr[i]
func j40__add_thresholds32(tls *libc.TLS, plane uintptr, in uintptr, lf_thr uintptr, nb_lf_thr Int32_t) {
	var x Int32_t
	var y Int32_t
	var i Int32_t

	for y = 0; y < (*J40__plane)(unsafe.Pointer(plane)).Height; y++ {
		var inpixels uintptr = func() uintptr {
			return uintptr((*J40__plane)(unsafe.Pointer(in)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(in)).Stride_bytes)*Size_t(y))
		}()
		var pixels uintptr = func() uintptr {
			return uintptr((*J40__plane)(unsafe.Pointer(plane)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(plane)).Stride_bytes)*Size_t(y))
		}()
		for i = 0; i < nb_lf_thr; i++ {
			var threshold Int32_t = *(*Int32_t)(unsafe.Pointer(lf_thr + uintptr(i)*4))
			for x = 0; x < (*J40__plane)(unsafe.Pointer(in)).Width; x++ {
				*(*Uint8_t)(unsafe.Pointer(pixels + uintptr(x))) = Uint8_t(int32(*(*Uint8_t)(unsafe.Pointer(pixels + uintptr(x)))) + libc.Bool32(*(*Int32_t)(unsafe.Pointer(inpixels + uintptr(x)*4)) > threshold))
			}
		}
	}
}

func J40__dequant_lf(tls *libc.TLS, in uintptr, mult float32, out uintptr) {
	switch int32((*J40__plane)(unsafe.Pointer(in)).Type) {
	case J40__PLANE_I16:
		j40__dequant_lf16(tls, in, mult, out)
		break
	case J40__PLANE_I32:
		j40__dequant_lf32(tls, in, mult, out)
		break
	default:
	}
}

func J40__add_thresholds(tls *libc.TLS, plane uintptr, in uintptr, lf_thr uintptr, nb_lf_thr Int32_t) {
	switch int32((*J40__plane)(unsafe.Pointer(in)).Type) {
	case J40__PLANE_I16:
		j40__add_thresholds16(tls, plane, in, lf_thr, nb_lf_thr)
		return
	case J40__PLANE_I32:
		j40__add_thresholds32(tls, plane, in, lf_thr, nb_lf_thr)
		return
	default:
	}
}

func j40__multiply_each_u8(tls *libc.TLS, plane uintptr, mult Int32_t) {
	var x Int32_t
	var y Int32_t

	for y = 0; y < (*J40__plane)(unsafe.Pointer(plane)).Height; y++ {
		var pixels uintptr = func() uintptr {
			return uintptr((*J40__plane)(unsafe.Pointer(plane)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(plane)).Stride_bytes)*Size_t(y))
		}()
		for x = 0; x < (*J40__plane)(unsafe.Pointer(plane)).Width; x++ {
			*(*Uint8_t)(unsafe.Pointer(pixels + uintptr(x))) = Uint8_t(int32(*(*Uint8_t)(unsafe.Pointer(pixels + uintptr(x)))) * mult)
		}
	}
}

func j40__smooth_lf(tls *libc.TLS, st uintptr, gg uintptr, lfquant uintptr) J40_err {
	bp := tls.Alloc(136)
	defer tls.Free(136)

	var f uintptr
	var ggw8 Int32_t
	var ggh8 Int32_t
	var linebuf uintptr

	var x Int32_t
	var y Int32_t
	var c Int32_t
	var temp uintptr

	var gap float32

	f = (*J40__st)(unsafe.Pointer(st)).Frame
	ggw8 = (*J40__lf_group_st)(unsafe.Pointer(gg)).Width8
	ggh8 = (*J40__lf_group_st)(unsafe.Pointer(gg)).Height8
	linebuf = uintptr(0)

	c = 0
__1:
	if !(c < 3) {
		goto __3
	}

	*(*float32)(unsafe.Pointer(bp + uintptr(c)*4)) = float32((*J40__frame_st)(unsafe.Pointer(f)).Global_scale*(*J40__frame_st)(unsafe.Pointer(f)).Quant_lf) / *(*float32)(unsafe.Pointer(f + 304 + uintptr(c)*4)) / 65536.0
	goto __2
__2:
	c++
	goto __1
	goto __3
__3:
	;
__4:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __7
	}
	goto J40__ON_ERROR
__7:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignUintptr(&linebuf, j40__malloc(tls, uint64(unsafe.Sizeof(float32(0)))*Size_t(ggw8*6)))) != 0)), int64(0)) != 0) {
		goto __8
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__8:
	;
	goto __5
__5:
	if 0 != 0 {
		goto __4
	}
	goto __6
__6:
	;
	c = 0
__9:
	if !(c < 3) {
		goto __11
	}
	*(*uintptr)(unsafe.Pointer(bp + 16 + uintptr(c)*8)) = linebuf + uintptr((c+3)*ggw8)*4
	*(*uintptr)(unsafe.Pointer(bp + 40 + uintptr(c)*8)) = linebuf + uintptr(c*ggw8)*4
	libc.Xmemcpy(tls, *(*uintptr)(unsafe.Pointer(bp + 40 + uintptr(c)*8)), func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(lfquant+uintptr(c)*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(lfquant+uintptr(c)*24)).Stride_bytes)*uint64(0))
	}(), uint64(unsafe.Sizeof(float32(0)))*Size_t(ggw8))
	goto __10
__10:
	c++
	goto __9
	goto __11
__11:
	;
	y = 1
__12:
	if !(y < ggh8-1) {
		goto __14
	}
	c = 0
__15:
	if !(c < 3) {
		goto __17
	}
	temp = *(*uintptr)(unsafe.Pointer(bp + 16 + uintptr(c)*8))
	*(*uintptr)(unsafe.Pointer(bp + 16 + uintptr(c)*8)) = *(*uintptr)(unsafe.Pointer(bp + 40 + uintptr(c)*8))
	*(*uintptr)(unsafe.Pointer(bp + 40 + uintptr(c)*8)) = temp
	*(*uintptr)(unsafe.Pointer(bp + 64 + uintptr(c)*8)) = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(lfquant+uintptr(c)*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(lfquant+uintptr(c)*24)).Stride_bytes)*Size_t(y))
	}()
	*(*uintptr)(unsafe.Pointer(bp + 88 + uintptr(c)*8)) = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(lfquant+uintptr(c)*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(lfquant+uintptr(c)*24)).Stride_bytes)*Size_t(y+1))
	}()
	libc.Xmemcpy(tls, *(*uintptr)(unsafe.Pointer(bp + 40 + uintptr(c)*8)), *(*uintptr)(unsafe.Pointer(bp + 64 + uintptr(c)*8)), uint64(unsafe.Sizeof(float32(0)))*Size_t(ggw8))
	goto __16
__16:
	c++
	goto __15
	goto __17
__17:
	;
	x = 1
__18:
	if !(x < ggw8-1) {
		goto __20
	}
	gap = 0.5
	c = 0
__21:
	if !(c < 3) {
		goto __23
	}
	*(*float32)(unsafe.Pointer(bp + 112 + uintptr(c)*4)) = *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 + uintptr(c)*8)) + uintptr(x-1)*4))*W2 + *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 + uintptr(c)*8)) + uintptr(x)*4))*W1 + *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 + uintptr(c)*8)) + uintptr(x+1)*4))*W2 + (*(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40 + uintptr(c)*8)) + uintptr(x-1)*4))*W1 + *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40 + uintptr(c)*8)) + uintptr(x)*4))*W0 + *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40 + uintptr(c)*8)) + uintptr(x+1)*4))*W1) + (*(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88 + uintptr(c)*8)) + uintptr(x-1)*4))*W2 + *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88 + uintptr(c)*8)) + uintptr(x)*4))*W1 + *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88 + uintptr(c)*8)) + uintptr(x+1)*4))*W2)
	*(*float32)(unsafe.Pointer(bp + 124 + uintptr(c)*4)) = libc.Xfabsf(tls, *(*float32)(unsafe.Pointer(bp + 112 + uintptr(c)*4))-*(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40 + uintptr(c)*8)) + uintptr(x)*4))) * *(*float32)(unsafe.Pointer(bp + uintptr(c)*4))
	if !(gap < *(*float32)(unsafe.Pointer(bp + 124 + uintptr(c)*4))) {
		goto __24
	}
	gap = *(*float32)(unsafe.Pointer(bp + 124 + uintptr(c)*4))
__24:
	;
	goto __22
__22:
	c++
	goto __21
	goto __23
__23:
	;
	gap = J40__maxf(tls, 0.0, 3.0-4.0*gap)

	c = 0
__25:
	if !(c < 3) {
		goto __27
	}
	*(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 64 + uintptr(c)*8)) + uintptr(x)*4)) = (*(*float32)(unsafe.Pointer(bp + 112 + uintptr(c)*4))-*(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40 + uintptr(c)*8)) + uintptr(x)*4)))*gap + *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40 + uintptr(c)*8)) + uintptr(x)*4))
	goto __26
__26:
	c++
	goto __25
	goto __27
__27:
	;
	goto __19
__19:
	x++
	goto __18
	goto __20
__20:
	;
	goto __13
__13:
	y++
	goto __12
	goto __14
__14:
	;
J40__ON_ERROR:
	j40__free(tls, linebuf)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

var W0 float32 = 0.05226273532324128
var W1 float32 = 0.20345139757231578
var W2 float32 = 0.0334829185968739

func j40__lf_quant(tls *libc.TLS, st uintptr, extra_prec Int32_t, m uintptr, gg uintptr, outlfquant uintptr) J40_err {
	bp := tls.Alloc(120)
	defer tls.Free(120)

	var f uintptr
	var ggw8 Int32_t
	var ggh8 Int32_t

	var c Int32_t

	var mult_lf float32
	f = (*J40__st)(unsafe.Pointer(st)).Frame
	ggw8 = (*J40__lf_group_st)(unsafe.Pointer(gg)).Width8
	ggh8 = (*J40__lf_group_st)(unsafe.Pointer(gg)).Height8
	*(*[3]J40__plane)(unsafe.Pointer(bp)) = [3]J40__plane{0: {}}
	*(*J40__plane)(unsafe.Pointer(bp + 72)) = J40__plane{}

	c = 0
__1:
	if !(c < 3) {
		goto __3
	}
__4:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_plane(tls, st, J40__PLANE_F32, ggw8, ggh8, uint32(0), bp+uintptr(c)*24) != 0)), int64(0)) != 0) {
		goto __7
	}
	goto J40__ON_ERROR
__7:
	;
	goto __5
__5:
	if 0 != 0 {
		goto __4
	}
	goto __6
__6:
	;
	goto __2
__2:
	c++
	goto __1
	goto __3
__3:
	;
__8:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_plane(tls, st, J40__PLANE_U8, ggw8, ggh8, J40__PLANE_CLEAR, bp+72) != 0)), int64(0)) != 0) {
		goto __11
	}
	goto J40__ON_ERROR
__11:
	;
	goto __9
__9:
	if 0 != 0 {
		goto __8
	}
	goto __10
__10:
	;
	c = 0
__12:
	if !(c < 3) {
		goto __14
	}

	mult_lf = *(*float32)(unsafe.Pointer(f + 304 + uintptr(c)*4)) / float32((*J40__frame_st)(unsafe.Pointer(f)).Global_scale*(*J40__frame_st)(unsafe.Pointer(f)).Quant_lf) * float32(int32(65536)>>extra_prec)
	*(*uintptr)(unsafe.Pointer(bp + 96 + uintptr(c)*8)) = (*J40__modular)(unsafe.Pointer(m)).Channel + uintptr(YXB2XYB[c])*24
	J40__dequant_lf(tls, *(*uintptr)(unsafe.Pointer(bp + 96 + uintptr(c)*8)), mult_lf, bp+uintptr(c)*24)
	goto __13
__13:
	c++
	goto __12
	goto __14
__14:
	;
	J40__add_thresholds(tls, bp+72, *(*uintptr)(unsafe.Pointer(bp + 96)), f+556, *(*Int32_t)(unsafe.Pointer(f + 796)))
	j40__multiply_each_u8(tls, bp+72, *(*Int32_t)(unsafe.Pointer(f + 796))+1)
	J40__add_thresholds(tls, bp+72, *(*uintptr)(unsafe.Pointer(bp + 96 + 2*8)), f+556+2*60, *(*Int32_t)(unsafe.Pointer(f + 796 + 2*4)))
	j40__multiply_each_u8(tls, bp+72, *(*Int32_t)(unsafe.Pointer(f + 796 + 2*4))+1)
	J40__add_thresholds(tls, bp+72, *(*uintptr)(unsafe.Pointer(bp + 96 + 1*8)), f+556+1*60, *(*Int32_t)(unsafe.Pointer(f + 796 + 1*4)))

	if !!((*J40__frame_st)(unsafe.Pointer(f)).Skip_adapt_lf_smooth != 0) {
		goto __15
	}
__16:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__smooth_lf(tls, st, gg, bp) != 0)), int64(0)) != 0) {
		goto __19
	}
	goto J40__ON_ERROR
__19:
	;
	goto __17
__17:
	if 0 != 0 {
		goto __16
	}
	goto __18
__18:
	;
__15:
	;
	libc.Xmemcpy(tls, outlfquant, bp, uint64(unsafe.Sizeof(J40__plane{}))*uint64(3))
	(*J40__lf_group_st)(unsafe.Pointer(gg)).Lfindices = *(*J40__plane)(unsafe.Pointer(bp + 72))
	return J40_err(0)

J40__ON_ERROR:
	c = 0
__20:
	if !(c < 3) {
		goto __22
	}
	j40__free_plane(tls, bp+uintptr(c)*24)
	goto __21
__21:
	c++
	goto __20
	goto __22
__22:
	;
	j40__free_plane(tls, bp+72)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

var YXB2XYB = [3]Int32_t{1, 0, 2}

func j40__hf_metadata(tls *libc.TLS, st uintptr, nb_varblocks Int32_t, m uintptr, lfquant uintptr, gg uintptr) J40_err {
	bp := tls.Alloc(4192)
	defer tls.Free(4192)

	var f uintptr

	var varblocks uintptr

	var log_gsize8 Int32_t
	var ggw8 Int32_t
	var ggh8 Int32_t
	var voff Int32_t
	var coeffoff Int32_t
	var x0 Int32_t
	var y0 Int32_t
	var x1 Int32_t
	var y1 Int32_t
	var i Int32_t
	var j Int32_t
	var c Int32_t
	var blockinfo0 uintptr
	var blockinfo1 uintptr
	var blockinfo01 uintptr
	var blockinfo11 uintptr
	var blockrow uintptr
	var lfquantrow uintptr
	var llfcoeffs_c uintptr

	var dctsel Int32_t
	var log_vh Int32_t
	var log_vw Int32_t
	var vh8 Int32_t
	var vw8 Int32_t
	var dct uintptr
	f = (*J40__st)(unsafe.Pointer(st)).Frame
	*(*J40__plane)(unsafe.Pointer(bp)) = J40__plane{}
	varblocks = uintptr(0)
	*(*[3]uintptr)(unsafe.Pointer(bp + 48)) = [3]uintptr{0: uintptr(0)}
	*(*[3]uintptr)(unsafe.Pointer(bp + 24)) = [3]uintptr{0: uintptr(0)}
	*(*[3]Size_t)(unsafe.Pointer(bp + 72)) = [3]Size_t{0: uint64(0)}
	log_gsize8 = (*J40__frame_st)(unsafe.Pointer(f)).Group_size_shift - 3
	ggw8 = (*J40__lf_group_st)(unsafe.Pointer(gg)).Width8
	ggh8 = (*J40__lf_group_st)(unsafe.Pointer(gg)).Height8

	(*J40__lf_group_st)(unsafe.Pointer(gg)).Xfromy = *(*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel))
	(*J40__lf_group_st)(unsafe.Pointer(gg)).Bfromy = *(*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel + 1*24))
	(*J40__lf_group_st)(unsafe.Pointer(gg)).Sharpness = *(*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel + 3*24))
	libc.Xmemset(tls, (*J40__modular)(unsafe.Pointer(m)).Channel, 0, uint64(unsafe.Sizeof(J40__plane{})))
	libc.Xmemset(tls, (*J40__modular)(unsafe.Pointer(m)).Channel+1*24, 0, uint64(unsafe.Sizeof(J40__plane{})))
	libc.Xmemset(tls, (*J40__modular)(unsafe.Pointer(m)).Channel+3*24, 0, uint64(unsafe.Sizeof(J40__plane{})))

__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_plane(tls, st, J40__PLANE_I32, ggw8, ggh8, J40__PLANE_CLEAR, bp) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
__5:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __8
	}
	goto J40__ON_ERROR
__8:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignUintptr(&varblocks, j40__malloc(tls, uint64(unsafe.Sizeof(J40__varblock{}))*Size_t(nb_varblocks)))) != 0)), int64(0)) != 0) {
		goto __9
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__9:
	;
	goto __6
__6:
	if 0 != 0 {
		goto __5
	}
	goto __7
__7:
	;
	c = 0
__10:
	if !(c < 3) {
		goto __12
	}
__13:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __16
	}
	goto J40__ON_ERROR
__16:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(bp+24+uintptr(c)*8, j40__malloc(tls, Size_t(ggw8*ggh8)*Size_t(unsafe.Sizeof(float32(0)))))) != 0)), int64(0)) != 0) {
		goto __17
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__17:
	;
	goto __14
__14:
	if 0 != 0 {
		goto __13
	}
	goto __15
__15:
	;
__18:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __21
	}
	goto J40__ON_ERROR
__21:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(bp+48+uintptr(c)*8, J40__alloc_aligned(tls, uint64(unsafe.Sizeof(float32(0)))*Size_t(ggw8*ggh8*64), uint64(J40__COEFFS_ALIGN), bp+72+uintptr(c)*8))) != 0)), int64(0)) != 0) {
		goto __22
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__22:
	;
	goto __19
__19:
	if 0 != 0 {
		goto __18
	}
	goto __20
__20:
	;
	i = 0
__23:
	if !(i < ggw8*ggh8*64) {
		goto __25
	}
	*(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48 + uintptr(c)*8)) + uintptr(i)*4)) = 0.0
	goto __24
__24:
	i++
	goto __23
	goto __25
__25:
	;
	goto __11
__11:
	c++
	goto __10
	goto __12
__12:
	;
	if !(int32((*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel+2*24)).Type) == J40__PLANE_I16) {
		goto __26
	}
	blockinfo0 = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel+2*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel+2*24)).Stride_bytes)*uint64(0))
	}()
	blockinfo1 = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel+2*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel+2*24)).Stride_bytes)*uint64(1))
	}()
	i = 0
__28:
	if !(i < nb_varblocks) {
		goto __30
	}
	(*J40__varblock)(unsafe.Pointer(varblocks + uintptr(i)*8)).Coeffoff_qfidx = Int32_t(*(*Int16_t)(unsafe.Pointer(blockinfo0 + uintptr(i)*2)))
	*(*Int32_t)(unsafe.Pointer(varblocks + uintptr(i)*8 + 4)) = Int32_t(*(*Int16_t)(unsafe.Pointer(blockinfo1 + uintptr(i)*2)))
	goto __29
__29:
	i++
	goto __28
	goto __30
__30:
	;
	goto __27
__26:
	blockinfo01 = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel+2*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel+2*24)).Stride_bytes)*uint64(0))
	}()
	blockinfo11 = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel+2*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer((*J40__modular)(unsafe.Pointer(m)).Channel+2*24)).Stride_bytes)*uint64(1))
	}()
	i = 0
__31:
	if !(i < nb_varblocks) {
		goto __33
	}
	(*J40__varblock)(unsafe.Pointer(varblocks + uintptr(i)*8)).Coeffoff_qfidx = *(*Int32_t)(unsafe.Pointer(blockinfo01 + uintptr(i)*4))
	*(*Int32_t)(unsafe.Pointer(varblocks + uintptr(i)*8 + 4)) = *(*Int32_t)(unsafe.Pointer(blockinfo11 + uintptr(i)*4))
	goto __32
__32:
	i++
	goto __31
	goto __33
__33:
	;
__27:
	;
	voff = libc.AssignInt32(&coeffoff, 0)
	y0 = 0
__34:
	if !(y0 < ggh8) {
		goto __36
	}
	x0 = 0
__37:
	if !(x0 < ggw8) {
		goto __39
	}
	if !(*(*Int32_t)(unsafe.Pointer(func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(bp)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp)).Stride_bytes)*Size_t(y0))
	}() + uintptr(x0)*4)) != 0) {
		goto __40
	}
	goto __38
__40:
	;
__41:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __44
	}
	goto J40__ON_ERROR
__44:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(voff < nb_varblocks)), int64(0)) != 0) {
		goto __45
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 604))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 604 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 604 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 604 + 3))))
	goto J40__ON_ERROR
__45:
	;
	goto __42
__42:
	if 0 != 0 {
		goto __41
	}
	goto __43
__43:
	;
	dctsel = (*J40__varblock)(unsafe.Pointer(varblocks + uintptr(voff)*8)).Coeffoff_qfidx
__46:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __49
	}
	goto J40__ON_ERROR
__49:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(0 <= dctsel && dctsel < J40__NUM_DCT_SELECT)), int64(0)) != 0) {
		goto __50
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 609))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 609 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 609 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 609 + 3))))
	goto J40__ON_ERROR
__50:
	;
	goto __47
__47:
	if 0 != 0 {
		goto __46
	}
	goto __48
__48:
	;
	dct = uintptr(unsafe.Pointer(&sJ40__DCT_SELECT)) + uintptr(dctsel)*4
	*(*Int32_t)(unsafe.Pointer(f + 852)) |= int32(1) << dctsel
	*(*Int32_t)(unsafe.Pointer(f + 860)) |= int32(1) << int32((*J40__dct_select)(unsafe.Pointer(dct)).Order_idx)
	(*J40__varblock)(unsafe.Pointer(varblocks + uintptr(voff)*8)).Coeffoff_qfidx = coeffoff

	log_vh = Int32_t((*J40__dct_select)(unsafe.Pointer(dct)).Log_rows)
	log_vw = Int32_t((*J40__dct_select)(unsafe.Pointer(dct)).Log_columns)

	vw8 = int32(1) << (log_vw - 3)
	vh8 = int32(1) << (log_vh - 3)
	x1 = x0 + vw8 - 1
	y1 = y0 + vh8 - 1

__51:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __54
	}
	goto J40__ON_ERROR
__54:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(x1 < ggw8 && x0>>log_gsize8 == x1>>log_gsize8)), int64(0)) != 0) {
		goto __55
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 604))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 604 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 604 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 604 + 3))))
	goto J40__ON_ERROR
__55:
	;
	goto __52
__52:
	if 0 != 0 {
		goto __51
	}
	goto __53
__53:
	;
__56:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __59
	}
	goto J40__ON_ERROR
__59:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(y1 < ggh8 && y0>>log_gsize8 == y1>>log_gsize8)), int64(0)) != 0) {
		goto __60
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 604))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 604 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 604 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 604 + 3))))
	goto J40__ON_ERROR
__60:
	;
	goto __57
__57:
	if 0 != 0 {
		goto __56
	}
	goto __58
__58:
	;
	i = 0
__61:
	if !(i < vh8) {
		goto __63
	}
	blockrow = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(bp)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp)).Stride_bytes)*Size_t(y0+i))
	}()
	j = 0
__64:
	if !(j < vw8) {
		goto __66
	}
	*(*Int32_t)(unsafe.Pointer(blockrow + uintptr(x0+j)*4)) = int32(1)<<20 | voff
	goto __65
__65:
	j++
	goto __64
	goto __66
__66:
	;
	goto __62
__62:
	i++
	goto __61
	goto __63
__63:
	;
	*(*Int32_t)(unsafe.Pointer(func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(bp)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp)).Stride_bytes)*Size_t(y0))
	}() + uintptr(x0)*4)) = (dctsel+2)<<20 | voff

	if !(log_vw <= 3 && log_vh <= 3) {
		goto __67
	}
	c = 0
__69:
	if !(c < 3) {
		goto __71
	}
	*(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 + uintptr(c)*8)) + uintptr(coeffoff>>6)*4)) = *(*float32)(unsafe.Pointer(func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(lfquant+uintptr(c)*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(lfquant+uintptr(c)*24)).Stride_bytes)*Size_t(y0))
	}() + uintptr(x0)*4))
	goto __70
__70:
	c++
	goto __69
	goto __71
__71:
	;
	goto __68
__67:
	c = 0
__72:
	if !(c < 3) {
		goto __74
	}
	llfcoeffs_c = *(*uintptr)(unsafe.Pointer(bp + 24 + uintptr(c)*8)) + uintptr(coeffoff>>6)*4
	i = 0
__75:
	if !(i < vh8) {
		goto __77
	}
	lfquantrow = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(lfquant+uintptr(c)*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(lfquant+uintptr(c)*24)).Stride_bytes)*Size_t(y0+i))
	}()
	j = 0
__78:
	if !(j < vw8) {
		goto __80
	}
	*(*float32)(unsafe.Pointer(llfcoeffs_c + uintptr(i*vw8+j)*4)) = *(*float32)(unsafe.Pointer(lfquantrow + uintptr(x0+j)*4))
	goto __79
__79:
	j++
	goto __78
	goto __80
__80:
	;
	goto __76
__76:
	i++
	goto __75
	goto __77
__77:
	;
	j40__forward_dct2d_scaled_for_llf(tls, llfcoeffs_c, bp+96, log_vh-3, log_vw-3)
	goto __73
__73:
	c++
	goto __72
	goto __74
__74:
	;
__68:
	;
	coeffoff = coeffoff + int32(1)<<(log_vw+log_vh)
	voff++
	goto __38
__38:
	x0++
	goto __37
	goto __39
__39:
	;
	goto __35
__35:
	y0++
	goto __34
	goto __36
__36:
	;
__81:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __84
	}
	goto J40__ON_ERROR
__84:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(voff == nb_varblocks)), int64(0)) != 0) {
		goto __85
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 604))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 604 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 604 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 604 + 3))))
	goto J40__ON_ERROR
__85:
	;
	goto __82
__82:
	if 0 != 0 {
		goto __81
	}
	goto __83
__83:
	;
	j = 0
__86:
	if !(j < (*J40__frame_st)(unsafe.Pointer(f)).Nb_qf_thr) {
		goto __88
	}
	i = 0
__89:
	if !(i < nb_varblocks) {
		goto __91
	}
	*(*Int32_t)(unsafe.Pointer(varblocks + uintptr(i)*8)) += libc.Bool32(*(*Int32_t)(unsafe.Pointer(varblocks + uintptr(i)*8 + 4)) >= *(*Int32_t)(unsafe.Pointer(f + 736 + uintptr(j)*4)))
	goto __90
__90:
	i++
	goto __89
	goto __91
__91:
	;
	goto __87
__87:
	j++
	goto __86
	goto __88
__88:
	;
	i = 0
__92:
	if !(i < nb_varblocks) {
		goto __94
	}
	*(*float32)(unsafe.Pointer(varblocks + uintptr(i)*8 + 4)) = 1.0 / (float32(*(*Int32_t)(unsafe.Pointer(varblocks + uintptr(i)*8 + 4))) + 1.0)
	goto __93
__93:
	i++
	goto __92
	goto __94
__94:
	;
	(*J40__lf_group_st)(unsafe.Pointer(gg)).Nb_varblocks = nb_varblocks
	(*J40__lf_group_st)(unsafe.Pointer(gg)).Blocks = *(*J40__plane)(unsafe.Pointer(bp))
	(*J40__lf_group_st)(unsafe.Pointer(gg)).Varblocks = varblocks
	c = 0
__95:
	if !(c < 3) {
		goto __97
	}
	*(*uintptr)(unsafe.Pointer(gg + 184 + uintptr(c)*8)) = *(*uintptr)(unsafe.Pointer(bp + 24 + uintptr(c)*8))
	*(*uintptr)(unsafe.Pointer(gg + 208 + uintptr(c)*8)) = *(*uintptr)(unsafe.Pointer(bp + 48 + uintptr(c)*8))
	*(*Uint8_t)(unsafe.Pointer(gg + 232 + uintptr(c))) = Uint8_t(*(*Size_t)(unsafe.Pointer(bp + 72 + uintptr(c)*8)))
	goto __96
__96:
	c++
	goto __95
	goto __97
__97:
	;
	return J40_err(0)

J40__ON_ERROR:
	j40__free_plane(tls, bp)
	j40__free(tls, varblocks)
	c = 0
__98:
	if !(c < 3) {
		goto __100
	}
	J40__free_aligned(tls, *(*uintptr)(unsafe.Pointer(bp + 48 + uintptr(c)*8)), uint64(J40__COEFFS_ALIGN), *(*Size_t)(unsafe.Pointer(bp + 72 + uintptr(c)*8)))
	j40__free(tls, *(*uintptr)(unsafe.Pointer(bp + 24 + uintptr(c)*8)))
	goto __99
__99:
	c++
	goto __98
	goto __100
__100:
	;
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__lf_group(tls *libc.TLS, st uintptr, gg uintptr) J40_err {
	bp := tls.Alloc(264)
	defer tls.Free(264)

	var f uintptr
	var ggidx Int64_t
	var sidx0 Int64_t
	var sidx1 Int64_t
	_ = sidx1
	var sidx2 Int64_t

	var i Int32_t
	var c Int32_t
	var c1 uintptr
	var extra_prec Int32_t
	var ggw8 Int32_t
	var ggh8 Int32_t
	var ggw64 Int32_t
	var ggh64 Int32_t

	var nb_varblocks Int32_t
	f = (*J40__st)(unsafe.Pointer(st)).Frame
	ggidx = (*J40__lf_group_st)(unsafe.Pointer(gg)).Idx
	sidx0 = int64(1) + ggidx
	sidx1 = int64(1) + (*J40__frame_st)(unsafe.Pointer(f)).Num_lf_groups + ggidx
	sidx2 = int64(1) + int64(2)*(*J40__frame_st)(unsafe.Pointer(f)).Num_lf_groups + ggidx
	*(*[3]J40__plane)(unsafe.Pointer(bp + 192)) = [3]J40__plane{0: {}}
	*(*J40__modular)(unsafe.Pointer(bp + 32)) = J40__modular{}

	i = (*J40__frame_st)(unsafe.Pointer(f)).Num_gm_channels
__1:
	if !(i < (*J40__frame_st)(unsafe.Pointer(f)).Gmodular.Num_channels) {
		goto __3
	}
	c1 = (*J40__frame_st)(unsafe.Pointer(f)).Gmodular.Channel + uintptr(i)*24
	if !(int32((*J40__plane)(unsafe.Pointer(c1)).Hshift) >= 3 && int32((*J40__plane)(unsafe.Pointer(c1)).Vshift) >= 3) {
		goto __4
	}
	_ = sidx1
__5:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 614))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 614 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 614 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 614 + 3))))
	goto J40__ON_ERROR
	goto __6
__6:
	if 0 != 0 {
		goto __5
	}
	goto __7
__7:
	;
__4:
	;
	goto __2
__2:
	i++
	goto __1
	goto __3
__3:
	;
	if !!((*J40__frame_st)(unsafe.Pointer(f)).Is_modular != 0) {
		goto __8
	}
	ggw8 = (*J40__lf_group_st)(unsafe.Pointer(gg)).Width8
	ggh8 = (*J40__lf_group_st)(unsafe.Pointer(gg)).Height8
	ggw64 = (*J40__lf_group_st)(unsafe.Pointer(gg)).Width64
	ggh64 = (*J40__lf_group_st)(unsafe.Pointer(gg)).Height64

	if !!((*J40__frame_st)(unsafe.Pointer(f)).Use_lf_frame != 0) {
		goto __9
	}
	extra_prec = j40__u(tls, st, 2)
__11:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __14
	}
	goto J40__ON_ERROR
__14:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__frame_st)(unsafe.Pointer(f)).Jpeg_upsampling == 0)), int64(0)) != 0) {
		goto __15
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 665))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 665 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 665 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 665 + 3))))
	goto J40__ON_ERROR
__15:
	;
	goto __12
__12:
	if 0 != 0 {
		goto __11
	}
	goto __13
__13:
	;
	*(*Int32_t)(unsafe.Pointer(bp)) = libc.AssignPtrInt32(bp+1*4, libc.AssignPtrInt32(bp+2*4, ggw8))
	*(*Int32_t)(unsafe.Pointer(bp + 16)) = libc.AssignPtrInt32(bp+16+1*4, libc.AssignPtrInt32(bp+16+2*4, ggh8))
__16:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_modular(tls, st, 3, bp, bp+16, bp+32) != 0)), int64(0)) != 0) {
		goto __19
	}
	goto J40__ON_ERROR
__19:
	;
	goto __17
__17:
	if 0 != 0 {
		goto __16
	}
	goto __18
__18:
	;
__20:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__modular_header(tls, st, (*J40__frame_st)(unsafe.Pointer(f)).Global_tree, f+328, bp+32) != 0)), int64(0)) != 0) {
		goto __23
	}
	goto J40__ON_ERROR
__23:
	;
	goto __21
__21:
	if 0 != 0 {
		goto __20
	}
	goto __22
__22:
	;
__24:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__allocate_modular(tls, st, bp+32) != 0)), int64(0)) != 0) {
		goto __27
	}
	goto J40__ON_ERROR
__27:
	;
	goto __25
__25:
	if 0 != 0 {
		goto __24
	}
	goto __26
__26:
	;
	c = 0
__28:
	if !(c < 3) {
		goto __30
	}
__31:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__modular_channel(tls, st, bp+32, c, sidx0) != 0)), int64(0)) != 0) {
		goto __34
	}
	goto J40__ON_ERROR
__34:
	;
	goto __32
__32:
	if 0 != 0 {
		goto __31
	}
	goto __33
__33:
	;
	goto __29
__29:
	c++
	goto __28
	goto __30
__30:
	;
__35:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__finish_and_free_code(tls, st, bp+32+96) != 0)), int64(0)) != 0) {
		goto __38
	}
	goto J40__ON_ERROR
__38:
	;
	goto __36
__36:
	if 0 != 0 {
		goto __35
	}
	goto __37
__37:
	;
__39:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__inverse_transform(tls, st, bp+32) != 0)), int64(0)) != 0) {
		goto __42
	}
	goto J40__ON_ERROR
__42:
	;
	goto __40
__40:
	if 0 != 0 {
		goto __39
	}
	goto __41
__41:
	;
__43:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__lf_quant(tls, st, extra_prec, bp+32, gg, bp+192) != 0)), int64(0)) != 0) {
		goto __46
	}
	goto J40__ON_ERROR
__46:
	;
	goto __44
__44:
	if 0 != 0 {
		goto __43
	}
	goto __45
__45:
	;
	j40__free_modular(tls, bp+32)
	goto __10
__9:
__47:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 711))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 711 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 711 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 711 + 3))))
	goto J40__ON_ERROR
	goto __48
__48:
	if 0 != 0 {
		goto __47
	}
	goto __49
__49:
	;
__10:
	;
	nb_varblocks = j40__u(tls, st, J40__ceil_lg32(tls, Uint32_t(ggw8*ggh8))) + 1
	*(*Int32_t)(unsafe.Pointer(bp)) = libc.AssignPtrInt32(bp+1*4, ggw64)
	*(*Int32_t)(unsafe.Pointer(bp + 16)) = libc.AssignPtrInt32(bp+16+1*4, ggh64)
	*(*Int32_t)(unsafe.Pointer(bp + 2*4)) = nb_varblocks
	*(*Int32_t)(unsafe.Pointer(bp + 16 + 2*4)) = 2
	*(*Int32_t)(unsafe.Pointer(bp + 3*4)) = ggw8
	*(*Int32_t)(unsafe.Pointer(bp + 16 + 3*4)) = ggh8
__50:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_modular(tls, st, 4, bp, bp+16, bp+32) != 0)), int64(0)) != 0) {
		goto __53
	}
	goto J40__ON_ERROR
__53:
	;
	goto __51
__51:
	if 0 != 0 {
		goto __50
	}
	goto __52
__52:
	;
__54:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__modular_header(tls, st, (*J40__frame_st)(unsafe.Pointer(f)).Global_tree, f+328, bp+32) != 0)), int64(0)) != 0) {
		goto __57
	}
	goto J40__ON_ERROR
__57:
	;
	goto __55
__55:
	if 0 != 0 {
		goto __54
	}
	goto __56
__56:
	;
__58:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__allocate_modular(tls, st, bp+32) != 0)), int64(0)) != 0) {
		goto __61
	}
	goto J40__ON_ERROR
__61:
	;
	goto __59
__59:
	if 0 != 0 {
		goto __58
	}
	goto __60
__60:
	;
	i = 0
__62:
	if !(i < 4) {
		goto __64
	}
__65:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__modular_channel(tls, st, bp+32, i, sidx2) != 0)), int64(0)) != 0) {
		goto __68
	}
	goto J40__ON_ERROR
__68:
	;
	goto __66
__66:
	if 0 != 0 {
		goto __65
	}
	goto __67
__67:
	;
	goto __63
__63:
	i++
	goto __62
	goto __64
__64:
	;
__69:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__finish_and_free_code(tls, st, bp+32+96) != 0)), int64(0)) != 0) {
		goto __72
	}
	goto J40__ON_ERROR
__72:
	;
	goto __70
__70:
	if 0 != 0 {
		goto __69
	}
	goto __71
__71:
	;
__73:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__inverse_transform(tls, st, bp+32) != 0)), int64(0)) != 0) {
		goto __76
	}
	goto J40__ON_ERROR
__76:
	;
	goto __74
__74:
	if 0 != 0 {
		goto __73
	}
	goto __75
__75:
	;
__77:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__hf_metadata(tls, st, nb_varblocks, bp+32, bp+192, gg) != 0)), int64(0)) != 0) {
		goto __80
	}
	goto J40__ON_ERROR
__80:
	;
	goto __78
__78:
	if 0 != 0 {
		goto __77
	}
	goto __79
__79:
	;
	j40__free_modular(tls, bp+32)
	i = 0
__81:
	if !(i < 3) {
		goto __83
	}
	j40__free_plane(tls, bp+192+uintptr(i)*24)
	goto __82
__82:
	i++
	goto __81
	goto __83
__83:
	;
__8:
	;
	return J40_err(0)

J40__ON_ERROR:
	j40__free_modular(tls, bp+32)
	i = 0
__84:
	if !(i < 3) {
		goto __86
	}
	j40__free_plane(tls, bp+192+uintptr(i)*24)
	goto __85
__85:
	i++
	goto __84
	goto __86
__86:
	;
	if !(gg != 0) {
		goto __87
	}
	j40__free_lf_group(tls, gg)
__87:
	;
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__free_lf_group(tls *libc.TLS, gg uintptr) {
	var i Int32_t
	for i = 0; i < 3; i++ {
		j40__free(tls, *(*uintptr)(unsafe.Pointer(gg + 184 + uintptr(i)*8)))
		J40__free_aligned(tls, *(*uintptr)(unsafe.Pointer(gg + 208 + uintptr(i)*8)), uint64(J40__COEFFS_ALIGN), uint64(*(*Uint8_t)(unsafe.Pointer(gg + 232 + uintptr(i)))))
		*(*uintptr)(unsafe.Pointer(gg + 184 + uintptr(i)*8)) = uintptr(0)
		*(*uintptr)(unsafe.Pointer(gg + 208 + uintptr(i)*8)) = uintptr(0)
	}
	j40__free_plane(tls, gg+72)
	j40__free_plane(tls, gg+96)
	j40__free_plane(tls, gg+120)
	j40__free_plane(tls, gg+152)
	j40__free_plane(tls, gg+240)
	j40__free(tls, (*J40__lf_group_st)(unsafe.Pointer(gg)).Varblocks)
	(*J40__lf_group_st)(unsafe.Pointer(gg)).Varblocks = uintptr(0)
}

// reads both HfGlobal and HfPass (SPEC they form a single group)
func j40__hf_global(tls *libc.TLS, st uintptr) J40_err {
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var f uintptr
	var sidx_base Int64_t

	var i Int32_t
	var j Int32_t
	var c Int32_t
	var dct J40__dct_params
	var rows Int32_t
	var columns Int32_t
	var size Int32_t
	var used_orders Int32_t
	f = (*J40__st)(unsafe.Pointer(st)).Frame
	sidx_base = int64(1) + int64(3)*(*J40__frame_st)(unsafe.Pointer(f)).Num_lf_groups
	*(*J40__code_spec)(unsafe.Pointer(bp)) = J40__code_spec{}
	*(*J40__code_st)(unsafe.Pointer(bp + 56)) = J40__code_st{Spec: bp}

	if !!(j40__u(tls, st, 1) != 0) {
		goto __1
	}

	i = 0
__2:
	if !(i < J40__NUM_DCT_PARAMS) {
		goto __4
	}
	dct = sJ40__DCT_PARAMS[i]
	rows = int32(1) << Int32_t(dct.Log_rows)
	columns = int32(1) << Int32_t(dct.Log_columns)
__5:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__read_dq_matrix(tls, st, rows, columns, sidx_base+Int64_t(i), (*J40__frame_st)(unsafe.Pointer(f)).Global_tree, f+328, f+872+uintptr(i)*16) != 0)), int64(0)) != 0) {
		goto __8
	}
	goto J40__ON_ERROR
__8:
	;
	goto __6
__6:
	if 0 != 0 {
		goto __5
	}
	goto __7
__7:
	;
	goto __3
__3:
	i++
	goto __2
	goto __4
__4:
	;
__1:
	;
	(*J40__frame_st)(unsafe.Pointer(f)).Num_hf_presets = j40__u(tls, st, J40__ceil_lg32(tls, Uint32_t((*J40__frame_st)(unsafe.Pointer(f)).Num_groups))) + 1
__9:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __12
	}
	goto J40__ON_ERROR
__12:
	;
	goto __10
__10:
	if 0 != 0 {
		goto __9
	}
	goto __11
__11:
	;
	i = 0
__13:
	if !(i < (*J40__frame_st)(unsafe.Pointer(f)).Num_passes) {
		goto __15
	}
	used_orders = j40__u32(tls, st, 0x5f, 0, 0x13, 0, 0, 0, 0, 13)
	if !(used_orders > 0) {
		goto __16
	}
__17:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__read_code_spec(tls, st, 8, bp) != 0)), int64(0)) != 0) {
		goto __20
	}
	goto J40__ON_ERROR
__20:
	;
	goto __18
__18:
	if 0 != 0 {
		goto __17
	}
	goto __19
__19:
	;
__16:
	;
	j = 0
__21:
	if !(j < J40__NUM_ORDERS) {
		goto __23
	}
	if !(used_orders>>j&1 != 0) {
		goto __24
	}
	size = int32(1) << (int32(*(*Int8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&sJ40__LOG_ORDER_SIZE)) + uintptr(j)*2))) + int32(*(*Int8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&sJ40__LOG_ORDER_SIZE)) + uintptr(j)*2 + 1))))
	c = 0
__25:
	if !(c < 3) {
		goto __27
	}
__28:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__permutation(tls, st, bp+56, size, size/64, f+1152+uintptr(i)*312+uintptr(j)*24+uintptr(c)*8) != 0)), int64(0)) != 0) {
		goto __31
	}
	goto J40__ON_ERROR
__31:
	;
	goto __29
__29:
	if 0 != 0 {
		goto __28
	}
	goto __30
__30:
	;
	goto __26
__26:
	c++
	goto __25
	goto __27
__27:
	;
__24:
	;
	goto __22
__22:
	j++
	goto __21
	goto __23
__23:
	;
	if !(used_orders > 0) {
		goto __32
	}
__33:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__finish_and_free_code(tls, st, bp+56) != 0)), int64(0)) != 0) {
		goto __36
	}
	goto J40__ON_ERROR
__36:
	;
	goto __34
__34:
	if 0 != 0 {
		goto __33
	}
	goto __35
__35:
	;
	j40__free_code_spec(tls, bp)
__32:
	;
__37:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__read_code_spec(tls, st, 495*(*J40__frame_st)(unsafe.Pointer(f)).Nb_block_ctx*(*J40__frame_st)(unsafe.Pointer(f)).Num_hf_presets, f+4584+uintptr(i)*56) != 0)), int64(0)) != 0) {
		goto __40
	}
	goto J40__ON_ERROR
__40:
	;
	goto __38
__38:
	if 0 != 0 {
		goto __37
	}
	goto __39
__39:
	;
	goto __14
__14:
	i++
	goto __13
	goto __15
__15:
	;
J40__ON_ERROR:
	j40__free_code(tls, bp+56)
	j40__free_code_spec(tls, bp)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__hf_coeffs(tls *libc.TLS, st uintptr, ctxoff Int32_t, pass Int32_t, gx_in_gg Int32_t, gy_in_gg Int32_t, gw Int32_t, gh Int32_t, gg uintptr) J40_err {
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var f uintptr
	var gw8 Int32_t
	var gh8 Int32_t
	var nonzeros uintptr

	var lfidx_size Int32_t
	var x8 Int32_t
	var y8 Int32_t
	var i Int32_t
	var j Int32_t
	var c_yxb Int32_t
	var ctx Int32_t

	var ucoeff Int32_t
	var c Int32_t
	var coeffs uintptr
	var order uintptr
	var bctx Int32_t
	var nz Int32_t
	var nzctx Int32_t
	var cctx Int32_t
	var qnz Int32_t
	var prev Int32_t
	var dct uintptr

	var ggx8 Int32_t
	var ggy8 Int32_t
	var nzpos Int32_t
	var voff Int32_t
	var dctsel Int32_t
	var log_rows Int32_t
	var log_columns Int32_t
	var log_size Int32_t
	var coeffoff Int32_t
	var qfidx Int32_t
	var lfidx Int32_t
	var bctx0 Int32_t
	var bctxc Int32_t
	f = (*J40__st)(unsafe.Pointer(st)).Frame
	gw8 = J40__ceil_div32(tls, gw, 8)
	gh8 = J40__ceil_div32(tls, gh, 8)
	nonzeros = uintptr(0)
	*(*J40__code_st)(unsafe.Pointer(bp)) = J40__code_st{Spec: f + 4584 + uintptr(pass)*56}
	lfidx_size = (*(*Int32_t)(unsafe.Pointer(f + 796)) + 1) * (*(*Int32_t)(unsafe.Pointer(f + 796 + 1*4)) + 1) * (*(*Int32_t)(unsafe.Pointer(f + 796 + 2*4)) + 1)

__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignUintptr(&nonzeros, j40__malloc(tls, uint64(3)*Size_t(gw8*gh8)))) != 0)), int64(0)) != 0) {
		goto __5
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__5:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
	y8 = 0
__6:
	if !(y8 < gh8) {
		goto __8
	}
	x8 = 0
__9:
	if !(x8 < gw8) {
		goto __11
	}

	ggx8 = x8 + gx_in_gg/8
	ggy8 = y8 + gy_in_gg/8
	nzpos = y8*gw8 + x8
	voff = *(*Int32_t)(unsafe.Pointer(func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(gg+152)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(gg+152)).Stride_bytes)*Size_t(ggy8))
	}() + uintptr(ggx8)*4))
	dctsel = voff >> 20

	if !(dctsel < 2) {
		goto __12
	}
	goto __10
__12:
	;
	dctsel = dctsel - 2
	voff = voff & 0xfffff

	dct = uintptr(unsafe.Pointer(&sJ40__DCT_SELECT)) + uintptr(dctsel)*4
	log_rows = Int32_t((*J40__dct_select)(unsafe.Pointer(dct)).Log_rows)
	log_columns = Int32_t((*J40__dct_select)(unsafe.Pointer(dct)).Log_columns)
	log_size = log_rows + log_columns

	coeffoff = (*J40__varblock)(unsafe.Pointer((*J40__lf_group_st)(unsafe.Pointer(gg)).Varblocks+uintptr(voff)*8)).Coeffoff_qfidx & libc.CplInt32(15)
	qfidx = (*J40__varblock)(unsafe.Pointer((*J40__lf_group_st)(unsafe.Pointer(gg)).Varblocks+uintptr(voff)*8)).Coeffoff_qfidx & 15

	lfidx = Int32_t(*(*Uint8_t)(unsafe.Pointer(func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(gg+240)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(gg+240)).Stride_bytes)*Size_t(ggy8))
	}() + uintptr(ggx8))))
	bctx0 = (int32((*J40__dct_select)(unsafe.Pointer(dct)).Order_idx)*((*J40__frame_st)(unsafe.Pointer(f)).Nb_qf_thr+1)+qfidx)*lfidx_size + lfidx
	bctxc = 13 * ((*J40__frame_st)(unsafe.Pointer(f)).Nb_qf_thr + 1) * lfidx_size

	c_yxb = 0
__13:
	if !(c_yxb < 3) {
		goto __15
	}

	c = YXB2XYB1[c_yxb]
	coeffs = *(*uintptr)(unsafe.Pointer(gg + 208 + uintptr(c)*8)) + uintptr(coeffoff)*4
	order = *(*uintptr)(unsafe.Pointer(f + 1152 + uintptr(pass)*312 + uintptr((*J40__dct_select)(unsafe.Pointer(dct)).Order_idx)*24 + uintptr(c)*8))
	bctx = Int32_t(*(*Uint8_t)(unsafe.Pointer((*J40__frame_st)(unsafe.Pointer(f)).Block_ctx_map + uintptr(bctx0+bctxc*c_yxb))))

	if x8 > 0 {
		nz = func() int32 {
			if y8 > 0 {
				return (int32(*(*Int8_t)(unsafe.Pointer(nonzeros + uintptr(nzpos-1)*3 + uintptr(c)))) + int32(*(*Int8_t)(unsafe.Pointer(nonzeros + uintptr(nzpos-gw8)*3 + uintptr(c)))) + 1) >> 1
			}
			return int32(*(*Int8_t)(unsafe.Pointer(nonzeros + uintptr(nzpos-1)*3 + uintptr(c))))
		}()
	} else {
		nz = func() int32 {
			if y8 > 0 {
				return int32(*(*Int8_t)(unsafe.Pointer(nonzeros + uintptr(nzpos-gw8)*3 + uintptr(c))))
			}
			return 32
		}()
	}

	nzctx = ctxoff + bctx + func() int32 {
		if nz < 8 {
			return nz
		}
		return 4 + nz/2
	}()*(*J40__frame_st)(unsafe.Pointer(f)).Nb_block_ctx
	nz = j40__code(tls, st, nzctx, 0, bp)

__16:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __19
	}
	goto J40__ON_ERROR
__19:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(nz <= int32(63)<<(log_size-6))), int64(0)) != 0) {
		goto __20
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 760))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 760 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 760 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 760 + 3))))
	goto J40__ON_ERROR
__20:
	;
	goto __17
__17:
	if 0 != 0 {
		goto __16
	}
	goto __18
__18:
	;
	qnz = J40__ceil_div32(tls, nz, int32(1)<<(log_size-6))
	i = 0
__21:
	if !(i < int32(1)<<(log_rows-3)) {
		goto __23
	}
	j = 0
__24:
	if !(j < int32(1)<<(log_columns-3)) {
		goto __26
	}
	*(*Int8_t)(unsafe.Pointer(nonzeros + uintptr(nzpos+i*gw8+j)*3 + uintptr(c))) = Int8_t(qnz)
	goto __25
__25:
	j++
	goto __24
	goto __26
__26:
	;
	goto __22
__22:
	i++
	goto __21
	goto __23
__23:
	;
	cctx = ctxoff + 458*bctx + 37*(*J40__frame_st)(unsafe.Pointer(f)).Nb_block_ctx

	prev = libc.Bool32(nz <= int32(1)<<(log_size-4))

	i = int32(1) << (log_size - 6)
__27:
	if !(nz > 0 && i < int32(1)<<log_size) {
		goto __29
	}
	ctx = cctx + Int32_t(TWICE_COEFF_NNZ_CTX[J40__ceil_div32(tls, nz, int32(1)<<(log_size-6))]) + Int32_t(TWICE_COEFF_FREQ_CTX[i>>(log_size-6)]) + prev

	ucoeff = j40__code(tls, st, ctx, 0, bp)

	*(*float32)(unsafe.Pointer(coeffs + uintptr(*(*Int32_t)(unsafe.Pointer(order + uintptr(i)*4)))*4)) += float32(J40__unpack_signed(tls, ucoeff))

	nz = nz - libc.AssignInt32(&prev, libc.Bool32(ucoeff != 0))
	goto __28
__28:
	i++
	goto __27
	goto __29
__29:
	;
__30:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __33
	}
	goto J40__ON_ERROR
__33:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(nz == 0)), int64(0)) != 0) {
		goto __34
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 760))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 760 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 760 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 760 + 3))))
	goto J40__ON_ERROR
__34:
	;
	goto __31
__31:
	if 0 != 0 {
		goto __30
	}
	goto __32
__32:
	;
	goto __14
__14:
	c_yxb++
	goto __13
	goto __15
__15:
	;
	goto __10
__10:
	x8++
	goto __9
	goto __11
__11:
	;
	goto __7
__7:
	y8++
	goto __6
	goto __8
__8:
	;
__35:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__finish_and_free_code(tls, st, bp) != 0)), int64(0)) != 0) {
		goto __38
	}
	goto J40__ON_ERROR
__38:
	;
	goto __36
__36:
	if 0 != 0 {
		goto __35
	}
	goto __37
__37:
	;
	j40__free(tls, nonzeros)
	return J40_err(0)

J40__ON_ERROR:
	j40__free_code(tls, bp)
	j40__free(tls, nonzeros)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

var YXB2XYB1 = [3]Int32_t{1, 0, 2}
var TWICE_COEFF_FREQ_CTX = [64]Int8_t{
	int8(-1), int8(0), int8(2), int8(4), int8(6), int8(8), int8(10), int8(12), int8(14), int8(16), int8(18), int8(20), int8(22), int8(24), int8(26), int8(28),
	int8(30), int8(30), int8(32), int8(32), int8(34), int8(34), int8(36), int8(36), int8(38), int8(38), int8(40), int8(40), int8(42), int8(42), int8(44), int8(44),
	int8(46), int8(46), int8(46), int8(46), int8(48), int8(48), int8(48), int8(48), int8(50), int8(50), int8(50), int8(50), int8(52), int8(52), int8(52), int8(52),
	int8(54), int8(54), int8(54), int8(54), int8(56), int8(56), int8(56), int8(56), int8(58), int8(58), int8(58), int8(58), int8(60), int8(60), int8(60), int8(60),
}
var TWICE_COEFF_NNZ_CTX = [64]Int16_t{
	int16(0), int16(0), int16(62), int16(124), int16(124), int16(186), int16(186), int16(186), int16(186), int16(246), int16(246), int16(246), int16(246), int16(304), int16(304), int16(304),
	int16(304), int16(304), int16(304), int16(304), int16(304), int16(360), int16(360), int16(360), int16(360), int16(360), int16(360), int16(360), int16(360), int16(360), int16(360), int16(360),
	int16(360), int16(412), int16(412), int16(412), int16(412), int16(412), int16(412), int16(412), int16(412), int16(412), int16(412), int16(412), int16(412), int16(412), int16(412), int16(412),
	int16(412), int16(412), int16(412), int16(412), int16(412), int16(412), int16(412), int16(412), int16(412), int16(412), int16(412), int16(412), int16(412), int16(412), int16(412), int16(412),
}

func j40__pass_group(tls *libc.TLS, st uintptr, pass Int32_t, gx_in_gg Int32_t, gy_in_gg Int32_t, gw Int32_t, gh Int32_t, gidx Int64_t, gg uintptr) J40_err {
	bp := tls.Alloc(160)
	defer tls.Free(160)

	var f uintptr

	var sidx Int64_t

	var i Int32_t
	var ctxoff Int32_t
	f = (*J40__st)(unsafe.Pointer(st)).Frame
	sidx = int64(1) + int64(3)*(*J40__frame_st)(unsafe.Pointer(f)).Num_lf_groups + J40__NUM_DCT_PARAMS + Int64_t(pass)*(*J40__frame_st)(unsafe.Pointer(f)).Num_groups + gidx
	*(*J40__modular)(unsafe.Pointer(bp)) = J40__modular{}

	if !!((*J40__frame_st)(unsafe.Pointer(f)).Is_modular != 0) {
		goto __1
	}

	ctxoff = 495 * (*J40__frame_st)(unsafe.Pointer(f)).Nb_block_ctx * j40__u(tls, st, J40__ceil_lg32(tls, Uint32_t((*J40__frame_st)(unsafe.Pointer(f)).Num_hf_presets)))
__2:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__hf_coeffs(tls, st, ctxoff, pass, gx_in_gg, gy_in_gg, gw, gh, gg) != 0)), int64(0)) != 0) {
		goto __5
	}
	goto J40__ON_ERROR
__5:
	;
	goto __3
__3:
	if 0 != 0 {
		goto __2
	}
	goto __4
__4:
	;
__1:
	;
__6:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_modular_for_pass_group(tls, st, (*J40__frame_st)(unsafe.Pointer(f)).Num_gm_channels, gw, gh, 0, 3, f+384, bp) != 0)), int64(0)) != 0) {
		goto __9
	}
	goto J40__ON_ERROR
__9:
	;
	goto __7
__7:
	if 0 != 0 {
		goto __6
	}
	goto __8
__8:
	;
	if !((*J40__modular)(unsafe.Pointer(bp)).Num_channels > 0) {
		goto __10
	}
__11:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__modular_header(tls, st, (*J40__frame_st)(unsafe.Pointer(f)).Global_tree, f+328, bp) != 0)), int64(0)) != 0) {
		goto __14
	}
	goto J40__ON_ERROR
__14:
	;
	goto __12
__12:
	if 0 != 0 {
		goto __11
	}
	goto __13
__13:
	;
__15:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__allocate_modular(tls, st, bp) != 0)), int64(0)) != 0) {
		goto __18
	}
	goto J40__ON_ERROR
__18:
	;
	goto __16
__16:
	if 0 != 0 {
		goto __15
	}
	goto __17
__17:
	;
	i = 0
__19:
	if !(i < (*J40__modular)(unsafe.Pointer(bp)).Num_channels) {
		goto __21
	}
__22:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__modular_channel(tls, st, bp, i, sidx) != 0)), int64(0)) != 0) {
		goto __25
	}
	goto J40__ON_ERROR
__25:
	;
	goto __23
__23:
	if 0 != 0 {
		goto __22
	}
	goto __24
__24:
	;
	goto __20
__20:
	i++
	goto __19
	goto __21
__21:
	;
__26:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__finish_and_free_code(tls, st, bp+96) != 0)), int64(0)) != 0) {
		goto __29
	}
	goto J40__ON_ERROR
__29:
	;
	goto __27
__27:
	if 0 != 0 {
		goto __26
	}
	goto __28
__28:
	;
__30:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__inverse_transform(tls, st, bp) != 0)), int64(0)) != 0) {
		goto __33
	}
	goto J40__ON_ERROR
__33:
	;
	goto __31
__31:
	if 0 != 0 {
		goto __30
	}
	goto __32
__32:
	;
	j40__combine_modular_from_pass_group(tls, (*J40__frame_st)(unsafe.Pointer(f)).Num_gm_channels,
		(*J40__lf_group_st)(unsafe.Pointer(gg)).Top+gy_in_gg, (*J40__lf_group_st)(unsafe.Pointer(gg)).Left+gx_in_gg, 0, 3, f+384, bp)
	j40__free_modular(tls, bp)
__10:
	;
	return J40_err(0)

J40__ON_ERROR:
	j40__free_modular(tls, bp)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__dequant_hf(tls *libc.TLS, st uintptr, gg uintptr) {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var f uintptr = (*J40__st)(unsafe.Pointer(st)).Frame
	var ggw8 Int32_t = (*J40__lf_group_st)(unsafe.Pointer(gg)).Width8
	var ggh8 Int32_t = (*J40__lf_group_st)(unsafe.Pointer(gg)).Height8
	var x_qm_scale float32
	var b_qm_scale float32
	var quant_bias_num float32 = (*J40__image_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Image)).Quant_bias_num
	var quant_bias uintptr = (*J40__st)(unsafe.Pointer(st)).Image + 196
	var x8 Int32_t
	var y8 Int32_t
	var c Int32_t
	var i Int32_t

	x_qm_scale = QM_SCALE[(*J40__frame_st)(unsafe.Pointer(f)).X_qm_scale]
	b_qm_scale = QM_SCALE[(*J40__frame_st)(unsafe.Pointer(f)).B_qm_scale]

	for y8 = 0; y8 < ggh8; y8++ {
		for x8 = 0; x8 < ggw8; x8++ {
			var dct uintptr
			var dqmat uintptr
			var voff Int32_t = *(*Int32_t)(unsafe.Pointer(func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(gg+152)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(gg+152)).Stride_bytes)*Size_t(y8))
			}() + uintptr(x8)*4))
			var dctsel Int32_t = voff >> 20
			var size Int32_t

			if dctsel < 2 {
				continue
			}
			voff = voff & 0xfffff
			dct = uintptr(unsafe.Pointer(&sJ40__DCT_SELECT)) + uintptr(dctsel-2)*4
			size = int32(1) << (int32((*J40__dct_select)(unsafe.Pointer(dct)).Log_rows) + int32((*J40__dct_select)(unsafe.Pointer(dct)).Log_columns))

			*(*float32)(unsafe.Pointer(bp + 1*4)) = 65536.0 / float32((*J40__frame_st)(unsafe.Pointer(f)).Global_scale) * *(*float32)(unsafe.Pointer((*J40__lf_group_st)(unsafe.Pointer(gg)).Varblocks + uintptr(voff)*8 + 4))
			*(*float32)(unsafe.Pointer(bp)) = *(*float32)(unsafe.Pointer(bp + 1*4)) * x_qm_scale
			*(*float32)(unsafe.Pointer(bp + 2*4)) = *(*float32)(unsafe.Pointer(bp + 1*4)) * b_qm_scale
			dqmat = f + 872 + uintptr((*J40__dct_select)(unsafe.Pointer(dct)).Param_idx)*16

			for c = 0; c < 3; c++ {
				var coeffs uintptr = *(*uintptr)(unsafe.Pointer(gg + 208 + uintptr(c)*8)) + uintptr((*J40__varblock)(unsafe.Pointer((*J40__lf_group_st)(unsafe.Pointer(gg)).Varblocks+uintptr(voff)*8)).Coeffoff_qfidx&libc.CplInt32(15))*4
				for i = 0; i < size; i++ {
					if -1.0 <= *(*float32)(unsafe.Pointer(coeffs + uintptr(i)*4)) && *(*float32)(unsafe.Pointer(coeffs + uintptr(i)*4)) <= 1.0 {
						*(*float32)(unsafe.Pointer(coeffs + uintptr(i)*4)) *= *(*float32)(unsafe.Pointer(quant_bias + uintptr(c)*4))
					} else {
						*(*float32)(unsafe.Pointer(coeffs + uintptr(i)*4)) -= quant_bias_num / *(*float32)(unsafe.Pointer(coeffs + uintptr(i)*4))
					}
					*(*float32)(unsafe.Pointer(coeffs + uintptr(i)*4)) *= *(*float32)(unsafe.Pointer(bp + uintptr(c)*4)) / *(*float32)(unsafe.Pointer((*J40__dq_matrix)(unsafe.Pointer(dqmat)).Params + uintptr(i)*16 + uintptr(c)*4))
				}
			}
		}
	}
}

var QM_SCALE = [8]float32{1.5625, 1.25, 1.0, 0.8, 0.64, 0.512, 0.4096, 0.32768}

func j40__combine_vardct_from_lf_group(tls *libc.TLS, st uintptr, gg uintptr) J40_err {
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var im uintptr
	var f uintptr
	var ggw8 Int32_t
	var ggh8 Int32_t
	var ggw Int32_t
	var ggh Int32_t
	var kx_lf float32
	var kb_lf float32

	var scratch uintptr
	var scratch2 uintptr

	var x8 Int32_t
	var y8 Int32_t
	var x Int32_t
	var y Int32_t
	var i Int32_t
	var c Int32_t
	var dct uintptr
	var voff Int32_t
	var dctsel Int32_t
	var size Int32_t
	var effvw Int32_t
	var effvh Int32_t
	var vw8 Int32_t
	var vh8 Int32_t
	var samplepos Int32_t
	var coeffoff Int32_t

	var kx_hf float32
	var kb_hf float32
	var pp float32
	var pos Int32_t

	var itscale float32
	var p1 Int32_t
	var v float32
	var pixels uintptr
	im = (*J40__st)(unsafe.Pointer(st)).Image
	f = (*J40__st)(unsafe.Pointer(st)).Frame
	ggw8 = (*J40__lf_group_st)(unsafe.Pointer(gg)).Width8
	ggh8 = (*J40__lf_group_st)(unsafe.Pointer(gg)).Height8
	ggw = (*J40__lf_group_st)(unsafe.Pointer(gg)).Width
	ggh = (*J40__lf_group_st)(unsafe.Pointer(gg)).Height
	scratch = uintptr(0)
	*(*[3]uintptr)(unsafe.Pointer(bp)) = [3]uintptr{}

	c = 0
__1:
	if !(c < 3) {
		goto __3
	}
__4:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __7
	}
	goto J40__ON_ERROR
__7:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(bp+uintptr(c)*8, j40__malloc(tls, uint64(unsafe.Sizeof(float32(0)))*Size_t(ggw*ggh)))) != 0)), int64(0)) != 0) {
		goto __8
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__8:
	;
	goto __5
__5:
	if 0 != 0 {
		goto __4
	}
	goto __6
__6:
	;
	goto __2
__2:
	c++
	goto __1
	goto __3
__3:
	;
__9:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __12
	}
	goto J40__ON_ERROR
__12:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignUintptr(&scratch, j40__malloc(tls, uint64(unsafe.Sizeof(float32(0)))*uint64(2)*uint64(65536)))) != 0)), int64(0)) != 0) {
		goto __13
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__13:
	;
	goto __10
__10:
	if 0 != 0 {
		goto __9
	}
	goto __11
__11:
	;
	scratch2 = scratch + uintptr(65536)*4

	kx_lf = (*J40__frame_st)(unsafe.Pointer(f)).Base_corr_x + float32((*J40__frame_st)(unsafe.Pointer(f)).X_factor_lf)*(*J40__frame_st)(unsafe.Pointer(f)).Inv_colour_factor
	kb_lf = (*J40__frame_st)(unsafe.Pointer(f)).Base_corr_b + float32((*J40__frame_st)(unsafe.Pointer(f)).B_factor_lf)*(*J40__frame_st)(unsafe.Pointer(f)).Inv_colour_factor

	y8 = 0
__14:
	if !(y8 < ggh8) {
		goto __16
	}
	x8 = 0
__17:
	if !(x8 < ggw8) {
		goto __19
	}
	voff = *(*Int32_t)(unsafe.Pointer(func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(gg+152)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(gg+152)).Stride_bytes)*Size_t(y8))
	}() + uintptr(x8)*4))
	dctsel = voff >> 20

	if !(dctsel < 2) {
		goto __20
	}
	goto __18
__20:
	;
	dctsel = dctsel - 2
	voff = voff & 0xfffff
	dct = uintptr(unsafe.Pointer(&sJ40__DCT_SELECT)) + uintptr(dctsel)*4
	size = int32(1) << (int32((*J40__dct_select)(unsafe.Pointer(dct)).Log_rows) + int32((*J40__dct_select)(unsafe.Pointer(dct)).Log_columns))
	coeffoff = (*J40__varblock)(unsafe.Pointer((*J40__lf_group_st)(unsafe.Pointer(gg)).Varblocks+uintptr(voff)*8)).Coeffoff_qfidx & libc.CplInt32(15)
	c = 0
__21:
	if !(c < 3) {
		goto __23
	}
	*(*uintptr)(unsafe.Pointer(bp + 24 + uintptr(c)*8)) = *(*uintptr)(unsafe.Pointer(gg + 208 + uintptr(c)*8)) + uintptr(coeffoff)*4
	*(*uintptr)(unsafe.Pointer(bp + 48 + uintptr(c)*8)) = *(*uintptr)(unsafe.Pointer(gg + 184 + uintptr(c)*8)) + uintptr(coeffoff>>6)*4
	goto __22
__22:
	c++
	goto __21
	goto __23
__23:
	;
	kx_hf = (*J40__frame_st)(unsafe.Pointer(f)).Base_corr_x + (*J40__frame_st)(unsafe.Pointer(f)).Inv_colour_factor*func() float32 {
		if int32((*J40__lf_group_st)(unsafe.Pointer(gg)).Xfromy.Type) == J40__PLANE_I16 {
			return float32(*(*Int16_t)(unsafe.Pointer(func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(gg+72)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(gg+72)).Stride_bytes)*Size_t(y8/8))
			}() + uintptr(x8/8)*2)))
		}
		return float32(*(*Int32_t)(unsafe.Pointer(func() uintptr {
			return uintptr((*J40__plane)(unsafe.Pointer(gg+72)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(gg+72)).Stride_bytes)*Size_t(y8/8))
		}() + uintptr(x8/8)*4)))
	}()
	kb_hf = (*J40__frame_st)(unsafe.Pointer(f)).Base_corr_b + (*J40__frame_st)(unsafe.Pointer(f)).Inv_colour_factor*func() float32 {
		if int32((*J40__lf_group_st)(unsafe.Pointer(gg)).Bfromy.Type) == J40__PLANE_I16 {
			return float32(*(*Int16_t)(unsafe.Pointer(func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(gg+96)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(gg+96)).Stride_bytes)*Size_t(y8/8))
			}() + uintptr(x8/8)*2)))
		}
		return float32(*(*Int32_t)(unsafe.Pointer(func() uintptr {
			return uintptr((*J40__plane)(unsafe.Pointer(gg+96)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(gg+96)).Stride_bytes)*Size_t(y8/8))
		}() + uintptr(x8/8)*4)))
	}()

	effvh = J40__min32(tls, ggh-y8*8, int32(1)<<int32((*J40__dct_select)(unsafe.Pointer(dct)).Log_rows))
	effvw = J40__min32(tls, ggw-x8*8, int32(1)<<int32((*J40__dct_select)(unsafe.Pointer(dct)).Log_columns))
	samplepos = y8*8*ggw + x8*8

	vh8 = int32(1) << (J40__min32(tls, int32((*J40__dct_select)(unsafe.Pointer(dct)).Log_rows), int32((*J40__dct_select)(unsafe.Pointer(dct)).Log_columns)) - 3)
	vw8 = int32(1) << (J40__max32(tls, int32((*J40__dct_select)(unsafe.Pointer(dct)).Log_rows), int32((*J40__dct_select)(unsafe.Pointer(dct)).Log_columns)) - 3)

	c = 0
__24:
	if !(c < 3) {
		goto __26
	}

	switch c {
	case 0:
		goto __28
	case 1:
		goto __29
	case 2:
		goto __30
	default:
		goto __31
	}
	goto __27
__28:
	i = 0
__32:
	if !(i < size) {
		goto __34
	}
	*(*float32)(unsafe.Pointer(scratch + uintptr(i)*4)) = *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)) + uintptr(i)*4)) + *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 + 1*8)) + uintptr(i)*4))*kx_hf
	goto __33
__33:
	i++
	goto __32
	goto __34
__34:
	;
	y = 0
__35:
	if !(y < vh8) {
		goto __37
	}
	x = 0
__38:
	if !(x < vw8) {
		goto __40
	}
	*(*float32)(unsafe.Pointer(scratch + uintptr(y*vw8*8+x)*4)) = *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48)) + uintptr(y*vw8+x)*4)) + *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48 + 1*8)) + uintptr(y*vw8+x)*4))*kx_lf
	goto __39
__39:
	x++
	goto __38
	goto __40
__40:
	;
	goto __36
__36:
	y++
	goto __35
	goto __37
__37:
	;
	goto __27
__29:
	i = 0
__41:
	if !(i < size) {
		goto __43
	}
	*(*float32)(unsafe.Pointer(scratch + uintptr(i)*4)) = *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 + 1*8)) + uintptr(i)*4))
	goto __42
__42:
	i++
	goto __41
	goto __43
__43:
	;
	y = 0
__44:
	if !(y < vh8) {
		goto __46
	}
	x = 0
__47:
	if !(x < vw8) {
		goto __49
	}
	*(*float32)(unsafe.Pointer(scratch + uintptr(y*vw8*8+x)*4)) = *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48 + 1*8)) + uintptr(y*vw8+x)*4))
	goto __48
__48:
	x++
	goto __47
	goto __49
__49:
	;
	goto __45
__45:
	y++
	goto __44
	goto __46
__46:
	;
	goto __27
__30:
	i = 0
__50:
	if !(i < size) {
		goto __52
	}
	*(*float32)(unsafe.Pointer(scratch + uintptr(i)*4)) = *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 + 2*8)) + uintptr(i)*4)) + *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 + 1*8)) + uintptr(i)*4))*kb_hf
	goto __51
__51:
	i++
	goto __50
	goto __52
__52:
	;
	y = 0
__53:
	if !(y < vh8) {
		goto __55
	}
	x = 0
__56:
	if !(x < vw8) {
		goto __58
	}
	*(*float32)(unsafe.Pointer(scratch + uintptr(y*vw8*8+x)*4)) = *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48 + 2*8)) + uintptr(y*vw8+x)*4)) + *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48 + 1*8)) + uintptr(y*vw8+x)*4))*kb_lf
	goto __57
__57:
	x++
	goto __56
	goto __58
__58:
	;
	goto __54
__54:
	y++
	goto __53
	goto __55
__55:
	;
	goto __27
__31:
	;
__27:
	;
	switch dctsel {
	case 1:
		goto __60
	case 2:
		goto __61
	case 3:
		goto __62
	case 12:
		goto __63
	case 13:
		goto __64
	case 14:
		goto __65
	case 15:
		goto __66
	case 16:
		goto __67
	case 17:
		goto __68
	default:
		goto __69
	}
	goto __59
__60:
	j40__inverse_hornuss(tls, scratch)
	goto __59
__61:
	j40__inverse_dct11(tls, scratch)
	goto __59
__62:
	j40__inverse_dct22(tls, scratch)
	goto __59
__63:
	j40__inverse_dct23(tls, scratch)
	goto __59
__64:
	j40__inverse_dct32(tls, scratch)
	goto __59
__65:
	j40__inverse_afv(tls, scratch, 0, 0)
	goto __59
__66:
	j40__inverse_afv(tls, scratch, 1, 0)
	goto __59
__67:
	j40__inverse_afv(tls, scratch, 0, 1)
	goto __59
__68:
	j40__inverse_afv(tls, scratch, 1, 1)
	goto __59
__69:
	j40__inverse_dct2d(tls, scratch, scratch2, int32((*J40__dct_select)(unsafe.Pointer(dct)).Log_rows), int32((*J40__dct_select)(unsafe.Pointer(dct)).Log_columns))
	goto __59
__59:
	;
	if !(0 != 0) {
		goto __70
	}
	x = 0
__71:
	if !(x < int32(1)<<int32((*J40__dct_select)(unsafe.Pointer(dct)).Log_columns)) {
		goto __73
	}
	*(*float32)(unsafe.Pointer(scratch + uintptr(x)*4)) = 1.0 - float32(dctsel>>x&1)
	goto __72
__72:
	x++
	goto __71
	goto __73
__73:
	;
	y = 0
__74:
	if !(y < int32(1)<<int32((*J40__dct_select)(unsafe.Pointer(dct)).Log_rows)) {
		goto __76
	}
	*(*float32)(unsafe.Pointer(scratch + uintptr(y<<int32((*J40__dct_select)(unsafe.Pointer(dct)).Log_columns))*4)) = 1.0 - float32(dctsel>>y&1)
	goto __75
__75:
	y++
	goto __74
	goto __76
__76:
	;
__70:
	;
	y = 0
__77:
	if !(y < effvh) {
		goto __79
	}
	x = 0
__80:
	if !(x < effvw) {
		goto __82
	}
	*(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + uintptr(c)*8)) + uintptr(samplepos+y*ggw+x)*4)) = *(*float32)(unsafe.Pointer(scratch + uintptr(y<<int32((*J40__dct_select)(unsafe.Pointer(dct)).Log_columns)|x)*4))
	goto __81
__81:
	x++
	goto __80
	goto __82
__82:
	;
	goto __78
__78:
	y++
	goto __77
	goto __79
__79:
	;
	goto __25
__25:
	c++
	goto __24
	goto __26
__26:
	;
	goto __18
__18:
	x8++
	goto __17
	goto __19
__19:
	;
	goto __15
__15:
	y8++
	goto __14
	goto __16
__16:
	;
	c = 0
__83:
	if !(c < 3) {
		goto __85
	}
	*(*float32)(unsafe.Pointer(bp + 72 + uintptr(c)*4)) = cbrtf(tls, *(*float32)(unsafe.Pointer(im + 184 + uintptr(c)*4)))
	goto __84
__84:
	c++
	goto __83
	goto __85
__85:
	;
	y = 0
__86:
	if !(y < ggh) {
		goto __88
	}
	x = 0
__89:
	if !(x < ggw) {
		goto __91
	}
	pos = y*ggw + x
	*(*[3]float32)(unsafe.Pointer(bp + 84)) = [3]float32{
		*(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 1*8)) + uintptr(pos)*4)) + *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + uintptr(pos)*4)),
		*(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 1*8)) + uintptr(pos)*4)) - *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + uintptr(pos)*4)),
		*(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 2*8)) + uintptr(pos)*4)),
	}
	itscale = 255.0 / (*J40__image_st)(unsafe.Pointer(im)).Intensity_target
	c = 0
__92:
	if !(c < 3) {
		goto __94
	}
	pp = *(*float32)(unsafe.Pointer(bp + 84 + uintptr(c)*4)) - *(*float32)(unsafe.Pointer(bp + 72 + uintptr(c)*4))
	*(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + uintptr(c)*8)) + uintptr(pos)*4)) = (pp*pp*pp + *(*float32)(unsafe.Pointer(im + 184 + uintptr(c)*4))) * itscale
	goto __93
__93:
	c++
	goto __92
	goto __94
__94:
	;
	goto __90
__90:
	x++
	goto __89
	goto __91
__91:
	;
	goto __87
__87:
	y++
	goto __86
	goto __88
__88:
	;
	c = 0
__95:
	if !(c < 3) {
		goto __97
	}
	if !(int32((*J40__plane)(unsafe.Pointer((*J40__frame_st)(unsafe.Pointer(f)).Gmodular.Channel+uintptr(c)*24)).Type) == J40__PLANE_I16) {
		goto __98
	}
	y = 0
__100:
	if !(y < ggh) {
		goto __102
	}
	pixels = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer((*J40__frame_st)(unsafe.Pointer(f)).Gmodular.Channel+uintptr(c)*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer((*J40__frame_st)(unsafe.Pointer(f)).Gmodular.Channel+uintptr(c)*24)).Stride_bytes)*Size_t((*J40__lf_group_st)(unsafe.Pointer(gg)).Top+y))
	}()
	x = 0
__103:
	if !(x < ggw) {
		goto __105
	}
	p1 = y*ggw + x
	v =
		*(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + uintptr(p1)*4))**(*float32)(unsafe.Pointer(im + 148 + uintptr(c)*12)) + *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 1*8)) + uintptr(p1)*4))**(*float32)(unsafe.Pointer(im + 148 + uintptr(c)*12 + 1*4)) + *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 2*8)) + uintptr(p1)*4))**(*float32)(unsafe.Pointer(im + 148 + uintptr(c)*12 + 2*4))

	v = func() float32 {
		if v <= 0.0031308 {
			return 12.92 * v
		}
		return 1.055*powf(tls, v, float32(1.0)/2.4) - 0.055
	}()

	*(*Int16_t)(unsafe.Pointer(pixels + uintptr((*J40__lf_group_st)(unsafe.Pointer(gg)).Left+x)*2)) = libc.Int16FromFloat32(float32(int32(1)<<(*J40__image_st)(unsafe.Pointer(im)).Bpp-1)*v + 0.5)
	goto __104
__104:
	x++
	goto __103
	goto __105
__105:
	;
	goto __101
__101:
	y++
	goto __100
	goto __102
__102:
	;
	goto __99
__98:
__106:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 765))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 765 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 765 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 765 + 3))))
	goto J40__ON_ERROR
	goto __107
__107:
	if 0 != 0 {
		goto __106
	}
	goto __108
__108:
	;
__99:
	;
	goto __96
__96:
	c++
	goto __95
	goto __97
__97:
	;
J40__ON_ERROR:
	j40__free(tls, scratch)
	c = 0
__109:
	if !(c < 3) {
		goto __111
	}
	j40__free(tls, *(*uintptr)(unsafe.Pointer(bp + uintptr(c)*8)))
	goto __110
__110:
	c++
	goto __109
	goto __111
__111:
	;
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__mirror1d(tls *libc.TLS, coord Int32_t, size Int32_t) Int32_t {
	for 1 != 0 {
		if coord < 0 {
			coord = -coord - 1
		} else if coord >= size {
			coord = size*2 - 1 - coord
		} else {
			return coord
		}
	}
	return Int32_t(0)
}

// computes out(x + 1, y + 1) = abs(in(x, y) - in(x + dx, y + dy)), up to mirroring.
// used to compute DistanceStep* functions; an increased border is required for correctness.
func j40__epf_distance(tls *libc.TLS, in uintptr, dx Int32_t, dy Int32_t, out uintptr) {
	var width Int32_t = (*J40__plane)(unsafe.Pointer(in)).Width
	var height Int32_t = (*J40__plane)(unsafe.Pointer(in)).Height
	var x Int32_t
	var y Int32_t
	var xlo Int32_t
	var xhi Int32_t

	xlo = func() int32 {
		if dx > 0 {
			return 0
		}
		return -dx
	}()
	xhi = func() int32 {
		if dx < 0 {
			return width
		}
		return width - dx
	}()

	for y = -1; y <= height; y++ {
		var refy Int32_t = j40__mirror1d(tls, y, height)
		var offy Int32_t = j40__mirror1d(tls, y+dy, height)
		var refpixels uintptr = func() uintptr {
			return uintptr((*J40__plane)(unsafe.Pointer(in)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(in)).Stride_bytes)*Size_t(refy))
		}()
		var offpixels uintptr = func() uintptr {
			return uintptr((*J40__plane)(unsafe.Pointer(in)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(in)).Stride_bytes)*Size_t(offy))
		}()
		var outpixels uintptr = func() uintptr {
			return uintptr((*J40__plane)(unsafe.Pointer(out)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(out)).Stride_bytes)*Size_t(y+1))
		}() + uintptr(1)*4

		for x = -1; x < xlo; x++ {
			*(*float32)(unsafe.Pointer(outpixels + uintptr(x)*4)) = libc.Xfabsf(tls, *(*float32)(unsafe.Pointer(refpixels + uintptr(j40__mirror1d(tls, x, width))*4))-*(*float32)(unsafe.Pointer(offpixels + uintptr(j40__mirror1d(tls, x+dx, width))*4)))
		}
		for ; x < xhi; x++ {
			*(*float32)(unsafe.Pointer(outpixels + uintptr(x)*4)) = libc.Xfabsf(tls, *(*float32)(unsafe.Pointer(refpixels + uintptr(x)*4))-*(*float32)(unsafe.Pointer(offpixels + uintptr(x+dx)*4)))
		}
		for ; x <= width; x++ {
			*(*float32)(unsafe.Pointer(outpixels + uintptr(x)*4)) = libc.Xfabsf(tls, *(*float32)(unsafe.Pointer(refpixels + uintptr(j40__mirror1d(tls, x, width))*4))-*(*float32)(unsafe.Pointer(offpixels + uintptr(j40__mirror1d(tls, x+dx, width))*4)))
		}
	}
}

var sJ40__SIGMA_THRESHOLD float32 = 0.3

// computes f(sigma) for each block, where f(x) = 1/x if x >= J40__SIGMA_THRESHOLD and < 0 otherwise.
// note that `inv_sigma` in the spec is not same to `1/sigma`, hence a different name.
func j40__epf_recip_sigmas(tls *libc.TLS, st uintptr, gg uintptr, out uintptr) J40_err {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var f uintptr
	var ggw8 Int32_t
	var ggh8 Int32_t

	var x8 Int32_t
	var y8 Int32_t
	var i Int32_t
	var quant_sharp_lut float32
	var sharpness uintptr
	var recip_sigmas uintptr
	var sharpness_ub Uint16_t
	var sharpness1 uintptr
	var recip_sigmas1 uintptr
	var sharpness_ub1 Uint32_t
	var voff Int32_t
	var blocks uintptr
	var recip_sigmas2 uintptr
	f = (*J40__st)(unsafe.Pointer(st)).Frame
	ggw8 = (*J40__lf_group_st)(unsafe.Pointer(gg)).Width8
	ggh8 = (*J40__lf_group_st)(unsafe.Pointer(gg)).Height8

__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_plane(tls, st, J40__PLANE_F32, (*J40__lf_group_st)(unsafe.Pointer(gg)).Width8, (*J40__lf_group_st)(unsafe.Pointer(gg)).Height8, J40__PLANE_FORCE_PAD, out) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
	i = 0
__5:
	if !(i < 8) {
		goto __7
	}
	quant_sharp_lut = (*J40__frame_st)(unsafe.Pointer(f)).Epf.Quant_mul * *(*float32)(unsafe.Pointer(f + 236 + 4 + uintptr(i)*4))
__8:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __11
	}
	goto J40__ON_ERROR
__11:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(J40__surely_nonzero(tls, quant_sharp_lut) != 0)), int64(0)) != 0) {
		goto __12
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 792))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 792 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 792 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 792 + 3))))
	goto J40__ON_ERROR
__12:
	;
	goto __9
__9:
	if 0 != 0 {
		goto __8
	}
	goto __10
__10:
	;
	*(*float32)(unsafe.Pointer(bp + uintptr(i)*4)) = 1.0 / quant_sharp_lut
	goto __6
__6:
	i++
	goto __5
	goto __7
__7:
	;
	if !(int32((*J40__lf_group_st)(unsafe.Pointer(gg)).Sharpness.Type) == J40__PLANE_I16) {
		goto __13
	}
	sharpness_ub = Uint16_t(0)
	y8 = 0
__15:
	if !(y8 < ggh8) {
		goto __17
	}
	sharpness = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(gg+120)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(gg+120)).Stride_bytes)*Size_t(y8))
	}()
	recip_sigmas = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(out)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(out)).Stride_bytes)*Size_t(y8))
	}()
	x8 = 0
__18:
	if !(x8 < ggw8) {
		goto __20
	}
	sharpness_ub = Uint16_t(int32(sharpness_ub) | int32(Uint16_t(*(*Int16_t)(unsafe.Pointer(sharpness + uintptr(x8)*2)))))
	*(*float32)(unsafe.Pointer(recip_sigmas + uintptr(x8)*4)) = *(*float32)(unsafe.Pointer(bp + uintptr(int32(*(*Int16_t)(unsafe.Pointer(sharpness + uintptr(x8)*2)))&7)*4))
	goto __19
__19:
	x8++
	goto __18
	goto __20
__20:
	;
	goto __16
__16:
	y8++
	goto __15
	goto __17
__17:
	;
__21:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __24
	}
	goto J40__ON_ERROR
__24:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(sharpness_ub) < 8)), int64(0)) != 0) {
		goto __25
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 797))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 797 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 797 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 797 + 3))))
	goto J40__ON_ERROR
__25:
	;
	goto __22
__22:
	if 0 != 0 {
		goto __21
	}
	goto __23
__23:
	;
	goto __14
__13:
	sharpness_ub1 = Uint32_t(0)
	y8 = 0
__26:
	if !(y8 < ggh8) {
		goto __28
	}
	sharpness1 = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(gg+120)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(gg+120)).Stride_bytes)*Size_t(y8))
	}()
	recip_sigmas1 = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(out)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(out)).Stride_bytes)*Size_t(y8))
	}()
	x8 = 0
__29:
	if !(x8 < ggw8) {
		goto __31
	}
	sharpness_ub1 = sharpness_ub1 | Uint32_t(*(*Int32_t)(unsafe.Pointer(sharpness1 + uintptr(x8)*4)))
	*(*float32)(unsafe.Pointer(recip_sigmas1 + uintptr(x8)*4)) = *(*float32)(unsafe.Pointer(bp + uintptr(*(*Int32_t)(unsafe.Pointer(sharpness1 + uintptr(x8)*4))&7)*4))
	goto __30
__30:
	x8++
	goto __29
	goto __31
__31:
	;
	goto __27
__27:
	y8++
	goto __26
	goto __28
__28:
	;
__32:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __35
	}
	goto J40__ON_ERROR
__35:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(sharpness_ub1 < Uint32_t(8))), int64(0)) != 0) {
		goto __36
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 797))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 797 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 797 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 797 + 3))))
	goto J40__ON_ERROR
__36:
	;
	goto __33
__33:
	if 0 != 0 {
		goto __32
	}
	goto __34
__34:
	;
__14:
	;
	y8 = 0
__37:
	if !(y8 < ggh8) {
		goto __39
	}
	blocks = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(gg+152)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(gg+152)).Stride_bytes)*Size_t(y8))
	}()
	recip_sigmas2 = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(out)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(out)).Stride_bytes)*Size_t(y8))
	}()
	x8 = 0
__40:
	if !(x8 < ggw8) {
		goto __42
	}
	voff = *(*Int32_t)(unsafe.Pointer(blocks + uintptr(x8)*4)) & 0xfffff
	*(*float32)(unsafe.Pointer(recip_sigmas2 + uintptr(x8)*4)) *= *(*float32)(unsafe.Pointer((*J40__lf_group_st)(unsafe.Pointer(gg)).Varblocks + uintptr(voff)*8 + 4))
	if !(*(*float32)(unsafe.Pointer(recip_sigmas2 + uintptr(x8)*4)) > 1.0/sJ40__SIGMA_THRESHOLD) {
		goto __43
	}
	*(*float32)(unsafe.Pointer(recip_sigmas2 + uintptr(x8)*4)) = -1.0
__43:
	;
	goto __41
__41:
	x8++
	goto __40
	goto __42
__42:
	;
	goto __38
__38:
	y8++
	goto __37
	goto __39
__39:
	;
	return J40_err(0)

J40__ON_ERROR:
	j40__free_plane(tls, out)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__epf_step(tls *libc.TLS, st uintptr, channels uintptr, sigma_scale float32, recip_sigmas uintptr, nkernels Int32_t, kernels uintptr, distances uintptr, dist_uses_cross int32, gg uintptr) J40_err {
	bp := tls.Alloc(188)
	defer tls.Free(188)

	var distance_rows uintptr
	defer libc.Xfree(tls, distance_rows)

	var f uintptr
	var ggw8 Int32_t
	var ggh8 Int32_t
	_ = ggh8
	var width Int32_t
	var height Int32_t
	var stride Int32_t
	var cstride Int32_t

	var linebuf uintptr

	var recip_sigmas_for_modular uintptr
	var border_sigma_scale float32
	var x Int32_t
	var y Int32_t
	var c Int32_t
	var k Int32_t
	var i Int32_t
	var recip_sigma float32
	var borderpos Int32_t
	var mirrorpos Int32_t
	var ym2 Int32_t
	var ym1 Int32_t
	var temp uintptr
	var dist float32
	var weight float32
	var dist1 float32
	var weight1 float32
	var recip_sigma1 float32
	var inv_sigma_times_pos_mult float32
	var sum_weights float32

	var y1 Int32_t
	var y2 Int32_t

	var recip_sigma_row uintptr
	distance_rows = libc.Xrealloc(tls, distance_rows, types.Size_t(NKERNELS*72))
	f = (*J40__st)(unsafe.Pointer(st)).Frame
	ggw8 = (*J40__lf_group_st)(unsafe.Pointer(gg)).Width8
	ggh8 = (*J40__lf_group_st)(unsafe.Pointer(gg)).Height8
	width = (*J40__lf_group_st)(unsafe.Pointer(gg)).Width
	height = (*J40__lf_group_st)(unsafe.Pointer(gg)).Height
	stride = width + 4
	cstride = stride * 3
	*(*[4]Int32_t)(unsafe.Pointer(bp + 16)) = [4]Int32_t{-2, -1, width, width + 1}
	linebuf = uintptr(0)
	recip_sigmas_for_modular = uintptr(0)

	if !(recip_sigmas != 0) {
		goto __1
	}

	goto __2
__1:
__3:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __6
	}
	goto J40__ON_ERROR
__6:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(J40__surely_nonzero(tls, (*J40__frame_st)(unsafe.Pointer(f)).Epf.Sigma_for_modular) != 0)), int64(0)) != 0) {
		goto __7
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 792))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 792 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 792 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 792 + 3))))
	goto J40__ON_ERROR
__7:
	;
	goto __4
__4:
	if 0 != 0 {
		goto __3
	}
	goto __5
__5:
	;
	if !((*J40__frame_st)(unsafe.Pointer(f)).Epf.Sigma_for_modular < sJ40__SIGMA_THRESHOLD) {
		goto __8
	}
	return J40_err(0)
__8:
	;
__9:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __12
	}
	goto J40__ON_ERROR
__12:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignUintptr(&recip_sigmas_for_modular, j40__malloc(tls, uint64(unsafe.Sizeof(float32(0)))*Size_t(ggw8)))) != 0)), int64(0)) != 0) {
		goto __13
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__13:
	;
	goto __10
__10:
	if 0 != 0 {
		goto __9
	}
	goto __11
__11:
	;
	recip_sigma = 1.0 / (*J40__frame_st)(unsafe.Pointer(f)).Epf.Sigma_for_modular
	x = 0
__14:
	if !(x < ggw8) {
		goto __16
	}
	*(*float32)(unsafe.Pointer(recip_sigmas_for_modular + uintptr(x)*4)) = recip_sigma
	goto __15
__15:
	x++
	goto __14
	goto __16
__16:
	;
__2:
	;
	sigma_scale = sigma_scale * 1.9330952441687859
	border_sigma_scale = sigma_scale * (*J40__frame_st)(unsafe.Pointer(f)).Epf.Border_sad_mul

	c = 0
__17:
	if !(c < 3) {
		goto __19
	}
	k = 0
__20:
	if !(k < nkernels) {
		goto __22
	}
	j40__epf_distance(tls, channels+uintptr(c)*24, *(*Int32_t)(unsafe.Pointer(kernels + uintptr(k)*8)), *(*Int32_t)(unsafe.Pointer(kernels + uintptr(k)*8 + 1*4)), distances+uintptr(k)*72+uintptr(c)*24)
	goto __21
__21:
	k++
	goto __20
	goto __22
__22:
	;
	goto __18
__18:
	c++
	goto __17
	goto __19
__19:
	;
	i = 0
__23:
	if !(i < 4) {
		goto __25
	}
	*(*Int32_t)(unsafe.Pointer(bp + uintptr(i)*4)) = j40__mirror1d(tls, *(*Int32_t)(unsafe.Pointer(bp + 16 + uintptr(i)*4)), width)
	goto __24
__24:
	i++
	goto __23
	goto __25
__25:
	;
__26:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __29
	}
	goto J40__ON_ERROR
__29:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignUintptr(&linebuf, j40__malloc(tls, uint64(unsafe.Sizeof(float32(0)))*Size_t(cstride*4)))) != 0)), int64(0)) != 0) {
		goto __30
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__30:
	;
	goto __27
__27:
	if 0 != 0 {
		goto __26
	}
	goto __28
__28:
	;
	c = 0
__31:
	if !(c < 3) {
		goto __33
	}
	ym2 = j40__mirror1d(tls, -2, height)
	ym1 = j40__mirror1d(tls, -1, height)
	i = 0
__34:
	if !(i < 4) {
		goto __36
	}
	*(*uintptr)(unsafe.Pointer(bp + 32 + uintptr(i)*24 + uintptr(c)*8)) = linebuf + uintptr(cstride*c)*4 + uintptr(stride*i)*4 + uintptr(1)*4
	goto __35
__35:
	i++
	goto __34
	goto __36
__36:
	;
	libc.Xmemcpy(tls, *(*uintptr)(unsafe.Pointer(bp + 32 + 1*24 + uintptr(c)*8)), func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(channels+uintptr(c)*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(channels+uintptr(c)*24)).Stride_bytes)*Size_t(ym2))
	}(), uint64(unsafe.Sizeof(float32(0)))*Size_t(width))
	libc.Xmemcpy(tls, *(*uintptr)(unsafe.Pointer(bp + 32 + 2*24 + uintptr(c)*8)), func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(channels+uintptr(c)*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(channels+uintptr(c)*24)).Stride_bytes)*Size_t(ym1))
	}(), uint64(unsafe.Sizeof(float32(0)))*Size_t(width))
	libc.Xmemcpy(tls, *(*uintptr)(unsafe.Pointer(bp + 32 + 3*24 + uintptr(c)*8)), func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(channels+uintptr(c)*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(channels+uintptr(c)*24)).Stride_bytes)*uint64(0))
	}(), uint64(unsafe.Sizeof(float32(0)))*Size_t(width))
	i = 0
__37:
	if !(i < 4) {
		goto __39
	}
	borderpos = c*cstride + *(*Int32_t)(unsafe.Pointer(bp + 16 + uintptr(i)*4))
	mirrorpos = c*cstride + *(*Int32_t)(unsafe.Pointer(bp + uintptr(i)*4))
	*(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 + 1*24 + uintptr(c)*8)) + uintptr(borderpos)*4)) = *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 + 1*24 + uintptr(c)*8)) + uintptr(mirrorpos)*4))
	*(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 + 2*24 + uintptr(c)*8)) + uintptr(borderpos)*4)) = *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 + 2*24 + uintptr(c)*8)) + uintptr(mirrorpos)*4))
	*(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 + 3*24 + uintptr(c)*8)) + uintptr(borderpos)*4)) = *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 + 3*24 + uintptr(c)*8)) + uintptr(mirrorpos)*4))
	goto __38
__38:
	i++
	goto __37
	goto __39
__39:
	;
	goto __32
__32:
	c++
	goto __31
	goto __33
__33:
	;
	y = 0
__40:
	if !(y < height) {
		goto __42
	}
	y1 = j40__mirror1d(tls, y+1, height)
	y2 = j40__mirror1d(tls, y+2, height)
	if recip_sigmas != 0 {
		recip_sigma_row = func() uintptr {
			return uintptr((*J40__plane)(unsafe.Pointer(recip_sigmas)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(recip_sigmas)).Stride_bytes)*Size_t(y/8))
		}()
	} else {
		recip_sigma_row = recip_sigmas_for_modular
	}

	c = 0
__43:
	if !(c < 3) {
		goto __45
	}
	temp = *(*uintptr)(unsafe.Pointer(bp + 32 + uintptr(c)*8))
	*(*uintptr)(unsafe.Pointer(bp + 32 + uintptr(c)*8)) = *(*uintptr)(unsafe.Pointer(bp + 32 + 1*24 + uintptr(c)*8))
	*(*uintptr)(unsafe.Pointer(bp + 32 + 1*24 + uintptr(c)*8)) = *(*uintptr)(unsafe.Pointer(bp + 32 + 2*24 + uintptr(c)*8))
	*(*uintptr)(unsafe.Pointer(bp + 32 + 2*24 + uintptr(c)*8)) = *(*uintptr)(unsafe.Pointer(bp + 32 + 3*24 + uintptr(c)*8))
	*(*uintptr)(unsafe.Pointer(bp + 32 + 3*24 + uintptr(c)*8)) = temp
	*(*uintptr)(unsafe.Pointer(bp + 32 + 4*24 + uintptr(c)*8)) = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(channels+uintptr(c)*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(channels+uintptr(c)*24)).Stride_bytes)*Size_t(y2))
	}()
	*(*uintptr)(unsafe.Pointer(bp + 152 + uintptr(c)*8)) = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(channels+uintptr(c)*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(channels+uintptr(c)*24)).Stride_bytes)*Size_t(y))
	}()

	libc.Xmemcpy(tls, *(*uintptr)(unsafe.Pointer(bp + 32 + 3*24 + uintptr(c)*8)), func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(channels+uintptr(c)*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(channels+uintptr(c)*24)).Stride_bytes)*Size_t(y1))
	}(), uint64(unsafe.Sizeof(float32(0)))*Size_t(width))
	i = 0
__46:
	if !(i < 4) {
		goto __48
	}
	*(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 + 3*24 + uintptr(c)*8)) + uintptr(*(*Int32_t)(unsafe.Pointer(bp + 16 + uintptr(i)*4)))*4)) = *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 + 3*24 + uintptr(c)*8)) + uintptr(*(*Int32_t)(unsafe.Pointer(bp + uintptr(i)*4)))*4))
	goto __47
__47:
	i++
	goto __46
	goto __48
__48:
	;
	k = 0
__49:
	if !(k < nkernels) {
		goto __51
	}
	i = 0
__52:
	if !(i < 3) {
		goto __54
	}
	*(*uintptr)(unsafe.Pointer(distance_rows + uintptr(k)*72 + uintptr(i)*24 + uintptr(c)*8)) = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(distances+uintptr(k)*72+uintptr(c)*24)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(distances+uintptr(k)*72+uintptr(c)*24)).Stride_bytes)*Size_t(y+i))
	}()
	goto __53
__53:
	i++
	goto __52
	goto __54
__54:
	;
	goto __50
__50:
	k++
	goto __49
	goto __51
__51:
	;
	goto __44
__44:
	c++
	goto __43
	goto __45
__45:
	;
	x = 0
__55:
	if !(x < width) {
		goto __57
	}
	recip_sigma1 = *(*float32)(unsafe.Pointer(recip_sigma_row + uintptr(x/8)*4))

	if !(recip_sigma1 < 0.0) {
		goto __58
	}
	x = x + 7
	goto __56
__58:
	;
	if !((x+1|(y+1))&7 < 2) {
		goto __59
	}
	inv_sigma_times_pos_mult = recip_sigma1 * border_sigma_scale
	goto __60
__59:
	inv_sigma_times_pos_mult = recip_sigma1 * sigma_scale
__60:
	;
	sum_weights = 1.0
	c = 0
__61:
	if !(c < 3) {
		goto __63
	}
	*(*float32)(unsafe.Pointer(bp + 176 + uintptr(c)*4)) = *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 + 2*24 + uintptr(c)*8)) + uintptr(x)*4))
	goto __62
__62:
	c++
	goto __61
	goto __63
__63:
	;
	if !(dist_uses_cross != 0) {
		goto __64
	}
	k = 0
__66:
	if !(k < nkernels) {
		goto __68
	}
	dist = 0.0
	c = 0
__69:
	if !(c < 3) {
		goto __71
	}
	dist = dist + *(*float32)(unsafe.Pointer(f + 236 + 36 + uintptr(c)*4))*(*(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(distance_rows + uintptr(k)*72 + 1*24 + uintptr(c)*8)) + uintptr(x+1)*4))+*(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(distance_rows + uintptr(k)*72 + 1*24 + uintptr(c)*8)) + uintptr(x+0)*4))+*(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(distance_rows + uintptr(k)*72 + uintptr(c)*8)) + uintptr(x+1)*4))+*(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(distance_rows + uintptr(k)*72 + 2*24 + uintptr(c)*8)) + uintptr(x+1)*4))+*(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(distance_rows + uintptr(k)*72 + 1*24 + uintptr(c)*8)) + uintptr(x+2)*4)))
	goto __70
__70:
	c++
	goto __69
	goto __71
__71:
	;
	weight = J40__maxf(tls, 0.0, 1.0+dist*inv_sigma_times_pos_mult)
	sum_weights = sum_weights + weight
	c = 0
__72:
	if !(c < 3) {
		goto __74
	}
	*(*float32)(unsafe.Pointer(bp + 176 + uintptr(c)*4)) += *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 + uintptr(2+*(*Int32_t)(unsafe.Pointer(kernels + uintptr(k)*8)))*24 + uintptr(c)*8)) + uintptr(x+*(*Int32_t)(unsafe.Pointer(kernels + uintptr(k)*8 + 1*4)))*4)) * weight
	goto __73
__73:
	c++
	goto __72
	goto __74
__74:
	;
	goto __67
__67:
	k++
	goto __66
	goto __68
__68:
	;
	goto __65
__64:
	k = 0
__75:
	if !(k < nkernels) {
		goto __77
	}
	dist1 = 0.0
	c = 0
__78:
	if !(c < 3) {
		goto __80
	}
	dist1 = dist1 + *(*float32)(unsafe.Pointer(f + 236 + 36 + uintptr(c)*4))**(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(distance_rows + uintptr(k)*72 + 1*24 + uintptr(c)*8)) + uintptr(x+1)*4))
	goto __79
__79:
	c++
	goto __78
	goto __80
__80:
	;
	weight1 = J40__maxf(tls, 0.0, 1.0+dist1*inv_sigma_times_pos_mult)
	sum_weights = sum_weights + weight1
	c = 0
__81:
	if !(c < 3) {
		goto __83
	}
	*(*float32)(unsafe.Pointer(bp + 176 + uintptr(c)*4)) += *(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 + uintptr(2+*(*Int32_t)(unsafe.Pointer(kernels + uintptr(k)*8)))*24 + uintptr(c)*8)) + uintptr(x+*(*Int32_t)(unsafe.Pointer(kernels + uintptr(k)*8 + 1*4)))*4)) * weight1
	goto __82
__82:
	c++
	goto __81
	goto __83
__83:
	;
	goto __76
__76:
	k++
	goto __75
	goto __77
__77:
	;
__65:
	;
	c = 0
__84:
	if !(c < 3) {
		goto __86
	}
	*(*float32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 152 + uintptr(c)*8)) + uintptr(x)*4)) = *(*float32)(unsafe.Pointer(bp + 176 + uintptr(c)*4)) / sum_weights
	goto __85
__85:
	c++
	goto __84
	goto __86
__86:
	;
	goto __56
__56:
	x++
	goto __55
	goto __57
__57:
	;
	goto __41
__41:
	y++
	goto __40
	goto __42
__42:
	;
J40__ON_ERROR:
	j40__free(tls, recip_sigmas_for_modular)
	j40__free(tls, linebuf)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

var NKERNELS int32 = 12

type J40__group_info1 = struct {
	Ggidx    Int64_t
	Gx_in_gg Int32_t
	Gy_in_gg Int32_t
	Gw       Int32_t
	Gh       Int32_t
}

type J40__section_st = struct {
	Parent uintptr
	St     J40__st
	Buffer J40__buffer_st
}

func j40__allocate_lf_groups(tls *libc.TLS, st uintptr, out uintptr) J40_err {
	var f uintptr
	var ggs uintptr
	var ggsize Int32_t
	var gsize Int32_t
	var ggx Int32_t
	var ggy Int32_t
	var ggidx Int32_t
	var gidx Int32_t
	var gstride Int32_t
	var gg uintptr
	var ggw Int32_t
	var gcolumns Int32_t
	var ggh Int32_t
	var grows Int32_t
	f = (*J40__st)(unsafe.Pointer(st)).Frame
	ggs = uintptr(0)
	ggsize = int32(8) << (*J40__frame_st)(unsafe.Pointer(f)).Group_size_shift
	gsize = int32(1) << (*J40__frame_st)(unsafe.Pointer(f)).Group_size_shift
	ggidx = 0
	gidx = 0
	gstride = J40__ceil_div32(tls, (*J40__frame_st)(unsafe.Pointer(f)).Width, gsize)

__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignUintptr(&ggs, j40__calloc(tls, Size_t((*J40__frame_st)(unsafe.Pointer(f)).Num_lf_groups), uint64(unsafe.Sizeof(J40__lf_group_st{}))))) != 0)), int64(0)) != 0) {
		goto __5
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__5:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
	ggy = 0
__6:
	if !(ggy < (*J40__frame_st)(unsafe.Pointer(f)).Height) {
		goto __8
	}
	ggh = J40__min32(tls, ggsize, (*J40__frame_st)(unsafe.Pointer(f)).Height-ggy)
	grows = J40__ceil_div32(tls, ggh, gsize)
	ggx = 0
__9:
	if !(ggx < (*J40__frame_st)(unsafe.Pointer(f)).Width) {
		goto __11
	}
	gg = ggs + uintptr(ggidx)*272
	ggw = J40__min32(tls, ggsize, (*J40__frame_st)(unsafe.Pointer(f)).Width-ggx)
	gcolumns = J40__ceil_div32(tls, ggw, gsize)
	(*J40__lf_group_st)(unsafe.Pointer(gg)).Idx = Int64_t(ggidx)
	(*J40__lf_group_st)(unsafe.Pointer(gg)).Left = ggx
	(*J40__lf_group_st)(unsafe.Pointer(gg)).Top = ggy
	(*J40__lf_group_st)(unsafe.Pointer(gg)).Width = ggw
	(*J40__lf_group_st)(unsafe.Pointer(gg)).Height = ggh
	(*J40__lf_group_st)(unsafe.Pointer(gg)).Width8 = J40__ceil_div32(tls, ggw, 8)
	(*J40__lf_group_st)(unsafe.Pointer(gg)).Height8 = J40__ceil_div32(tls, ggh, 8)
	(*J40__lf_group_st)(unsafe.Pointer(gg)).Width64 = J40__ceil_div32(tls, ggw, 64)
	(*J40__lf_group_st)(unsafe.Pointer(gg)).Height64 = J40__ceil_div32(tls, ggh, 64)
	(*J40__lf_group_st)(unsafe.Pointer(gg)).Gidx = Int64_t(gidx + ggx>>(*J40__frame_st)(unsafe.Pointer(f)).Group_size_shift)
	(*J40__lf_group_st)(unsafe.Pointer(gg)).Grows = Int64_t(grows)
	(*J40__lf_group_st)(unsafe.Pointer(gg)).Gcolumns = Int64_t(gcolumns)
	(*J40__lf_group_st)(unsafe.Pointer(gg)).Gstride = Int64_t(gstride)
	goto __10
__10:
	ggx = ggx + ggsize
	ggidx++
	goto __9
	goto __11
__11:
	;
	gidx = gidx + grows*gstride
	goto __7
__7:
	ggy = ggy + ggsize
	goto __6
	goto __8
__8:
	;
	*(*uintptr)(unsafe.Pointer(out)) = ggs
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__prepare_dq_matrices(tls *libc.TLS, st uintptr) J40_err {
	var f uintptr
	var dct_select_not_loaded Int32_t
	var i Int32_t
	var dct uintptr
	var param_idx Int32_t
	f = (*J40__st)(unsafe.Pointer(st)).Frame
	dct_select_not_loaded = (*J40__frame_st)(unsafe.Pointer(f)).Dct_select_used & ^(*J40__frame_st)(unsafe.Pointer(f)).Dct_select_loaded
	if !!(dct_select_not_loaded != 0) {
		goto __1
	}
	return J40_err(0)
__1:
	;
	i = 0
__2:
	if !(i < J40__NUM_DCT_SELECT) {
		goto __4
	}
	if !(dct_select_not_loaded>>i&1 != 0) {
		goto __5
	}
	dct = uintptr(unsafe.Pointer(&sJ40__DCT_SELECT)) + uintptr(i)*4
	param_idx = Int32_t((*J40__dct_select)(unsafe.Pointer(dct)).Param_idx)
__6:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__load_dq_matrix(tls, st, param_idx, f+872+uintptr(param_idx)*16) != 0)), int64(0)) != 0) {
		goto __9
	}
	goto J40__ON_ERROR
__9:
	;
	goto __7
__7:
	if 0 != 0 {
		goto __6
	}
	goto __8
__8:
	;
	*(*Int32_t)(unsafe.Pointer(f + 856)) |= int32(1) << i
__5:
	;
	goto __3
__3:
	i++
	goto __2
	goto __4
__4:
	;
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__prepare_orders(tls *libc.TLS, st uintptr) J40_err {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var f uintptr
	var order_not_loaded Int32_t
	var pass Int32_t
	var i Int32_t
	var c Int32_t
	var log_rows Int32_t
	var log_columns Int32_t

	var skip Int32_t
	f = (*J40__st)(unsafe.Pointer(st)).Frame
	order_not_loaded = (*J40__frame_st)(unsafe.Pointer(f)).Order_used & ^(*J40__frame_st)(unsafe.Pointer(f)).Order_loaded
	if !!(order_not_loaded != 0) {
		goto __1
	}
	return J40_err(0)
__1:
	;
	i = 0
__2:
	if !(i < J40__NUM_ORDERS) {
		goto __4
	}
	if !(order_not_loaded>>i&1 != 0) {
		goto __5
	}
	log_rows = Int32_t(*(*Int8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&sJ40__LOG_ORDER_SIZE)) + uintptr(i)*2)))
	log_columns = Int32_t(*(*Int8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&sJ40__LOG_ORDER_SIZE)) + uintptr(i)*2 + 1)))
	skip = int32(1) << (log_rows + log_columns - 6)
	pass = 0
__6:
	if !(pass < (*J40__frame_st)(unsafe.Pointer(f)).Num_passes) {
		goto __8
	}
	c = 0
__9:
	if !(c < 3) {
		goto __11
	}
__12:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__natural_order(tls, st, log_rows, log_columns, bp) != 0)), int64(0)) != 0) {
		goto __15
	}
	goto J40__ON_ERROR
__15:
	;
	goto __13
__13:
	if 0 != 0 {
		goto __12
	}
	goto __14
__14:
	;
	j40__apply_permutation(tls, *(*uintptr)(unsafe.Pointer(bp))+uintptr(skip)*4, bp+8, uint64(unsafe.Sizeof(Int32_t(0))), *(*uintptr)(unsafe.Pointer(f + 1152 + uintptr(pass)*312 + uintptr(i)*24 + uintptr(c)*8)))
	j40__free(tls, *(*uintptr)(unsafe.Pointer(f + 1152 + uintptr(pass)*312 + uintptr(i)*24 + uintptr(c)*8)))
	*(*uintptr)(unsafe.Pointer(f + 1152 + uintptr(pass)*312 + uintptr(i)*24 + uintptr(c)*8)) = *(*uintptr)(unsafe.Pointer(bp))
	goto __10
__10:
	c++
	goto __9
	goto __11
__11:
	;
	goto __7
__7:
	pass++
	goto __6
	goto __8
__8:
	;
	*(*Int32_t)(unsafe.Pointer(f + 864)) |= int32(1) << i
__5:
	;
	goto __3
__3:
	i++
	goto __2
	goto __4
__4:
	;
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func J40__group_info(tls *libc.TLS, f uintptr, gidx Int64_t) J40__group_info1 {
	var info J40__group_info1
	var shift Int32_t = (*J40__frame_st)(unsafe.Pointer(f)).Group_size_shift
	var row Int64_t
	var column Int64_t

	row = gidx / (*J40__frame_st)(unsafe.Pointer(f)).Num_groups_per_row
	column = gidx % (*J40__frame_st)(unsafe.Pointer(f)).Num_groups_per_row
	info.Ggidx = row/int64(8)*(*J40__frame_st)(unsafe.Pointer(f)).Num_lf_groups_per_row + column/int64(8)
	info.Gx_in_gg = Int32_t(column%int64(8)) << shift
	info.Gy_in_gg = Int32_t(row%int64(8)) << shift
	info.Gw = Int32_t(J40__min64(tls, int64((*J40__frame_st)(unsafe.Pointer(f)).Width), (column+int64(1))<<shift) - column<<shift)
	info.Gh = Int32_t(J40__min64(tls, int64((*J40__frame_st)(unsafe.Pointer(f)).Height), (row+int64(1))<<shift) - row<<shift)
	return info
}

// creates a new per-section state `sst` which is identical to `*stptr` except for `buffer`,
// then ensures that only codestream offsets [codeoff, codeoff + size) are available to `sst`
// and updates `stptr` to point to `sst`, which should be restored with `j40__finish_section_state`.
func j40__init_section_state(tls *libc.TLS, stptr uintptr, sst uintptr, codeoff Int64_t, size Int32_t) J40_err {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var st uintptr

	st = *(*uintptr)(unsafe.Pointer(stptr))

	(*J40__section_st)(unsafe.Pointer(sst)).Parent = uintptr(0)

__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__map_codestream_offset(tls, st, codeoff, bp) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
__5:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __8
	}
	goto J40__ON_ERROR
__8:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(J40__add64(tls, codeoff, int64(size), bp+8) != 0)), int64(0)) != 0) {
		goto __9
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 66 + 3))))
	goto J40__ON_ERROR
__9:
	;
	goto __6
__6:
	if 0 != 0 {
		goto __5
	}
	goto __7
__7:
	;
__10:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__seek_from_source(tls, st, *(*Int64_t)(unsafe.Pointer(bp))) != 0)), int64(0)) != 0) {
		goto __13
	}
	goto J40__ON_ERROR
__13:
	;
	goto __11
__11:
	if 0 != 0 {
		goto __10
	}
	goto __12
__12:
	;
	(*J40__section_st)(unsafe.Pointer(sst)).St = *(*J40__st)(unsafe.Pointer(st))
	(*J40__section_st)(unsafe.Pointer(sst)).Buffer = BUFFER_INIT
	(*J40__section_st)(unsafe.Pointer(sst)).St.Buffer = sst + 112
__14:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_buffer(tls, sst+8, codeoff, *(*Int64_t)(unsafe.Pointer(bp + 8))) != 0)), int64(0)) != 0) {
		goto __17
	}
	goto J40__ON_ERROR
__17:
	;
	goto __15
__15:
	if 0 != 0 {
		goto __14
	}
	goto __16
__16:
	;
J40__ON_ERROR:
	(*J40__section_st)(unsafe.Pointer(sst)).Parent = st
	*(*uintptr)(unsafe.Pointer(stptr)) = sst + 8
	return (*J40__st)(unsafe.Pointer(st)).Err
}

var BUFFER_INIT = J40__buffer_st{}

func j40__finish_section_state(tls *libc.TLS, stptr uintptr, sst uintptr, err J40_err) J40_err {
	var st uintptr

	if !!(int32((*J40__section_st)(unsafe.Pointer(sst)).Parent) != 0) {
		goto __1
	}
	return err
__1:
	;
	if !(err != 0) {
		goto __2
	}
	*(*uintptr)(unsafe.Pointer(stptr)) = libc.AssignUintptr(&st, (*J40__section_st)(unsafe.Pointer(sst)).Parent)

	(*J40__st)(unsafe.Pointer(st)).Err = err
	(*J40__st)(unsafe.Pointer(st)).Saved_errno = (*J40__section_st)(unsafe.Pointer(sst)).St.Saved_errno
	(*J40__st)(unsafe.Pointer(st)).Cannot_retry = (*J40__section_st)(unsafe.Pointer(sst)).St.Cannot_retry

	goto __3
__2:
	st = sst + 8

__4:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__no_more_bytes(tls, st) != 0)), int64(0)) != 0) {
		goto __7
	}
	goto J40__ON_ERROR
__7:
	;
	goto __5
__5:
	if 0 != 0 {
		goto __4
	}
	goto __6
__6:
	;
__3:
	;
J40__ON_ERROR:
	*(*uintptr)(unsafe.Pointer(stptr)) = libc.AssignUintptr(&st, (*J40__section_st)(unsafe.Pointer(sst)).Parent)
	j40__free_buffer(tls, sst+112)

	(*J40__section_st)(unsafe.Pointer(sst)).Parent = uintptr(0)
	(*J40__section_st)(unsafe.Pointer(sst)).St.Source = uintptr(0)
	(*J40__section_st)(unsafe.Pointer(sst)).St.Container = uintptr(0)
	(*J40__section_st)(unsafe.Pointer(sst)).St.Buffer = uintptr(0)
	(*J40__section_st)(unsafe.Pointer(sst)).St.Image = uintptr(0)
	(*J40__section_st)(unsafe.Pointer(sst)).St.Frame = uintptr(0)

	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__lf_global_in_section(tls *libc.TLS, st uintptr, toc uintptr) J40_err {
	bp := tls.Alloc(192)
	defer tls.Free(192)
	*(*uintptr)(unsafe.Pointer(bp)) = st

	*(*J40__section_st)(unsafe.Pointer(bp + 8)) = J40__section_st{}
	if !!((*J40__toc)(unsafe.Pointer(toc)).Single_size != 0) {
		goto __1
	}
__2:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_section_state(tls, bp, bp+8, (*J40__toc)(unsafe.Pointer(toc)).Lf_global_codeoff, (*J40__toc)(unsafe.Pointer(toc)).Lf_global_size) != 0)), int64(0)) != 0) {
		goto __5
	}
	goto J40__ON_ERROR
__5:
	;
	goto __3
__3:
	if 0 != 0 {
		goto __2
	}
	goto __4
__4:
	;
__1:
	;
__6:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__finish_section_state(tls, bp, bp+8, j40__lf_global(tls, *(*uintptr)(unsafe.Pointer(bp)))) != 0)), int64(0)) != 0) {
		goto __9
	}
	goto J40__ON_ERROR
__9:
	;
	goto __7
__7:
	if 0 != 0 {
		goto __6
	}
	goto __8
__8:
	;
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Err
}

func j40__hf_global_in_section(tls *libc.TLS, st uintptr, toc uintptr) J40_err {
	bp := tls.Alloc(192)
	defer tls.Free(192)
	*(*uintptr)(unsafe.Pointer(bp)) = st

	*(*J40__section_st)(unsafe.Pointer(bp + 8)) = J40__section_st{}
	if !((*J40__frame_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Frame)).Is_modular != 0) {
		goto __1
	}
__3:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Err) != 0)), int64(0)) != 0) {
		goto __6
	}
	goto J40__ON_ERROR
__6:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__toc)(unsafe.Pointer(toc)).Hf_global_size == 0)), int64(0)) != 0) {
		goto __7
	}
	j40__set_error(tls, *(*uintptr)(unsafe.Pointer(bp)), Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 139))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 139 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 139 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 139 + 3))))
	goto J40__ON_ERROR
__7:
	;
	goto __4
__4:
	if 0 != 0 {
		goto __3
	}
	goto __5
__5:
	;
	goto __2
__1:
	if !!((*J40__toc)(unsafe.Pointer(toc)).Single_size != 0) {
		goto __8
	}
__9:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_section_state(tls, bp, bp+8, (*J40__toc)(unsafe.Pointer(toc)).Hf_global_codeoff, (*J40__toc)(unsafe.Pointer(toc)).Hf_global_size) != 0)), int64(0)) != 0) {
		goto __12
	}
	goto J40__ON_ERROR
__12:
	;
	goto __10
__10:
	if 0 != 0 {
		goto __9
	}
	goto __11
__11:
	;
__8:
	;
__13:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__finish_section_state(tls, bp, bp+8, j40__hf_global(tls, *(*uintptr)(unsafe.Pointer(bp)))) != 0)), int64(0)) != 0) {
		goto __16
	}
	goto J40__ON_ERROR
__16:
	;
	goto __14
__14:
	if 0 != 0 {
		goto __13
	}
	goto __15
__15:
	;
__2:
	;
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Err
}

func j40__lf_or_pass_group_in_section(tls *libc.TLS, st uintptr, toc uintptr, ggs uintptr) J40_err {
	bp := tls.Alloc(192)
	defer tls.Free(192)
	*(*uintptr)(unsafe.Pointer(bp)) = st

	var section J40__section

	var gg uintptr
	var info J40__group_info1
	var gg1 uintptr
	section = *(*J40__section)(unsafe.Pointer((*J40__toc)(unsafe.Pointer(toc)).Sections + uintptr((*J40__toc)(unsafe.Pointer(toc)).Nsections_read)*24))
	*(*J40__section_st)(unsafe.Pointer(bp + 8)) = J40__section_st{}

	if !(section.Pass < 0) {
		goto __1
	}
	gg = ggs + uintptr(section.Idx)*272
__3:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_section_state(tls, bp, bp+8, section.Codeoff, section.Size) != 0)), int64(0)) != 0) {
		goto __6
	}
	goto J40__ON_ERROR
__6:
	;
	goto __4
__4:
	if 0 != 0 {
		goto __3
	}
	goto __5
__5:
	;
__7:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__finish_section_state(tls, bp, bp+8, j40__lf_group(tls, *(*uintptr)(unsafe.Pointer(bp)), gg)) != 0)), int64(0)) != 0) {
		goto __10
	}
	goto J40__ON_ERROR
__10:
	;
	goto __8
__8:
	if 0 != 0 {
		goto __7
	}
	goto __9
__9:
	;
	(*J40__lf_group_st)(unsafe.Pointer(gg)).Loaded = 1
__11:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__prepare_dq_matrices(tls, *(*uintptr)(unsafe.Pointer(bp))) != 0)), int64(0)) != 0) {
		goto __14
	}
	goto J40__ON_ERROR
__14:
	;
	goto __12
__12:
	if 0 != 0 {
		goto __11
	}
	goto __13
__13:
	;
__15:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__prepare_orders(tls, *(*uintptr)(unsafe.Pointer(bp))) != 0)), int64(0)) != 0) {
		goto __18
	}
	goto J40__ON_ERROR
__18:
	;
	goto __16
__16:
	if 0 != 0 {
		goto __15
	}
	goto __17
__17:
	;
	goto __2
__1:
	info = J40__group_info(tls, (*J40__st)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Frame, section.Idx)
	gg1 = ggs + uintptr(info.Ggidx)*272

__19:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_section_state(tls, bp, bp+8, section.Codeoff, section.Size) != 0)), int64(0)) != 0) {
		goto __22
	}
	goto J40__ON_ERROR
__22:
	;
	goto __20
__20:
	if 0 != 0 {
		goto __19
	}
	goto __21
__21:
	;
__23:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__finish_section_state(tls, bp, bp+8, j40__pass_group(tls, *(*uintptr)(unsafe.Pointer(bp)), section.Pass, info.Gx_in_gg, info.Gy_in_gg, info.Gw, info.Gh, section.Idx, gg1)) != 0)), int64(0)) != 0) {
		goto __26
	}
	goto J40__ON_ERROR
__26:
	;
	goto __24
__24:
	if 0 != 0 {
		goto __23
	}
	goto __25
__25:
	;
__2:
	;
	(*J40__toc)(unsafe.Pointer(toc)).Nsections_read++

J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Err
}

func j40__combine_vardct(tls *libc.TLS, st uintptr, ggs uintptr) J40_err {
	var f uintptr
	var i Int64_t
	f = (*J40__st)(unsafe.Pointer(st)).Frame

__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(!((*J40__frame_st)(unsafe.Pointer(f)).Do_ycbcr != 0) && (*J40__image_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Image)).Cspace != J40__CS_GREY)), int64(0)) != 0) {
		goto __5
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 802))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 802 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 802 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 802 + 3))))
	goto J40__ON_ERROR
__5:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
__6:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __9
	}
	goto J40__ON_ERROR
__9:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__image_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Image)).Modular_16bit_buffers != 0)), int64(0)) != 0) {
		goto __10
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 838))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 838 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 838 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 838 + 3))))
	goto J40__ON_ERROR
__10:
	;
	goto __7
__7:
	if 0 != 0 {
		goto __6
	}
	goto __8
__8:
	;
	(*J40__frame_st)(unsafe.Pointer(f)).Gmodular.Num_channels = 3
__11:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __14
	}
	goto J40__ON_ERROR
__14:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(libc.AssignPtrUintptr(f+384+144, j40__calloc(tls, uint64(3), uint64(unsafe.Sizeof(J40__plane{}))))) != 0)), int64(0)) != 0) {
		goto __15
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))))
	goto J40__ON_ERROR
__15:
	;
	goto __12
__12:
	if 0 != 0 {
		goto __11
	}
	goto __13
__13:
	;
	i = int64(0)
__16:
	if !(i < Int64_t((*J40__frame_st)(unsafe.Pointer(f)).Gmodular.Num_channels)) {
		goto __18
	}
__19:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_plane(tls, st, J40__PLANE_I16, (*J40__frame_st)(unsafe.Pointer(f)).Width, (*J40__frame_st)(unsafe.Pointer(f)).Height, J40__PLANE_FORCE_PAD, (*J40__frame_st)(unsafe.Pointer(f)).Gmodular.Channel+uintptr(i)*24) != 0)), int64(0)) != 0) {
		goto __22
	}
	goto J40__ON_ERROR
__22:
	;
	goto __20
__20:
	if 0 != 0 {
		goto __19
	}
	goto __21
__21:
	;
	goto __17
__17:
	i++
	goto __16
	goto __18
__18:
	;
	i = int64(0)
__23:
	if !(i < (*J40__frame_st)(unsafe.Pointer(f)).Num_lf_groups) {
		goto __25
	}
	j40__dequant_hf(tls, st, ggs+uintptr(i)*272)
__26:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__combine_vardct_from_lf_group(tls, st, ggs+uintptr(i)*272) != 0)), int64(0)) != 0) {
		goto __29
	}
	goto J40__ON_ERROR
__29:
	;
	goto __27
__27:
	if 0 != 0 {
		goto __26
	}
	goto __28
__28:
	;
	goto __24
__24:
	i++
	goto __23
	goto __25
__25:
	;
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__end_of_frame(tls *libc.TLS, st uintptr, toc uintptr) J40_err {
	var codeoff Int64_t
__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__zero_pad_to_byte(tls, st) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
	if !((*J40__toc)(unsafe.Pointer(toc)).Single_size != 0) {
		goto __5
	}
	codeoff = j40__codestream_offset(tls, st)
	if !(codeoff < (*J40__toc)(unsafe.Pointer(toc)).End_codeoff) {
		goto __7
	}
	(*J40__st)(unsafe.Pointer(st)).Cannot_retry = 1
__9:
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 3))))
	goto J40__ON_ERROR
	goto __10
__10:
	if 0 != 0 {
		goto __9
	}
	goto __11
__11:
	;
	goto __8
__7:
__12:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __15
	}
	goto J40__ON_ERROR
__15:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(codeoff == (*J40__toc)(unsafe.Pointer(toc)).End_codeoff)), int64(0)) != 0) {
		goto __16
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 139))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 139 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 139 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 139 + 3))))
	goto J40__ON_ERROR
__16:
	;
	goto __13
__13:
	if 0 != 0 {
		goto __12
	}
	goto __14
__14:
	;
__8:
	;
	goto __6
__5:
__17:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__seek_buffer(tls, st, (*J40__toc)(unsafe.Pointer(toc)).End_codeoff) != 0)), int64(0)) != 0) {
		goto __20
	}
	goto J40__ON_ERROR
__20:
	;
	goto __18
__18:
	if 0 != 0 {
		goto __17
	}
	goto __19
__19:
	;
__6:
	;
J40__ON_ERROR:
	return (*J40__st)(unsafe.Pointer(st)).Err
}

func j40__render_to_u8x4_rgba(tls *libc.TLS, st uintptr, out uintptr) J40_err {
	bp := tls.Alloc(88)
	defer tls.Free(88)

	var im uintptr
	var f uintptr

	var maxpixel Int32_t
	var maxpixel2 Int32_t
	var i Int32_t
	var x Int32_t
	var y Int32_t
	var ec uintptr

	var p Int32_t

	var outpixels uintptr
	im = (*J40__st)(unsafe.Pointer(st)).Image
	f = (*J40__st)(unsafe.Pointer(st)).Frame
	*(*J40__plane)(unsafe.Pointer(bp + 32)) = J40__plane{}

__1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __4
	}
	goto J40__ON_ERROR
__4:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__image_st)(unsafe.Pointer(im)).Modular_16bit_buffers != 0)), int64(0)) != 0) {
		goto __5
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 867))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 867 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 867 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 867 + 3))))
	goto J40__ON_ERROR
__5:
	;
	goto __2
__2:
	if 0 != 0 {
		goto __1
	}
	goto __3
__3:
	;
__6:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __9
	}
	goto J40__ON_ERROR
__9:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__image_st)(unsafe.Pointer(im)).Bpp >= 8)), int64(0)) != 0) {
		goto __10
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 895))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 895 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 895 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 895 + 3))))
	goto J40__ON_ERROR
__10:
	;
	goto __7
__7:
	if 0 != 0 {
		goto __6
	}
	goto __8
__8:
	;
__11:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __14
	}
	goto J40__ON_ERROR
__14:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__image_st)(unsafe.Pointer(im)).Exp_bits == 0)), int64(0)) != 0) {
		goto __15
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 928))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 928 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 928 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 928 + 3))))
	goto J40__ON_ERROR
__15:
	;
	goto __12
__12:
	if 0 != 0 {
		goto __11
	}
	goto __13
__13:
	;
__16:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __19
	}
	goto J40__ON_ERROR
__19:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!!(!((*J40__frame_st)(unsafe.Pointer(f)).Do_ycbcr != 0) && (*J40__image_st)(unsafe.Pointer(im)).Xyb_encoded != 0 && (*J40__image_st)(unsafe.Pointer(im)).Cspace == J40__CS_GREY)), int64(0)) != 0) {
		goto __20
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 966))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 966 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 966 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 966 + 3))))
	goto J40__ON_ERROR
__20:
	;
	goto __17
__17:
	if 0 != 0 {
		goto __16
	}
	goto __18
__18:
	;
	i = 0
__21:
	if !(i < 3) {
		goto __23
	}
	*(*uintptr)(unsafe.Pointer(bp + uintptr(i)*8)) = (*J40__frame_st)(unsafe.Pointer(f)).Gmodular.Channel + uintptr(i)*24
	goto __22
__22:
	i++
	goto __21
	goto __23
__23:
	;
	*(*uintptr)(unsafe.Pointer(bp + 3*8)) = uintptr(0)
	i = 3
__24:
	if !(i < (*J40__frame_st)(unsafe.Pointer(f)).Gmodular.Num_channels) {
		goto __26
	}
	ec = (*J40__image_st)(unsafe.Pointer(im)).Ec_info + uintptr(i-3)*48
	if !((*J40__ec_info)(unsafe.Pointer(ec)).Type == J40__EC_ALPHA) {
		goto __27
	}
__28:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __31
	}
	goto J40__ON_ERROR
__31:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__ec_info)(unsafe.Pointer(ec)).Bpp == (*J40__image_st)(unsafe.Pointer(im)).Bpp && (*J40__ec_info)(unsafe.Pointer(ec)).Exp_bits == (*J40__image_st)(unsafe.Pointer(im)).Exp_bits)), int64(0)) != 0) {
		goto __32
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1011))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1011 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1011 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 1011 + 3))))
	goto J40__ON_ERROR
__32:
	;
	goto __29
__29:
	if 0 != 0 {
		goto __28
	}
	goto __30
__30:
	;
__33:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __36
	}
	goto J40__ON_ERROR
__36:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__ec_info)(unsafe.Pointer(ec)).Dim_shift == 0)), int64(0)) != 0) {
		goto __37
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1084))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1084 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1084 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 1084 + 3))))
	goto J40__ON_ERROR
__37:
	;
	goto __34
__34:
	if 0 != 0 {
		goto __33
	}
	goto __35
__35:
	;
__38:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __41
	}
	goto J40__ON_ERROR
__41:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!!(*(*int32)(unsafe.Pointer(ec + 32)) != 0)), int64(0)) != 0) {
		goto __42
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1125))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1125 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1125 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 1125 + 3))))
	goto J40__ON_ERROR
__42:
	;
	goto __39
__39:
	if 0 != 0 {
		goto __38
	}
	goto __40
__40:
	;
	*(*uintptr)(unsafe.Pointer(bp + 3*8)) = (*J40__frame_st)(unsafe.Pointer(f)).Gmodular.Channel + uintptr(i)*24
	goto __26
__27:
	;
	goto __25
__25:
	i++
	goto __24
	goto __26
__26:
	;
__43:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32((*J40__st)(unsafe.Pointer(st)).Err) != 0)), int64(0)) != 0) {
		goto __46
	}
	goto J40__ON_ERROR
__46:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!((*J40__frame_st)(unsafe.Pointer(f)).Width < 2147483647/4)), int64(0)) != 0) {
		goto __47
	}
	j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 61))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 61 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 61 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 61 + 3))))
	goto J40__ON_ERROR
__47:
	;
	goto __44
__44:
	if 0 != 0 {
		goto __43
	}
	goto __45
__45:
	;
__48:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(j40__init_plane(tls, st, J40__PLANE_U8, (*J40__frame_st)(unsafe.Pointer(f)).Width*4, (*J40__frame_st)(unsafe.Pointer(f)).Height, J40__PLANE_FORCE_PAD, bp+32) != 0)), int64(0)) != 0) {
		goto __51
	}
	goto J40__ON_ERROR
__51:
	;
	goto __49
__49:
	if 0 != 0 {
		goto __48
	}
	goto __50
__50:
	;
	maxpixel = int32(1)<<(*J40__image_st)(unsafe.Pointer(im)).Bpp - 1
	maxpixel2 = int32(1) << ((*J40__image_st)(unsafe.Pointer(im)).Bpp - 1)
	y = 0
__52:
	if !(y < (*J40__frame_st)(unsafe.Pointer(f)).Height) {
		goto __54
	}
	outpixels = func() uintptr {
		return uintptr((*J40__plane)(unsafe.Pointer(bp+32)).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(bp+32)).Stride_bytes)*Size_t(y))
	}()
	i = 0
__55:
	if !(i < 4) {
		goto __57
	}
	*(*uintptr)(unsafe.Pointer(bp + 56 + uintptr(i)*8)) = func() uintptr {
		if *(*uintptr)(unsafe.Pointer(bp + uintptr(i)*8)) != 0 {
			return func() uintptr {
				return uintptr((*J40__plane)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + uintptr(i)*8)))).Pixels) + uintptr(Size_t((*J40__plane)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + uintptr(i)*8)))).Stride_bytes)*Size_t(y))
			}()
		}
		return uintptr(0)
	}()
	goto __56
__56:
	i++
	goto __55
	goto __57
__57:
	;
	x = 0
__58:
	if !(x < (*J40__frame_st)(unsafe.Pointer(f)).Width) {
		goto __60
	}
	i = 0
__61:
	if !(i < 4) {
		goto __63
	}

	p = J40__min32(tls, J40__max32(tls, 0, func() int32 {
		if *(*uintptr)(unsafe.Pointer(bp + 56 + uintptr(i)*8)) != 0 {
			return int32(*(*Int16_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 56 + uintptr(i)*8)) + uintptr(x)*2)))
		}
		return maxpixel
	}()), maxpixel)
	*(*Uint8_t)(unsafe.Pointer(outpixels + uintptr(x*4+i))) = Uint8_t((p*255 + maxpixel2) / maxpixel)
	goto __62
__62:
	i++
	goto __61
	goto __63
__63:
	;
	goto __59
__59:
	x++
	goto __58
	goto __60
__60:
	;
	goto __53
__53:
	y++
	goto __52
	goto __54
__54:
	;
	*(*J40__plane)(unsafe.Pointer(out)) = *(*J40__plane)(unsafe.Pointer(bp + 32))
	return J40_err(0)

J40__ON_ERROR:
	j40__free_plane(tls, bp+32)
	return (*J40__st)(unsafe.Pointer(st)).Err
}

type J40__origin = uint32

var sJ40__ORIGIN_NAMES = [10]uintptr{
	ts + 1166,
	uintptr(0),
	ts + 1176, ts + 1186, ts + 1198, ts + 1212, ts + 1223, ts + 1237, ts + 1252, ts + 1265,
}

var sJ40__ERROR_STRINGS = [22]struct {
	Err         [4]int8
	__ccgo_pad1 [4]byte
	Msg         uintptr
	Suffix      uintptr
}{
	{Err: *(*[4]int8)(unsafe.Pointer(ts + 1270)), Msg: ts + 1275},
	{Err: *(*[4]int8)(unsafe.Pointer(ts + 1300)), Msg: ts + 1305},
	{Err: *(*[4]int8)(unsafe.Pointer(ts + 1329)), Msg: ts + 1334},
	{Err: *(*[4]int8)(unsafe.Pointer(ts + 1358)), Msg: ts + 1363},
	{Err: *(*[4]int8)(unsafe.Pointer(ts + 1386)), Msg: ts + 1391},
	{Err: *(*[4]int8)(unsafe.Pointer(ts + 1430)), Msg: ts + 1435},
	{Err: *(*[4]int8)(unsafe.Pointer(ts + 1461)), Msg: ts + 1466},
	{Err: *(*[4]int8)(unsafe.Pointer(ts + 5)), Msg: ts + 1502},
	{Err: *(*[4]int8)(unsafe.Pointer(ts + 94)), Msg: ts + 1516},
	{Err: *(*[4]int8)(unsafe.Pointer(ts + 74)), Msg: ts + 1551},
	{Err: *(*[4]int8)(unsafe.Pointer(ts + 61)), Msg: ts + 1571},
	{Err: *(*[4]int8)(unsafe.Pointer(ts + 66)), Msg: ts + 1612},
	{Err: *(*[4]int8)(unsafe.Pointer(ts)), Msg: ts + 1642},
	{Err: *(*[4]int8)(unsafe.Pointer(ts + 184)), Msg: ts + 1664},
	{Err: *(*[4]int8)(unsafe.Pointer(ts + 213)), Msg: ts + 1689},
	{Err: *(*[4]int8)(unsafe.Pointer(ts + 372)), Msg: ts + 1724},
	{Err: *(*[4]int8)(unsafe.Pointer(ts + 314)), Msg: ts + 1756},
	{Err: *(*[4]int8)(unsafe.Pointer(ts + 203)), Msg: ts + 1803},
	{Err: *(*[4]int8)(unsafe.Pointer(ts + 218)), Msg: ts + 1844},
	{Err: *(*[4]int8)(unsafe.Pointer(ts + 208)), Msg: ts + 1878},
	{Err: *(*[4]int8)(unsafe.Pointer(ts + 1929)), Msg: ts + 1934},
	{Err: *(*[4]int8)(unsafe.Pointer(ts + 1968)), Msg: ts + 1973},
}

// an API-level twin of `j40__st`; see `j40__st` documentation for the rationale for split.
type J40__inner = J40__inner1

func j40__set_alt_magic(tls *libc.TLS, err J40_err, saved_errno int32, origin J40__origin, image uintptr) J40_err {
	if err == Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 74))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 74 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 74 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 74 + 3))) {
		(*J40_image)(unsafe.Pointer(image)).Magic = Uint32_t(0x02c2eb6d) ^ origin
		*(*int32)(unsafe.Pointer(image + 8)) = saved_errno
		return err
	} else {
		(*J40_image)(unsafe.Pointer(image)).Magic = 0xb26a48aa ^ origin
		return libc.AssignPtrUint32(image+8, err)
	}
	return J40_err(0)
}

func j40__set_magic(tls *libc.TLS, inner uintptr, image uintptr) J40_err {
	(*J40_image)(unsafe.Pointer(image)).Magic = Uint32_t(0x7867ae21)
	*(*uintptr)(unsafe.Pointer(image + 8)) = inner
	(*J40__inner)(unsafe.Pointer(inner)).Magic = Uint32_t(0x5009e1c4)
	return J40_err(0)
}

func j40__check_image(tls *libc.TLS, image uintptr, neworigin J40__origin, outinner uintptr) J40_err {
	*(*uintptr)(unsafe.Pointer(outinner)) = uintptr(0)
	if !(image != 0) {
		return Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2001))))<<24 | Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2001 + 1))))<<16 | Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2001 + 2))))<<8 | Uint32_t(*(*int8)(unsafe.Pointer(ts + 2001 + 3)))
	}
	if (*J40_image)(unsafe.Pointer(image)).Magic != Uint32_t(0x7867ae21) {
		var origin Uint32_t = (*J40_image)(unsafe.Pointer(image)).Magic ^ 0xb26a48aa
		if Uint32_t(0) < origin && origin <= J40__ORIGIN_LAST_ALT_MAGIC {
			if origin == J40__ORIGIN_NEXT && neworigin != 0 {
				(*J40_image)(unsafe.Pointer(image)).Magic = 0xb26a48aa ^ neworigin
			}
			return *(*J40_err)(unsafe.Pointer(image + 8))
		}
		origin = (*J40_image)(unsafe.Pointer(image)).Magic ^ Uint32_t(0x02c2eb6d)
		if Uint32_t(0) < origin && origin <= J40__ORIGIN_LAST_ALT_MAGIC {
			return Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 74))))<<24 | Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 74 + 1))))<<16 | Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 74 + 2))))<<8 | Uint32_t(*(*int8)(unsafe.Pointer(ts + 74 + 3)))
		}
		return Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2006))))<<24 | Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2006 + 1))))<<16 | Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2006 + 2))))<<8 | Uint32_t(*(*int8)(unsafe.Pointer(ts + 2006 + 3)))
	}
	if !(int32(*(*uintptr)(unsafe.Pointer(image + 8))) != 0) || (*J40__inner1)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(image + 8)))).Magic != Uint32_t(0x5009e1c4) {
		return Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2006))))<<24 | Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2006 + 1))))<<16 | Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2006 + 2))))<<8 | Uint32_t(*(*int8)(unsafe.Pointer(ts + 2006 + 3)))
	}
	*(*uintptr)(unsafe.Pointer(outinner)) = *(*uintptr)(unsafe.Pointer(image + 8))
	return (*J40__inner1)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(image + 8)))).Err
}

func j40__init_state(tls *libc.TLS, st uintptr, inner uintptr) {
	(*J40__st)(unsafe.Pointer(st)).Err = J40_err(0)
	(*J40__st)(unsafe.Pointer(st)).Saved_errno = 0
	(*J40__st)(unsafe.Pointer(st)).Cannot_retry = 0
	(*J40__st)(unsafe.Pointer(st)).Bits = (*J40__inner)(unsafe.Pointer(inner)).Buffer.Checkpoint
	(*J40__st)(unsafe.Pointer(st)).Source = inner + 312
	(*J40__st)(unsafe.Pointer(st)).Container = inner + 360
	(*J40__st)(unsafe.Pointer(st)).Buffer = inner + 384
	(*J40__st)(unsafe.Pointer(st)).Image = inner + 456
	(*J40__st)(unsafe.Pointer(st)).Frame = inner + 672
	(*J40__st)(unsafe.Pointer(st)).Limits = uintptr(unsafe.Pointer(&sJ40__MAIN_LV5_LIMITS))
}

// TODO expose this with a proper interface
func j40__advance(tls *libc.TLS, inner uintptr, origin J40__origin) J40_err {
	bp := tls.Alloc(104)
	defer tls.Free(104)

	var st uintptr = bp
	var f uintptr

	j40__init_state(tls, st, inner)

	f = (*J40__st)(unsafe.Pointer(st)).Frame
	switch (*J40__inner)(unsafe.Pointer(inner)).State {
	case 0:
		j40__init_buffer(tls, st, int64(0), 9223372036854775807)
		j40__signature(tls, st)
		j40__image_metadata(tls, st)

		if (*J40__image_st1)(unsafe.Pointer((*J40__st)(unsafe.Pointer(st)).Image)).Want_icc != 0 {
			j40__icc(tls, st)
		}

		{
			j40__frame_header(tls, st)
			if !((*J40__frame_st)(unsafe.Pointer(f)).Is_last != 0) {
				j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2011))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2011 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2011 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 2011 + 3))))
			}
			if (*J40__frame_st)(unsafe.Pointer(f)).Type != J40__FRAME_REGULAR {
				j40__set_error(tls, st, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2033))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2033 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2033 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 2033 + 3))))
			}
			j40__read_toc(tls, st, inner+5880)

			j40__lf_global_in_section(tls, st, inner+5880)
			j40__hf_global_in_section(tls, st, inner+5880)

			j40__allocate_lf_groups(tls, st, inner+5872)

			if (*J40__inner)(unsafe.Pointer(inner)).Toc.Single_size != 0 {
				j40__lf_group(tls, st, (*J40__inner)(unsafe.Pointer(inner)).Lf_groups)
				j40__prepare_dq_matrices(tls, st)
				j40__prepare_orders(tls, st)
				j40__pass_group(tls, st, 0, 0, 0, (*J40__frame_st)(unsafe.Pointer(f)).Width, (*J40__frame_st)(unsafe.Pointer(f)).Height, int64(0), (*J40__inner)(unsafe.Pointer(inner)).Lf_groups)
				j40__zero_pad_to_byte(tls, st)
			} else {
				for (*J40__inner)(unsafe.Pointer(inner)).Toc.Nsections_read < (*J40__inner)(unsafe.Pointer(inner)).Toc.Nsections {
					j40__lf_or_pass_group_in_section(tls, st, inner+5880, (*J40__inner)(unsafe.Pointer(inner)).Lf_groups)
				}
			}

			j40__end_of_frame(tls, st, inner+5880)

			j40__inverse_transform(tls, st, f+384)
			if !((*J40__frame_st)(unsafe.Pointer(f)).Is_modular != 0) {
				j40__combine_vardct(tls, st, (*J40__inner)(unsafe.Pointer(inner)).Lf_groups)
			}

		}

		j40__no_more_bytes(tls, st)
		break

	default:
	}

	return J40_err(0)
}

func j40__free_inner(tls *libc.TLS, inner uintptr) {
	var i Int64_t
	var num_lf_groups Int64_t = (*J40__inner)(unsafe.Pointer(inner)).Frame.Num_lf_groups
	j40__free_source(tls, inner+312)
	j40__free_container(tls, inner+360)
	j40__free_buffer(tls, inner+384)
	j40__free_image_state(tls, inner+456)
	j40__free_frame_state(tls, inner+672)
	if (*J40__inner)(unsafe.Pointer(inner)).Lf_groups != 0 {
		for i = int64(0); i < num_lf_groups; i++ {
			j40__free_lf_group(tls, (*J40__inner)(unsafe.Pointer(inner)).Lf_groups+uintptr(i)*272)
		}
		libc.Xfree(tls, (*J40__inner)(unsafe.Pointer(inner)).Lf_groups)
	}
	j40__free_toc(tls, inner+5880)
	j40__free_plane(tls, inner+5952)
	j40__free(tls, inner)
}

func J40_error(tls *libc.TLS, image uintptr) J40_err {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	return j40__check_image(tls, image, J40__ORIGIN_NONE, bp)
}

func J40_error_string(tls *libc.TLS, image uintptr) uintptr {
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var origin Uint32_t
	var err J40_err
	var msg uintptr
	var suffix uintptr
	var buf uintptr
	var saved_errno int32
	var i Int32_t
	var corrupted_image Int32_t = 0

	if !(image != 0) {
		libc.Xsnprintf(tls, uintptr(unsafe.Pointer(&static_errbuf)), uint64(J40__ERRBUF_LEN), ts+2057, 0)
		return uintptr(unsafe.Pointer(&static_errbuf))
	}
	if (*J40_image)(unsafe.Pointer(image)).Magic == Uint32_t(0x7867ae21) {
		if *(*uintptr)(unsafe.Pointer(image + 8)) != 0 && (*J40__inner1)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(image + 8)))).Magic == Uint32_t(0x5009e1c4) {
			origin = (*J40__inner1)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(image + 8)))).Origin
			err = (*J40__inner1)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(image + 8)))).Err
			buf = *(*uintptr)(unsafe.Pointer(image + 8)) + 20
			saved_errno = (*J40__inner1)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(image + 8)))).Saved_errno
		} else {
			corrupted_image = 1
		}
	} else {
		origin = (*J40_image)(unsafe.Pointer(image)).Magic ^ 0xb26a48aa
		if Uint32_t(0) < origin && origin <= J40__ORIGIN_LAST_ALT_MAGIC {
			err = *(*J40_err)(unsafe.Pointer(image + 8))
			buf = uintptr(unsafe.Pointer(&static_errbuf))
			saved_errno = 0

			if origin == J40__ORIGIN_NEXT {
				origin = J40__ORIGIN_error_string
			}
		} else {
			origin = (*J40_image)(unsafe.Pointer(image)).Magic ^ Uint32_t(0x02c2eb6d)
			if Uint32_t(0) < origin && origin <= J40__ORIGIN_LAST_ALT_MAGIC {
				err = Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 74))))<<24 | Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 74 + 1))))<<16 | Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 74 + 2))))<<8 | Uint32_t(*(*int8)(unsafe.Pointer(ts + 74 + 3)))
				buf = uintptr(unsafe.Pointer(&static_errbuf))
				saved_errno = *(*int32)(unsafe.Pointer(image + 8))
			} else {
				corrupted_image = 1
			}
		}
	}
	if corrupted_image != 0 {
		libc.Xsnprintf(tls, uintptr(unsafe.Pointer(&static_errbuf)), uint64(J40__ERRBUF_LEN),
			ts+2107, 0)
		return uintptr(unsafe.Pointer(&static_errbuf))
	}

	msg = uintptr(0)
	suffix = ts + 2168
	for i = 0; i < int32(uint64(unsafe.Sizeof(sJ40__ERROR_STRINGS))/uint64(unsafe.Sizeof(struct {
		Err         [4]int8
		__ccgo_pad1 [4]byte
		Msg         uintptr
		Suffix      uintptr
	}{}))); i++ {
		if err == Uint32_t(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&sJ40__ERROR_STRINGS)) + uintptr(i)*24)))<<24|Uint32_t(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&sJ40__ERROR_STRINGS)) + uintptr(i)*24 + 1)))<<16|Uint32_t(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&sJ40__ERROR_STRINGS)) + uintptr(i)*24 + 2)))<<8|Uint32_t(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&sJ40__ERROR_STRINGS)) + uintptr(i)*24 + 3))) {
			msg = sJ40__ERROR_STRINGS[i].Msg
			if sJ40__ERROR_STRINGS[i].Suffix != 0 {
				suffix = sJ40__ERROR_STRINGS[i].Suffix
			}
			break
		}
	}
	if !(msg != 0) {
		libc.Xsnprintf(tls, buf, uint64(J40__ERRBUF_LEN), ts+2169,
			libc.VaList(bp, err>>24&J40_err(0xff), err>>16&J40_err(0xff), err>>8&J40_err(0xff), err&J40_err(0xff), sJ40__ORIGIN_NAMES[origin]))
	} else if saved_errno != 0 {
		libc.Xsnprintf(tls, buf, uint64(J40__ERRBUF_LEN), ts+2210,
			libc.VaList(bp+40, msg, sJ40__ORIGIN_NAMES[origin], suffix, libc.Xstrerror(tls, saved_errno)))
	} else {
		libc.Xsnprintf(tls, buf, uint64(J40__ERRBUF_LEN), ts+2233, libc.VaList(bp+72, msg, sJ40__ORIGIN_NAMES[origin], suffix))
	}
	return buf
}

var static_errbuf [256]int8

func J40_from_memory(tls *libc.TLS, image uintptr, buf uintptr, size Size_t, freefunc J40_memory_free_func) J40_err {
	bp := tls.Alloc(104)
	defer tls.Free(104)

	var inner uintptr

	var st uintptr = bp

	if !(image != 0) {
		return Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2001))))<<24 | Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2001 + 1))))<<16 | Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2001 + 2))))<<8 | Uint32_t(*(*int8)(unsafe.Pointer(ts + 2001 + 3)))
	}
	if !(buf != 0) {
		return j40__set_alt_magic(tls, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1300))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1300 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1300 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 1300 + 3))), 0, ORIGIN, image)
	}

	inner = j40__calloc(tls, uint64(1), uint64(unsafe.Sizeof(J40__inner{})))
	if !(inner != 0) {
		return j40__set_alt_magic(tls, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))), 0, ORIGIN, image)
	}

	j40__init_state(tls, st, inner)
	if j40__init_memory_source(tls, st, buf, size, freefunc, inner+312) != 0 {
		j40__free_inner(tls, inner)
		return j40__set_alt_magic(tls, (*J40__st)(unsafe.Pointer(st)).Err, (*J40__st)(unsafe.Pointer(st)).Saved_errno, ORIGIN, image)
	} else {
		return j40__set_magic(tls, inner, image)
	}
	return J40_err(0)
}

var ORIGIN J40__origin = J40__ORIGIN_from_memory

func J40_from_file(tls *libc.TLS, image uintptr, path uintptr) J40_err {
	bp := tls.Alloc(104)
	defer tls.Free(104)

	var inner uintptr

	var st uintptr = bp

	if !(image != 0) {
		return Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2001))))<<24 | Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2001 + 1))))<<16 | Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 2001 + 2))))<<8 | Uint32_t(*(*int8)(unsafe.Pointer(ts + 2001 + 3)))
	}
	if !(path != 0) {
		return j40__set_alt_magic(tls, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1270))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1270 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1270 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 1270 + 3))), 0, ORIGIN1, image)
	}

	inner = j40__calloc(tls, uint64(1), uint64(unsafe.Sizeof(J40__inner{})))
	if !(inner != 0) {
		return j40__set_alt_magic(tls, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 5 + 3))), 0, ORIGIN1, image)
	}

	j40__init_state(tls, st, inner)
	if j40__init_file_source(tls, st, path, inner+312) != 0 {
		j40__free_inner(tls, inner)
		return j40__set_alt_magic(tls, (*J40__st)(unsafe.Pointer(st)).Err, (*J40__st)(unsafe.Pointer(st)).Saved_errno, ORIGIN1, image)
	} else {
		return j40__set_magic(tls, inner, image)
	}
	return J40_err(0)
}

var ORIGIN1 J40__origin = J40__ORIGIN_from_file

func J40_output_format(tls *libc.TLS, image uintptr, channel Int32_t, format Int32_t) J40_err {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var err J40_err = j40__check_image(tls, image, ORIGIN2, bp)
		if err != 0 {
			return err
		}
	}

	if channel != J40_RGBA {
		return func() J40_err {
			(*J40__inner)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Origin = ORIGIN2
			return libc.AssignPtrUint32(*(*uintptr)(unsafe.Pointer(bp))+8, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1329))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1329 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1329 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 1329 + 3))))
		}()
	}
	if format != J40_U8X4 {
		return func() J40_err {
			(*J40__inner)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Origin = ORIGIN2
			return libc.AssignPtrUint32(*(*uintptr)(unsafe.Pointer(bp))+8, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1358))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1358 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1358 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 1358 + 3))))
		}()
	}
	if !(channel == J40_RGBA && format == J40_U8X4) {
		return func() J40_err {
			(*J40__inner)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Origin = ORIGIN2
			return libc.AssignPtrUint32(*(*uintptr)(unsafe.Pointer(bp))+8, Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1386))))<<24|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1386 + 1))))<<16|Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1386 + 2))))<<8|Uint32_t(*(*int8)(unsafe.Pointer(ts + 1386 + 3))))
		}()
	}

	return J40_err(0)
}

var ORIGIN2 J40__origin = J40__ORIGIN_output_format

func J40_next_frame(tls *libc.TLS, image uintptr) int32 {
	bp := tls.Alloc(112)
	defer tls.Free(112)

	var err J40_err

	err = j40__check_image(tls, image, ORIGIN3, bp)
	if err != 0 {
		return 0
	}

	err = j40__advance(tls, *(*uintptr)(unsafe.Pointer(bp)), ORIGIN3)
	if err != 0 {
		return 0
	}

	if (*J40__inner)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Rendered != 0 {
		return 0
	}

	j40__init_state(tls, bp+8, *(*uintptr)(unsafe.Pointer(bp)))
	err = j40__render_to_u8x4_rgba(tls, bp+8, *(*uintptr)(unsafe.Pointer(bp))+5952)
	if err != 0 {
		(*J40__inner)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Origin = ORIGIN3
		(*J40__inner)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Err = err
		return 0
	}
	(*J40__inner)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Rendered = 1
	return 1
}

var ORIGIN3 J40__origin = J40__ORIGIN_next_frame

func J40_current_frame(tls *libc.TLS, image uintptr) J40_frame {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var frame J40_frame
	var err J40_err

	err = j40__check_image(tls, image, ORIGIN4, bp)
	frame.Magic = Uint32_t(0x16351564)
	frame.Reserved = Uint32_t(0)
	frame.Inner = *(*uintptr)(unsafe.Pointer(bp))
	if err != 0 {
		return frame
	}

	if !((*J40__inner)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Rendered != 0) {
		if !(J40_next_frame(tls, image) != 0) {
			if (*J40__inner)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Err != 0 {
				return frame
			}
		}
	}

	frame.Magic = Uint32_t(0x08a296b3)
	return frame
}

var ORIGIN4 J40__origin = J40__ORIGIN_current_frame

func J40_frame_pixels_u8x4(tls *libc.TLS, frame uintptr, channel Int32_t) J40_pixels_u8x4 {
	var inner uintptr
	var pixels J40_pixels_u8x4

	if !(frame != 0) || (*J40_frame)(unsafe.Pointer(frame)).Magic != Uint32_t(0x08a296b3) {
		return ERROR_PIXELS
	}
	inner = (*J40_frame)(unsafe.Pointer(frame)).Inner
	if !(inner != 0) || (*J40__inner)(unsafe.Pointer(inner)).Magic != Uint32_t(0x5009e1c4) {
		return ERROR_PIXELS
	}

	if channel != J40_RGBA {
		return ERROR_PIXELS
	}

	if !((*J40__inner)(unsafe.Pointer(inner)).Rendered != 0) {
		(*J40__inner)(unsafe.Pointer(inner)).Origin = ORIGIN5
		(*J40__inner)(unsafe.Pointer(inner)).Err = Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1430))))<<24 | Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1430 + 1))))<<16 | Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1430 + 2))))<<8 | Uint32_t(*(*int8)(unsafe.Pointer(ts + 1430 + 3)))
		return ERROR_PIXELS
	}

	pixels.Width = (*J40__inner)(unsafe.Pointer(inner)).Rendered_rgba.Width / 4
	pixels.Height = (*J40__inner)(unsafe.Pointer(inner)).Rendered_rgba.Height
	pixels.Stride_bytes = (*J40__inner)(unsafe.Pointer(inner)).Rendered_rgba.Stride_bytes
	pixels.Data = uintptr((*J40__inner)(unsafe.Pointer(inner)).Rendered_rgba.Pixels)
	return pixels
}

var ORIGIN5 J40__origin = J40__ORIGIN_frame_pixels
var ERROR_PIXELS_DATA = [588]Uint8_t{
	Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255),
	Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255),
	Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255),
	Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255),
	Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255),
	Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(0 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255),
	Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255), Uint8_t(255), Uint8_t(0), Uint8_t(0), Uint8_t(1 * 255),
}
var ERROR_PIXELS = J40_pixels_u8x4{Width: 21, Height: 7, Stride_bytes: 21 * 4, Data: 0}

func J40_row_u8x4(tls *libc.TLS, pixels J40_pixels_u8x4, y Int32_t) uintptr {
	return pixels.Data + uintptr(Size_t(pixels.Stride_bytes)*Size_t(y))
}

func J40_free(tls *libc.TLS, image uintptr) {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	j40__check_image(tls, image, J40__ORIGIN_free, bp)
	if *(*uintptr)(unsafe.Pointer(bp)) != 0 {
		j40__free_inner(tls, *(*uintptr)(unsafe.Pointer(bp)))
	}
	(*J40_image)(unsafe.Pointer(image)).Magic = 0xb26a48aa ^ J40__ORIGIN_NEXT
	*(*J40_err)(unsafe.Pointer(image + 8)) = Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1461))))<<24 | Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1461 + 1))))<<16 | Uint32_t(Uint32_t(*(*int8)(unsafe.Pointer(ts + 1461 + 2))))<<8 | Uint32_t(*(*int8)(unsafe.Pointer(ts + 1461 + 3)))
}

func init() {
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&ERROR_PIXELS)) + 16)) = uintptr(unsafe.Pointer(&ERROR_PIXELS_DATA))
}

var ts1 = "shrt\x00!mem\x00.--- %s:%d: %s (w=%d h=%d @%p)\x00\n|\x00 %f\x00\n'--- %s:%d\n\x00bigg\x00flen\x00rb\x00open\x00read\x00seek\x00boxx\x00!jxl\x00ftyp\x00box?\x00jxlp\x00brot\x00pad0\x00enum\x00!fin\x00rnge\x00excs\x00hufd\x00iovf\x00clst\x00ansd\x00ans?\x00bpp?\x00exp?\x00name\x00slim\x00TODO: preview\x00fbpp\x00fm32\x00elim\x00fblk\x00ect?\x00csp?\x00wpt?\x00prm?\x00gama\x00tfn?\x00itt?\x00tone\x00TODO: up2_weight\x00TODO: up4_weight\x00TODO: up8_weight\x00tlim\x00tree\x00usmp\x00TODO: upsampling is not yet supported\x00mtre\x00xlim\x00rctt\x00rctc\x00rtcd\x00palp\x00palc\x00pald\x00TODO: squeeze channel effects\x00xfm?\x00pred\x00trec\x00povf\x00TODO: squeeze inverse transformation\x00dqm0\x00dqm?\x00band\x00TODO: upsampling is not yet implemented\x00pass\x00perm\x00TODO: patches\x00TODO: splines\x00TODO: noise\x00hfbc\x00vblk\x00dct?\x00TODO: ModularLfGroup decoding should continue here\x00TODO: subimage w/h depends on jpeg_upsampling\x00TODO: persist lfquant and use it in later frames\x00coef\x00TODO: don't keep this here\x00epf0\x00shrp\x00TODO: we don't yet do YCbCr or gray\x00TODO: !modular_16bit_buffers\x00TODO: specialize for 32-bit\x00TODO: does not yet support <8bpp\x00TODO: float samples not yet supported\x00TODO: direct luma encoding not yet supported\x00TODO: alpha channel has different bpp or sample type from color channels\x00TODO: subsampled alpha not yet supported\x00TODO: associated alpha not yet supported\x00(unknown)\x00from_file\x00from_memory\x00output_format\x00next_frame\x00current_frame\x00frame_pixels_*\x00error_string\x00free\x00Upt0\x00`path` parameter is NULL\x00Ubf0\x00`buf` parameter is NULL\x00Uch?\x00Bad `channel` parameter\x00Ufm?\x00Bad `format` parameter\x00Uof?\x00Bad `channel` and `format` combination\x00Urnd\x00Frame is not yet rendered\x00Ufre\x00Trying to reuse already freed image\x00Out of memory\x00The JPEG XL signature is not found\x00Failed to open file\x00Image dimensions are too large to handle\x00File is too lengthy to handle\x00Premature end of file\x00Image size limit reached\x00Extra channel number limit reached\x00Modular transform limit reached\x00Meta-adaptive tree size or depth limit reached\x00Given bits per pixel value is disallowed\x00Black extra channel is disallowed\x0032-bit buffers for modular encoding are disallowed\x00TODO\x00Unimplemented feature encountered\x00TEST\x00Testing-only error occurred\x00Uim0\x00Uim?\x00TODO: multiple frames\x00TODO: non-regular frame\x00`image` parameter is NULL during j40_error_string\x00`image` parameter is found corrupted during j40_error_string\x00\x00Decoding failed (%c%c%c%c) during j40_%s\x00%s during j40_%s%s: %s\x00%s during j40_%s%s\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
